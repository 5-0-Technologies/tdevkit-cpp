// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#include "core.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR Guid::Guid(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lo_)*/uint64_t{0u}
  , /*decltype(_impl_.hi_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GuidDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GuidDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GuidDefaultTypeInternal() {}
  union {
    Guid _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GuidDefaultTypeInternal _Guid_default_instance_;
PROTOBUF_CONSTEXPR DeviceContract::DeviceContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.layers_)*/{}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.note_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.appversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.devicetype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.devicestatus_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.validsectorid_)*/0
  , /*decltype(_impl_.lasttimeonline_)*/int64_t{0}
  , /*decltype(_impl_.validlasttimeonline_)*/int64_t{0}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.validx_)*/0
  , /*decltype(_impl_.validy_)*/0
  , /*decltype(_impl_.fallstatus_)*/0
  , /*decltype(_impl_.battery_)*/0
  , /*decltype(_impl_.devicetypeid_)*/0
  , /*decltype(_impl_.ismoving_)*/false
  , /*decltype(_impl_.position_)*/false
  , /*decltype(_impl_.geofence_)*/false
  , /*decltype(_impl_.heartbeat_)*/int64_t{0}
  , /*decltype(_impl_.geofencerange_)*/0u} {}
struct DeviceContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceContractDefaultTypeInternal() {}
  union {
    DeviceContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceContractDefaultTypeInternal _DeviceContract_default_instance_;
PROTOBUF_CONSTEXPR SectorContract::SectorContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gpsitems_)*/{}
  , /*decltype(_impl_.areas_)*/{}
  , /*decltype(_impl_.barriers_)*/{}
  , /*decltype(_impl_.beacons_)*/{}
  , /*decltype(_impl_.sensors_)*/{}
  , /*decltype(_impl_.paths_)*/{}
  , /*decltype(_impl_.guid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.configuration_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.barrierheight_)*/0
  , /*decltype(_impl_.barrierwidth_)*/0
  , /*decltype(_impl_.sectorheight_)*/0
  , /*decltype(_impl_.sectorwidth_)*/0
  , /*decltype(_impl_.modified_)*/int64_t{0}} {}
struct SectorContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SectorContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SectorContractDefaultTypeInternal() {}
  union {
    SectorContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SectorContractDefaultTypeInternal _SectorContract_default_instance_;
PROTOBUF_CONSTEXPR BranchContract::BranchContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sectors_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timezone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.guid_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.latitude_)*/0
  , /*decltype(_impl_.longtitude_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BranchContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BranchContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BranchContractDefaultTypeInternal() {}
  union {
    BranchContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BranchContractDefaultTypeInternal _BranchContract_default_instance_;
PROTOBUF_CONSTEXPR LayerContract::LayerContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.areas_)*/{}
  , /*decltype(_impl_.devices_)*/{}
  , /*decltype(_impl_.paths_)*/{}
  , /*decltype(_impl_.children_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.icon_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.created_)*/int64_t{0}
  , /*decltype(_impl_.updated_)*/int64_t{0}
  , /*decltype(_impl_.visible_)*/false
  , /*decltype(_impl_.localization_)*/false
  , /*decltype(_impl_.isnogo_)*/false} {}
struct LayerContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LayerContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LayerContractDefaultTypeInternal() {}
  union {
    LayerContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LayerContractDefaultTypeInternal _LayerContract_default_instance_;
PROTOBUF_CONSTEXPR PathContract::PathContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pathpoints_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.guid_)*/nullptr
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.layer_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.layerid_)*/0
  , /*decltype(_impl_.created_)*/int64_t{0}
  , /*decltype(_impl_.updated_)*/int64_t{0}} {}
struct PathContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathContractDefaultTypeInternal() {}
  union {
    PathContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathContractDefaultTypeInternal _PathContract_default_instance_;
PROTOBUF_CONSTEXPR PathPointContract::PathPointContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/nullptr
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.area_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.pathid_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.areaid_)*/0} {}
struct PathPointContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathPointContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathPointContractDefaultTypeInternal() {}
  union {
    PathPointContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathPointContractDefaultTypeInternal _PathPointContract_default_instance_;
PROTOBUF_CONSTEXPR AreaContract::AreaContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.coordinates_)*/{}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.guid_)*/nullptr
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.layer_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.layerid_)*/0
  , /*decltype(_impl_.created_)*/int64_t{0}
  , /*decltype(_impl_.updated_)*/int64_t{0}
  , /*decltype(_impl_.targetbranchid_)*/0} {}
struct AreaContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AreaContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AreaContractDefaultTypeInternal() {}
  union {
    AreaContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AreaContractDefaultTypeInternal _AreaContract_default_instance_;
PROTOBUF_CONSTEXPR PointContract::PointContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PointContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PointContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PointContractDefaultTypeInternal() {}
  union {
    PointContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PointContractDefaultTypeInternal _PointContract_default_instance_;
PROTOBUF_CONSTEXPR DeviceLocationContract::DeviceLocationContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.locations_)*/{}
  , /*decltype(_impl_.login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeviceLocationContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeviceLocationContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeviceLocationContractDefaultTypeInternal() {}
  union {
    DeviceLocationContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceLocationContractDefaultTypeInternal _DeviceLocationContract_default_instance_;
PROTOBUF_CONSTEXPR LocationContract::LocationContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.distances_)*/{}
  , /*decltype(_impl_.localizationareas_)*/{}
  , /*decltype(_impl_._localizationareas_cached_byte_size_)*/{0}
  , /*decltype(_impl_.nogoareas_)*/{}
  , /*decltype(_impl_._nogoareas_cached_byte_size_)*/{0}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.interval_)*/0
  , /*decltype(_impl_.battery_)*/0u
  , /*decltype(_impl_.ismoving_)*/false} {}
struct LocationContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocationContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocationContractDefaultTypeInternal() {}
  union {
    LocationContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocationContractDefaultTypeInternal _LocationContract_default_instance_;
PROTOBUF_CONSTEXPR DistanceContract::DistanceContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.beaconid_)*/0
  , /*decltype(_impl_.distance_)*/0
  , /*decltype(_impl_.rssi_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DistanceContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DistanceContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DistanceContractDefaultTypeInternal() {}
  union {
    DistanceContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DistanceContractDefaultTypeInternal _DistanceContract_default_instance_;
PROTOBUF_CONSTEXPR LoginContract::LoginContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoginContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoginContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoginContractDefaultTypeInternal() {}
  union {
    LoginContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginContractDefaultTypeInternal _LoginContract_default_instance_;
PROTOBUF_CONSTEXPR AuthenticationResponseContract::AuthenticationResponseContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.client_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.branch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expiration_)*/uint64_t{0u}
  , /*decltype(_impl_.created_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AuthenticationResponseContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AuthenticationResponseContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AuthenticationResponseContractDefaultTypeInternal() {}
  union {
    AuthenticationResponseContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthenticationResponseContractDefaultTypeInternal _AuthenticationResponseContract_default_instance_;
PROTOBUF_CONSTEXPR CredentialContract::CredentialContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.client_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CredentialContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CredentialContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CredentialContractDefaultTypeInternal() {}
  union {
    CredentialContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CredentialContractDefaultTypeInternal _CredentialContract_default_instance_;
PROTOBUF_CONSTEXPR PostResponseContract::PostResponseContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.errormessage_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.success_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PostResponseContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PostResponseContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PostResponseContractDefaultTypeInternal() {}
  union {
    PostResponseContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PostResponseContractDefaultTypeInternal _PostResponseContract_default_instance_;
PROTOBUF_CONSTEXPR GpsItemContract::GpsItemContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.latitude_)*/0
  , /*decltype(_impl_.longitude_)*/0} {}
struct GpsItemContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GpsItemContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GpsItemContractDefaultTypeInternal() {}
  union {
    GpsItemContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GpsItemContractDefaultTypeInternal _GpsItemContract_default_instance_;
PROTOBUF_CONSTEXPR BarrierContract::BarrierContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.branchid_)*/0} {}
struct BarrierContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BarrierContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BarrierContractDefaultTypeInternal() {}
  union {
    BarrierContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BarrierContractDefaultTypeInternal _BarrierContract_default_instance_;
PROTOBUF_CONSTEXPR BeaconContract::BeaconContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cluster_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.branch_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.branchid_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.typeid__)*/0
  , /*decltype(_impl_.active_)*/false
  , /*decltype(_impl_.position_)*/false
  , /*decltype(_impl_.geofence_)*/false
  , /*decltype(_impl_.usegps_)*/false
  , /*decltype(_impl_.lasttimeonline_)*/int64_t{0}
  , /*decltype(_impl_.geofencerange_)*/0} {}
struct BeaconContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeaconContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeaconContractDefaultTypeInternal() {}
  union {
    BeaconContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeaconContractDefaultTypeInternal _BeaconContract_default_instance_;
PROTOBUF_CONSTEXPR BeaconPositionContract::BeaconPositionContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct BeaconPositionContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BeaconPositionContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BeaconPositionContractDefaultTypeInternal() {}
  union {
    BeaconPositionContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BeaconPositionContractDefaultTypeInternal _BeaconPositionContract_default_instance_;
PROTOBUF_CONSTEXPR SensorContract::SensorContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sensordata_)*/{}
  , /*decltype(_impl_.login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.note_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sector_)*/nullptr
  , /*decltype(_impl_.area_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.battery_)*/0
  , /*decltype(_impl_.sectorid_)*/0
  , /*decltype(_impl_.areaid_)*/0} {}
struct SensorContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorContractDefaultTypeInternal() {}
  union {
    SensorContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorContractDefaultTypeInternal _SensorContract_default_instance_;
PROTOBUF_CONSTEXPR SensorDataContract::SensorDataContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.quantity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unit_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.datatype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.range_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.index_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SensorDataContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorDataContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorDataContractDefaultTypeInternal() {}
  union {
    SensorDataContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorDataContractDefaultTypeInternal _SensorDataContract_default_instance_;
PROTOBUF_CONSTEXPR SensorBatchContract::SensorBatchContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sensordata_)*/{}
  , /*decltype(_impl_.login_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SensorBatchContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorBatchContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorBatchContractDefaultTypeInternal() {}
  union {
    SensorBatchContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorBatchContractDefaultTypeInternal _SensorBatchContract_default_instance_;
PROTOBUF_CONSTEXPR SensorDataBatchContract::SensorDataBatchContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.quantity_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unit_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.datatype_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/int64_t{0}
  , /*decltype(_impl_.valueok_)*/false} {}
struct SensorDataBatchContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorDataBatchContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorDataBatchContractDefaultTypeInternal() {}
  union {
    SensorDataBatchContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorDataBatchContractDefaultTypeInternal _SensorDataBatchContract_default_instance_;
PROTOBUF_CONSTEXPR SensorAppInfoContract::SensorAppInfoContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SensorAppInfoContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SensorAppInfoContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SensorAppInfoContractDefaultTypeInternal() {}
  union {
    SensorAppInfoContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SensorAppInfoContractDefaultTypeInternal _SensorAppInfoContract_default_instance_;
PROTOBUF_CONSTEXPR RangeContract::RangeContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ranges_)*/{}
  , /*decltype(_impl_.type_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RangeContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangeContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangeContractDefaultTypeInternal() {}
  union {
    RangeContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangeContractDefaultTypeInternal _RangeContract_default_instance_;
PROTOBUF_CONSTEXPR RangesContract::RangesContract(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RangesContractDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RangesContractDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RangesContractDefaultTypeInternal() {}
  union {
    RangesContract _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RangesContractDefaultTypeInternal _RangesContract_default_instance_;
static ::_pb::Metadata file_level_metadata_core_2eproto[27];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_core_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_core_2eproto = nullptr;

const uint32_t TableStruct_core_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Guid, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Guid, _impl_.lo_),
  PROTOBUF_FIELD_OFFSET(::Guid, _impl_.hi_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.mac_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.validsectorid_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.note_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.lasttimeonline_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.validlasttimeonline_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.validx_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.validy_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.appversion_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.ismoving_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.fallstatus_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.battery_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.devicetypeid_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.devicetype_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.login_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.geofence_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.geofencerange_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.password_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.layers_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.devicestatus_),
  PROTOBUF_FIELD_OFFSET(::DeviceContract, _impl_.heartbeat_),
  ~0u,
  ~0u,
  ~0u,
  0,
  2,
  1,
  3,
  ~0u,
  ~0u,
  4,
  5,
  6,
  7,
  8,
  9,
  ~0u,
  ~0u,
  ~0u,
  10,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  12,
  ~0u,
  ~0u,
  ~0u,
  11,
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.guid_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.barrierheight_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.barrierwidth_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.sectorheight_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.sectorwidth_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.modified_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.gpsitems_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.areas_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.barriers_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.beacons_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.sensors_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.configuration_),
  PROTOBUF_FIELD_OFFSET(::SectorContract, _impl_.paths_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::BranchContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.guid_),
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.timezone_),
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.latitude_),
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.longtitude_),
  PROTOBUF_FIELD_OFFSET(::BranchContract, _impl_.sectors_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.icon_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.visible_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.localization_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.created_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.updated_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.areas_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.devices_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.isnogo_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.paths_),
  PROTOBUF_FIELD_OFFSET(::LayerContract, _impl_.children_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.guid_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.layerid_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.layer_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.pathpoints_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.created_),
  PROTOBUF_FIELD_OFFSET(::PathContract, _impl_.updated_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  1,
  3,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.pathid_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.areaid_),
  PROTOBUF_FIELD_OFFSET(::PathPointContract, _impl_.area_),
  ~0u,
  ~0u,
  0,
  ~0u,
  1,
  ~0u,
  ~0u,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.guid_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.layerid_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.layer_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.coordinates_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.created_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.updated_),
  PROTOBUF_FIELD_OFFSET(::AreaContract, _impl_.targetbranchid_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  1,
  3,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PointContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PointContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::PointContract, _impl_.y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DeviceLocationContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DeviceLocationContract, _impl_.login_),
  PROTOBUF_FIELD_OFFSET(::DeviceLocationContract, _impl_.locations_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.interval_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.battery_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.ismoving_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.distances_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.localizationareas_),
  PROTOBUF_FIELD_OFFSET(::LocationContract, _impl_.nogoareas_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DistanceContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DistanceContract, _impl_.beaconid_),
  PROTOBUF_FIELD_OFFSET(::DistanceContract, _impl_.distance_),
  PROTOBUF_FIELD_OFFSET(::DistanceContract, _impl_.rssi_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LoginContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LoginContract, _impl_.login_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AuthenticationResponseContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AuthenticationResponseContract, _impl_.client_),
  PROTOBUF_FIELD_OFFSET(::AuthenticationResponseContract, _impl_.token_),
  PROTOBUF_FIELD_OFFSET(::AuthenticationResponseContract, _impl_.expiration_),
  PROTOBUF_FIELD_OFFSET(::AuthenticationResponseContract, _impl_.created_),
  PROTOBUF_FIELD_OFFSET(::AuthenticationResponseContract, _impl_.branch_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CredentialContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CredentialContract, _impl_.client_),
  PROTOBUF_FIELD_OFFSET(::CredentialContract, _impl_.login_),
  PROTOBUF_FIELD_OFFSET(::CredentialContract, _impl_.password_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PostResponseContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PostResponseContract, _impl_.success_),
  PROTOBUF_FIELD_OFFSET(::PostResponseContract, _impl_.errormessage_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.latitude_),
  PROTOBUF_FIELD_OFFSET(::GpsItemContract, _impl_.longitude_),
  ~0u,
  ~0u,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::BarrierContract, _impl_.branch_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.branchid_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.branch_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.mac_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.active_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.typeid__),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.geofence_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.geofencerange_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.cluster_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.lasttimeonline_),
  PROTOBUF_FIELD_OFFSET(::BeaconContract, _impl_.usegps_),
  ~0u,
  2,
  0,
  ~0u,
  1,
  ~0u,
  3,
  4,
  5,
  ~0u,
  ~0u,
  6,
  ~0u,
  ~0u,
  8,
  ~0u,
  7,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::BeaconPositionContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::BeaconPositionContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::BeaconPositionContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::BeaconPositionContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::BeaconPositionContract, _impl_.y_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.login_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.title_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.mac_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.note_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.battery_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.sectorid_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.sector_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.sensordata_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.areaid_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.area_),
  PROTOBUF_FIELD_OFFSET(::SensorContract, _impl_.password_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  3,
  4,
  5,
  0,
  ~0u,
  6,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.unit_),
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.datatype_),
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.range_),
  PROTOBUF_FIELD_OFFSET(::SensorDataContract, _impl_.index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SensorBatchContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SensorBatchContract, _impl_.login_),
  PROTOBUF_FIELD_OFFSET(::SensorBatchContract, _impl_.sensordata_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_.quantity_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_.value_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_.unit_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_.datatype_),
  PROTOBUF_FIELD_OFFSET(::SensorDataBatchContract, _impl_.valueok_),
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SensorAppInfoContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SensorAppInfoContract, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::SensorAppInfoContract, _impl_.size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RangeContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RangeContract, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::RangeContract, _impl_.ranges_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RangesContract, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RangesContract, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::RangesContract, _impl_.value_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Guid)},
  { 8, 43, -1, sizeof(::DeviceContract)},
  { 72, 95, -1, sizeof(::SectorContract)},
  { 112, -1, -1, sizeof(::BranchContract)},
  { 125, 145, -1, sizeof(::LayerContract)},
  { 159, 179, -1, sizeof(::PathContract)},
  { 193, 209, -1, sizeof(::PathPointContract)},
  { 219, 240, -1, sizeof(::AreaContract)},
  { 255, -1, -1, sizeof(::PointContract)},
  { 263, -1, -1, sizeof(::DeviceLocationContract)},
  { 271, 288, -1, sizeof(::LocationContract)},
  { 299, -1, -1, sizeof(::DistanceContract)},
  { 308, -1, -1, sizeof(::LoginContract)},
  { 315, -1, -1, sizeof(::AuthenticationResponseContract)},
  { 326, -1, -1, sizeof(::CredentialContract)},
  { 335, -1, -1, sizeof(::PostResponseContract)},
  { 343, 356, -1, sizeof(::GpsItemContract)},
  { 363, 375, -1, sizeof(::BarrierContract)},
  { 381, 405, -1, sizeof(::BeaconContract)},
  { 423, 432, -1, sizeof(::BeaconPositionContract)},
  { 435, 455, -1, sizeof(::SensorContract)},
  { 469, -1, -1, sizeof(::SensorDataContract)},
  { 482, -1, -1, sizeof(::SensorBatchContract)},
  { 490, 502, -1, sizeof(::SensorDataBatchContract)},
  { 508, -1, -1, sizeof(::SensorAppInfoContract)},
  { 516, -1, -1, sizeof(::RangeContract)},
  { 524, -1, -1, sizeof(::RangesContract)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_Guid_default_instance_._instance,
  &::_DeviceContract_default_instance_._instance,
  &::_SectorContract_default_instance_._instance,
  &::_BranchContract_default_instance_._instance,
  &::_LayerContract_default_instance_._instance,
  &::_PathContract_default_instance_._instance,
  &::_PathPointContract_default_instance_._instance,
  &::_AreaContract_default_instance_._instance,
  &::_PointContract_default_instance_._instance,
  &::_DeviceLocationContract_default_instance_._instance,
  &::_LocationContract_default_instance_._instance,
  &::_DistanceContract_default_instance_._instance,
  &::_LoginContract_default_instance_._instance,
  &::_AuthenticationResponseContract_default_instance_._instance,
  &::_CredentialContract_default_instance_._instance,
  &::_PostResponseContract_default_instance_._instance,
  &::_GpsItemContract_default_instance_._instance,
  &::_BarrierContract_default_instance_._instance,
  &::_BeaconContract_default_instance_._instance,
  &::_BeaconPositionContract_default_instance_._instance,
  &::_SensorContract_default_instance_._instance,
  &::_SensorDataContract_default_instance_._instance,
  &::_SensorBatchContract_default_instance_._instance,
  &::_SensorDataBatchContract_default_instance_._instance,
  &::_SensorAppInfoContract_default_instance_._instance,
  &::_RangeContract_default_instance_._instance,
  &::_RangesContract_default_instance_._instance,
};

const char descriptor_table_protodef_core_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ncore.proto\"\036\n\004Guid\022\n\n\002lo\030\001 \001(\006\022\n\n\002hi\030\002"
  " \001(\006\"\302\006\n\016DeviceContract\022\n\n\002Id\030\001 \001(\005\022\013\n\003M"
  "ac\030\002 \001(\t\022\020\n\010BranchId\030\003 \001(\005\022$\n\006Branch\030\004 \001"
  "(\0132\017.BranchContractH\000\210\001\001\022\025\n\010SectorId\030\005 \001"
  "(\005H\001\210\001\001\022$\n\006Sector\030\006 \001(\0132\017.SectorContract"
  "H\002\210\001\001\022\032\n\rValidSectorId\030\007 \001(\005H\003\210\001\001\022\r\n\005Tit"
  "le\030\010 \001(\t\022\014\n\004Note\030\t \001(\t\022\033\n\016LastTimeOnline"
  "\030\n \001(\003H\004\210\001\001\022 \n\023ValidLastTimeOnline\030\013 \001(\003"
  "H\005\210\001\001\022\016\n\001X\030\014 \001(\002H\006\210\001\001\022\016\n\001Y\030\r \001(\002H\007\210\001\001\022\023\n"
  "\006ValidX\030\016 \001(\002H\010\210\001\001\022\023\n\006ValidY\030\017 \001(\002H\t\210\001\001\022"
  "\022\n\nAppVersion\030\020 \001(\t\022\020\n\010IsMoving\030\021 \001(\010\022\035\n"
  "\nFallStatus\030\022 \001(\0162\t.FallType\022\024\n\007Battery\030"
  "\023 \001(\002H\n\210\001\001\022\024\n\014DeviceTypeId\030\024 \001(\005\022\022\n\nDevi"
  "ceType\030\025 \001(\t\022\r\n\005Login\030\026 \001(\t\022\020\n\010Position\030"
  "\027 \001(\010\022\020\n\010Geofence\030\030 \001(\010\022\032\n\rGeofenceRange"
  "\030\031 \001(\rH\013\210\001\001\022\020\n\010Password\030\032 \001(\t\022\036\n\006Layers\030"
  "\033 \003(\0132\016.LayerContract\022\024\n\014DeviceStatus\030\034 "
  "\001(\t\022\026\n\tHeartbeat\030\035 \001(\003H\014\210\001\001B\t\n\007_BranchB\013"
  "\n\t_SectorIdB\t\n\007_SectorB\020\n\016_ValidSectorId"
  "B\021\n\017_LastTimeOnlineB\026\n\024_ValidLastTimeOnl"
  "ineB\004\n\002_XB\004\n\002_YB\t\n\007_ValidXB\t\n\007_ValidYB\n\n"
  "\010_BatteryB\020\n\016_GeofenceRangeB\014\n\n_Heartbea"
  "t\"\305\003\n\016SectorContract\022\n\n\002Id\030\001 \001(\005\022\014\n\004Guid"
  "\030\002 \001(\t\022\020\n\010BranchId\030\003 \001(\005\022$\n\006Branch\030\004 \001(\013"
  "2\017.BranchContractH\000\210\001\001\022\r\n\005Title\030\005 \001(\t\022\025\n"
  "\rBarrierHeight\030\006 \001(\002\022\024\n\014BarrierWidth\030\007 \001"
  "(\002\022\024\n\014SectorHeight\030\010 \001(\002\022\023\n\013SectorWidth\030"
  "\t \001(\002\022\020\n\010Modified\030\n \001(\003\022\"\n\010GpsItems\030\013 \003("
  "\0132\020.GpsItemContract\022\034\n\005Areas\030\014 \003(\0132\r.Are"
  "aContract\022\"\n\010Barriers\030\r \003(\0132\020.BarrierCon"
  "tract\022 \n\007Beacons\030\016 \003(\0132\017.BeaconContract\022"
  " \n\007Sensors\030\017 \003(\0132\017.SensorContract\022\025\n\rCon"
  "figuration\030\020 \001(\t\022\034\n\005Paths\030\021 \003(\0132\r.PathCo"
  "ntractB\t\n\007_Branch\"\232\001\n\016BranchContract\022\n\n\002"
  "Id\030\001 \001(\005\022\r\n\005Title\030\002 \001(\t\022\023\n\004Guid\030\003 \001(\0132\005."
  "Guid\022\020\n\010TimeZone\030\004 \001(\t\022\020\n\010Latitude\030\005 \001(\002"
  "\022\022\n\nLongtitude\030\006 \001(\002\022 \n\007Sectors\030\007 \003(\0132\017."
  "SectorContract\"\324\002\n\rLayerContract\022\n\n\002Id\030\001"
  " \001(\005\022\r\n\005Title\030\002 \001(\t\022\014\n\004Icon\030\003 \001(\t\022\020\n\010Bra"
  "nchId\030\004 \001(\005\022$\n\006Branch\030\005 \001(\0132\017.BranchCont"
  "ractH\000\210\001\001\022\017\n\007Visible\030\006 \001(\010\022\024\n\014Localizati"
  "on\030\007 \001(\010\022\017\n\007Created\030\010 \001(\003\022\017\n\007Updated\030\t \001"
  "(\003\022\034\n\005Areas\030\n \003(\0132\r.AreaContract\022 \n\007Devi"
  "ces\030\013 \003(\0132\017.DeviceContract\022\016\n\006IsNoGo\030\014 \001"
  "(\010\022\034\n\005Paths\030\r \003(\0132\r.PathContract\022 \n\010Chil"
  "dren\030\016 \003(\0132\016.LayerContractB\t\n\007_Branch\"\202\003"
  "\n\014PathContract\022\n\n\002Id\030\001 \001(\005\022\023\n\004Guid\030\002 \001(\013"
  "2\005.Guid\022\r\n\005Title\030\003 \001(\t\022\020\n\010SectorId\030\004 \001(\005"
  "\022$\n\006Sector\030\005 \001(\0132\017.SectorContractH\000\210\001\001\022\020"
  "\n\010BranchId\030\006 \001(\005\022$\n\006Branch\030\007 \001(\0132\017.Branc"
  "hContractH\001\210\001\001\022\024\n\007LayerId\030\010 \001(\005H\002\210\001\001\022\"\n\005"
  "Layer\030\t \001(\0132\016.LayerContractH\003\210\001\001\022\r\n\005Colo"
  "r\030\n \001(\t\022&\n\nPathPoints\030\013 \003(\0132\022.PathPointC"
  "ontract\022\023\n\013Description\030\014 \001(\t\022\017\n\007Created\030"
  "\r \001(\003\022\017\n\007Updated\030\016 \001(\003B\t\n\007_SectorB\t\n\007_Br"
  "anchB\n\n\010_LayerIdB\010\n\006_Layer\"\215\002\n\021PathPoint"
  "Contract\022\n\n\002Id\030\001 \001(\005\022\016\n\006PathId\030\002 \001(\005\022 \n\004"
  "Path\030\003 \001(\0132\r.PathContractH\000\210\001\001\022\020\n\010Branch"
  "Id\030\004 \001(\005\022$\n\006Branch\030\005 \001(\0132\017.BranchContrac"
  "tH\001\210\001\001\022\r\n\005Index\030\006 \001(\005\022\t\n\001X\030\007 \001(\002\022\t\n\001Y\030\010 "
  "\001(\002\022\023\n\006AreaId\030\t \001(\005H\002\210\001\001\022 \n\004Area\030\n \001(\0132\r"
  ".AreaContractH\003\210\001\001B\007\n\005_PathB\t\n\007_BranchB\t"
  "\n\007_AreaIdB\007\n\005_Area\"\257\003\n\014AreaContract\022\n\n\002I"
  "d\030\001 \001(\005\022\023\n\004Guid\030\002 \001(\0132\005.Guid\022\r\n\005Title\030\003 "
  "\001(\t\022\020\n\010SectorId\030\004 \001(\005\022$\n\006Sector\030\005 \001(\0132\017."
  "SectorContractH\000\210\001\001\022\020\n\010BranchId\030\006 \001(\005\022$\n"
  "\006Branch\030\007 \001(\0132\017.BranchContractH\001\210\001\001\022\024\n\007L"
  "ayerId\030\010 \001(\005H\002\210\001\001\022\"\n\005Layer\030\t \001(\0132\016.Layer"
  "ContractH\003\210\001\001\022\r\n\005Color\030\n \001(\t\022#\n\013Coordina"
  "tes\030\013 \003(\0132\016.PointContract\022\023\n\013Description"
  "\030\014 \001(\t\022\017\n\007Created\030\r \001(\003\022\017\n\007Updated\030\016 \001(\003"
  "\022\033\n\016TargetBranchId\030\017 \001(\005H\004\210\001\001B\t\n\007_Sector"
  "B\t\n\007_BranchB\n\n\010_LayerIdB\010\n\006_LayerB\021\n\017_Ta"
  "rgetBranchId\"%\n\rPointContract\022\t\n\001X\030\001 \001(\002"
  "\022\t\n\001Y\030\002 \001(\002\"M\n\026DeviceLocationContract\022\r\n"
  "\005Login\030\001 \001(\t\022$\n\tLocations\030\002 \003(\0132\021.Locati"
  "onContract\"\267\002\n\020LocationContract\022\021\n\tTimes"
  "tamp\030\001 \001(\003\022\025\n\010SectorId\030\002 \001(\005H\000\210\001\001\022\016\n\001X\030\003"
  " \001(\002H\001\210\001\001\022\016\n\001Y\030\004 \001(\002H\002\210\001\001\022\016\n\001Z\030\005 \001(\002H\003\210\001"
  "\001\022\025\n\010Interval\030\006 \001(\005H\004\210\001\001\022\024\n\007battery\030\007 \001("
  "\rH\005\210\001\001\022\020\n\010IsMoving\030\010 \001(\010\022$\n\tDistances\030\t "
  "\003(\0132\021.DistanceContract\022\031\n\021LocalizationAr"
  "eas\030\n \003(\005\022\021\n\tNoGoAreas\030\013 \003(\005B\013\n\t_SectorI"
  "dB\004\n\002_XB\004\n\002_YB\004\n\002_ZB\013\n\t_IntervalB\n\n\010_bat"
  "tery\"D\n\020DistanceContract\022\020\n\010BeaconId\030\001 \001"
  "(\005\022\020\n\010Distance\030\002 \001(\002\022\014\n\004RSSI\030\003 \001(\005\"\036\n\rLo"
  "ginContract\022\r\n\005Login\030\001 \001(\t\"t\n\036Authentica"
  "tionResponseContract\022\016\n\006Client\030\001 \001(\t\022\r\n\005"
  "Token\030\002 \001(\t\022\022\n\nExpiration\030\003 \001(\004\022\017\n\007Creat"
  "ed\030\004 \001(\004\022\016\n\006Branch\030\005 \001(\t\"E\n\022CredentialCo"
  "ntract\022\016\n\006Client\030\001 \001(\t\022\r\n\005Login\030\002 \001(\t\022\020\n"
  "\010Password\030\003 \001(\t\"=\n\024PostResponseContract\022"
  "\017\n\007Success\030\001 \001(\010\022\024\n\014ErrorMessage\030\002 \001(\t\"\233"
  "\001\n\017GpsItemContract\022\n\n\002Id\030\001 \001(\005\022\020\n\010Sector"
  "Id\030\002 \001(\005\022$\n\006Sector\030\003 \001(\0132\017.SectorContrac"
  "tH\000\210\001\001\022\t\n\001X\030\004 \001(\002\022\t\n\001Y\030\005 \001(\002\022\020\n\010Latitude"
  "\030\006 \001(\001\022\021\n\tLongitude\030\007 \001(\001B\t\n\007_Sector\"\255\001\n"
  "\017BarrierContract\022\t\n\001X\030\001 \001(\005\022\t\n\001Y\030\002 \001(\005\022\020"
  "\n\010SectorId\030\003 \001(\005\022$\n\006Sector\030\004 \001(\0132\017.Secto"
  "rContractH\000\210\001\001\022\020\n\010BranchId\030\005 \001(\005\022$\n\006Bran"
  "ch\030\006 \001(\0132\017.BranchContractH\001\210\001\001B\t\n\007_Secto"
  "rB\t\n\007_Branch\"\345\003\n\016BeaconContract\022\n\n\002Id\030\001 "
  "\001(\005\022\025\n\010SectorId\030\002 \001(\005H\000\210\001\001\022$\n\006Sector\030\003 \001"
  "(\0132\017.SectorContractH\001\210\001\001\022\020\n\010BranchId\030\004 \001"
  "(\005\022$\n\006Branch\030\005 \001(\0132\017.BranchContractH\002\210\001\001"
  "\022\013\n\003Mac\030\006 \001(\t\022\016\n\001X\030\007 \001(\002H\003\210\001\001\022\016\n\001Y\030\010 \001(\002"
  "H\004\210\001\001\022\016\n\001Z\030\t \001(\002H\005\210\001\001\022\r\n\005Title\030\n \001(\t\022\016\n\006"
  "Active\030\013 \001(\010\022\023\n\006TypeId\030\014 \001(\005H\006\210\001\001\022\020\n\010Pos"
  "ition\030\016 \001(\010\022\020\n\010Geofence\030\017 \001(\010\022\032\n\rGeofenc"
  "eRange\030\020 \001(\002H\007\210\001\001\022\017\n\007Cluster\030\021 \001(\t\022\033\n\016La"
  "stTimeOnline\030\022 \001(\003H\010\210\001\001\022\016\n\006UseGps\030\023 \001(\010B"
  "\013\n\t_SectorIdB\t\n\007_SectorB\t\n\007_BranchB\004\n\002_X"
  "B\004\n\002_YB\004\n\002_ZB\t\n\007_TypeIdB\020\n\016_GeofenceRang"
  "eB\021\n\017_LastTimeOnline\"P\n\026BeaconPositionCo"
  "ntract\022\n\n\002Id\030\001 \001(\005\022\016\n\001X\030\002 \001(\002H\000\210\001\001\022\016\n\001Y\030"
  "\003 \001(\002H\001\210\001\001B\004\n\002_XB\004\n\002_Y\"\376\002\n\016SensorContrac"
  "t\022\n\n\002Id\030\001 \001(\005\022\r\n\005Login\030\002 \001(\t\022\r\n\005Title\030\003 "
  "\001(\t\022\013\n\003Mac\030\004 \001(\t\022\014\n\004Note\030\005 \001(\t\022\016\n\001X\030\006 \001("
  "\002H\000\210\001\001\022\016\n\001y\030\007 \001(\002H\001\210\001\001\022\024\n\007Battery\030\010 \001(\002H"
  "\002\210\001\001\022\025\n\010SectorId\030\t \001(\005H\003\210\001\001\022$\n\006Sector\030\n "
  "\001(\0132\017.SectorContractH\004\210\001\001\022\'\n\nSensorData\030"
  "\013 \003(\0132\023.SensorDataContract\022\023\n\006AreaId\030\014 \001"
  "(\005H\005\210\001\001\022 \n\004Area\030\r \001(\0132\r.AreaContractH\006\210\001"
  "\001\022\020\n\010Password\030\016 \001(\tB\004\n\002_XB\004\n\002_yB\n\n\010_Batt"
  "eryB\013\n\t_SectorIdB\t\n\007_SectorB\t\n\007_AreaIdB\007"
  "\n\005_Area\"\226\001\n\022SensorDataContract\022\020\n\010Quanti"
  "ty\030\001 \001(\t\022\r\n\005Value\030\002 \001(\t\022\014\n\004Unit\030\003 \001(\t\022\020\n"
  "\010DataType\030\004 \001(\t\022\021\n\tTimestamp\030\005 \001(\003\022\035\n\005Ra"
  "nge\030\006 \001(\0132\016.RangeContract\022\r\n\005Index\030\007 \001(\005"
  "\"R\n\023SensorBatchContract\022\r\n\005Login\030\001 \001(\t\022,"
  "\n\nSensorData\030\002 \003(\0132\030.SensorDataBatchCont"
  "ract\"\217\001\n\027SensorDataBatchContract\022\021\n\tTime"
  "stamp\030\001 \001(\003\022\020\n\010Quantity\030\002 \001(\t\022\r\n\005Value\030\003"
  " \001(\t\022\014\n\004Unit\030\004 \001(\t\022\020\n\010DataType\030\005 \001(\t\022\024\n\007"
  "ValueOK\030\006 \001(\010H\000\210\001\001B\n\n\010_ValueOK\"6\n\025Sensor"
  "AppInfoContract\022\017\n\007Version\030\001 \001(\t\022\014\n\004Size"
  "\030\002 \001(\003\">\n\rRangeContract\022\014\n\004Type\030\001 \001(\t\022\037\n"
  "\006Ranges\030\002 \003(\0132\017.RangesContract\".\n\016Ranges"
  "Contract\022\r\n\005Color\030\001 \001(\t\022\r\n\005Value\030\002 \001(\t*|"
  "\n\010FallType\022\006\n\002OK\020\000\022\013\n\007MANDOWN\020\001\022\022\n\016MANDO"
  "WNCONTROL\020\002\022\023\n\017MANDOWNPOSITIVE\020\003\022\023\n\017MAND"
  "OWNNEGATIVE\020\004\022\035\n\031MANDOWNNEGATIVEAFTERLIM"
  "IT\020\005b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_core_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_core_2eproto = {
    false, false, 5692, descriptor_table_protodef_core_2eproto,
    "core.proto",
    &descriptor_table_core_2eproto_once, nullptr, 0, 27,
    schemas, file_default_instances, TableStruct_core_2eproto::offsets,
    file_level_metadata_core_2eproto, file_level_enum_descriptors_core_2eproto,
    file_level_service_descriptors_core_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_core_2eproto_getter() {
  return &descriptor_table_core_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_core_2eproto(&descriptor_table_core_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FallType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_core_2eproto);
  return file_level_enum_descriptors_core_2eproto[0];
}
bool FallType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Guid::_Internal {
 public:
};

Guid::Guid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Guid)
}
Guid::Guid(const Guid& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Guid* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lo_){}
    , decltype(_impl_.hi_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lo_, &from._impl_.lo_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hi_) -
    reinterpret_cast<char*>(&_impl_.lo_)) + sizeof(_impl_.hi_));
  // @@protoc_insertion_point(copy_constructor:Guid)
}

inline void Guid::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lo_){uint64_t{0u}}
    , decltype(_impl_.hi_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Guid::~Guid() {
  // @@protoc_insertion_point(destructor:Guid)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Guid::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Guid::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Guid::Clear() {
// @@protoc_insertion_point(message_clear_start:Guid)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.lo_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.hi_) -
      reinterpret_cast<char*>(&_impl_.lo_)) + sizeof(_impl_.hi_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Guid::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 lo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.lo_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 hi = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.hi_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Guid::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Guid)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 lo = 1;
  if (this->_internal_lo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_lo(), target);
  }

  // fixed64 hi = 2;
  if (this->_internal_hi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_hi(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Guid)
  return target;
}

size_t Guid::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Guid)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 lo = 1;
  if (this->_internal_lo() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 hi = 2;
  if (this->_internal_hi() != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Guid::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Guid::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Guid::GetClassData() const { return &_class_data_; }


void Guid::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Guid*>(&to_msg);
  auto& from = static_cast<const Guid&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Guid)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_lo() != 0) {
    _this->_internal_set_lo(from._internal_lo());
  }
  if (from._internal_hi() != 0) {
    _this->_internal_set_hi(from._internal_hi());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Guid::CopyFrom(const Guid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Guid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Guid::IsInitialized() const {
  return true;
}

void Guid::InternalSwap(Guid* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Guid, _impl_.hi_)
      + sizeof(Guid::_impl_.hi_)
      - PROTOBUF_FIELD_OFFSET(Guid, _impl_.lo_)>(
          reinterpret_cast<char*>(&_impl_.lo_),
          reinterpret_cast<char*>(&other->_impl_.lo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Guid::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[0]);
}

// ===================================================================

class DeviceContract::_Internal {
 public:
  using HasBits = decltype(std::declval<DeviceContract>()._impl_._has_bits_);
  static const ::BranchContract& branch(const DeviceContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sectorid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::SectorContract& sector(const DeviceContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validsectorid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lasttimeonline(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_validlasttimeonline(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_validx(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_validy(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_battery(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_geofencerange(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_heartbeat(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::BranchContract&
DeviceContract::_Internal::branch(const DeviceContract* msg) {
  return *msg->_impl_.branch_;
}
const ::SectorContract&
DeviceContract::_Internal::sector(const DeviceContract* msg) {
  return *msg->_impl_.sector_;
}
DeviceContract::DeviceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DeviceContract)
}
DeviceContract::DeviceContract(const DeviceContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeviceContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.layers_){from._impl_.layers_}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.note_){}
    , decltype(_impl_.appversion_){}
    , decltype(_impl_.devicetype_){}
    , decltype(_impl_.login_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.devicestatus_){}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.validsectorid_){}
    , decltype(_impl_.lasttimeonline_){}
    , decltype(_impl_.validlasttimeonline_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.validx_){}
    , decltype(_impl_.validy_){}
    , decltype(_impl_.fallstatus_){}
    , decltype(_impl_.battery_){}
    , decltype(_impl_.devicetypeid_){}
    , decltype(_impl_.ismoving_){}
    , decltype(_impl_.position_){}
    , decltype(_impl_.geofence_){}
    , decltype(_impl_.heartbeat_){}
    , decltype(_impl_.geofencerange_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.note_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.note_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_note().empty()) {
    _this->_impl_.note_.Set(from._internal_note(), 
      _this->GetArenaForAllocation());
  }
  _impl_.appversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.appversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_appversion().empty()) {
    _this->_impl_.appversion_.Set(from._internal_appversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.devicetype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicetype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_devicetype().empty()) {
    _this->_impl_.devicetype_.Set(from._internal_devicetype(), 
      _this->GetArenaForAllocation());
  }
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_login().empty()) {
    _this->_impl_.login_.Set(from._internal_login(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  _impl_.devicestatus_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicestatus_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_devicestatus().empty()) {
    _this->_impl_.devicestatus_.Set(from._internal_devicestatus(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.geofencerange_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.geofencerange_));
  // @@protoc_insertion_point(copy_constructor:DeviceContract)
}

inline void DeviceContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.layers_){arena}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.note_){}
    , decltype(_impl_.appversion_){}
    , decltype(_impl_.devicetype_){}
    , decltype(_impl_.login_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.devicestatus_){}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.validsectorid_){0}
    , decltype(_impl_.lasttimeonline_){int64_t{0}}
    , decltype(_impl_.validlasttimeonline_){int64_t{0}}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.validx_){0}
    , decltype(_impl_.validy_){0}
    , decltype(_impl_.fallstatus_){0}
    , decltype(_impl_.battery_){0}
    , decltype(_impl_.devicetypeid_){0}
    , decltype(_impl_.ismoving_){false}
    , decltype(_impl_.position_){false}
    , decltype(_impl_.geofence_){false}
    , decltype(_impl_.heartbeat_){int64_t{0}}
    , decltype(_impl_.geofencerange_){0u}
  };
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.note_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.note_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.appversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.appversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.devicetype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicetype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.devicestatus_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.devicestatus_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceContract::~DeviceContract() {
  // @@protoc_insertion_point(destructor:DeviceContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layers_.~RepeatedPtrField();
  _impl_.mac_.Destroy();
  _impl_.title_.Destroy();
  _impl_.note_.Destroy();
  _impl_.appversion_.Destroy();
  _impl_.devicetype_.Destroy();
  _impl_.login_.Destroy();
  _impl_.password_.Destroy();
  _impl_.devicestatus_.Destroy();
  if (this != internal_default_instance()) delete _impl_.branch_;
  if (this != internal_default_instance()) delete _impl_.sector_;
}

void DeviceContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceContract::Clear() {
// @@protoc_insertion_point(message_clear_start:DeviceContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layers_.Clear();
  _impl_.mac_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.note_.ClearToEmpty();
  _impl_.appversion_.ClearToEmpty();
  _impl_.devicetype_.ClearToEmpty();
  _impl_.login_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _impl_.devicestatus_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.branch_ != nullptr);
      _impl_.branch_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.sector_ != nullptr);
      _impl_.sector_->Clear();
    }
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.branchid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.branchid_));
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.sectorid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.sectorid_)) + sizeof(_impl_.y_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.validx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.validy_) -
        reinterpret_cast<char*>(&_impl_.validx_)) + sizeof(_impl_.validy_));
  }
  _impl_.fallstatus_ = 0;
  _impl_.battery_ = 0;
  ::memset(&_impl_.devicetypeid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.geofence_) -
      reinterpret_cast<char*>(&_impl_.devicetypeid_)) + sizeof(_impl_.geofence_));
  if (cached_has_bits & 0x00001800u) {
    ::memset(&_impl_.heartbeat_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.geofencerange_) -
        reinterpret_cast<char*>(&_impl_.heartbeat_)) + sizeof(_impl_.geofencerange_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeviceContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Mac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.Mac"));
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 SectorId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sectorid(&has_bits);
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ValidSectorId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_validsectorid(&has_bits);
          _impl_.validsectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Title = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // string Note = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_note();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.Note"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 LastTimeOnline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_lasttimeonline(&has_bits);
          _impl_.lasttimeonline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ValidLastTimeOnline = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_validlasttimeonline(&has_bits);
          _impl_.validlasttimeonline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float X = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Y = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float ValidX = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_validx(&has_bits);
          _impl_.validx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float ValidY = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_validy(&has_bits);
          _impl_.validy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string AppVersion = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_appversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.AppVersion"));
        } else
          goto handle_unusual;
        continue;
      // bool IsMoving = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _impl_.ismoving_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .FallType FallStatus = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_fallstatus(static_cast<::FallType>(val));
        } else
          goto handle_unusual;
        continue;
      // optional float Battery = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_battery(&has_bits);
          _impl_.battery_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 DeviceTypeId = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.devicetypeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string DeviceType = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_devicetype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.DeviceType"));
        } else
          goto handle_unusual;
        continue;
      // string Login = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.Login"));
        } else
          goto handle_unusual;
        continue;
      // bool Position = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Geofence = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _impl_.geofence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 GeofenceRange = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_geofencerange(&has_bits);
          _impl_.geofencerange_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Password = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.Password"));
        } else
          goto handle_unusual;
        continue;
      // repeated .LayerContract Layers = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_layers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string DeviceStatus = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          auto str = _internal_mutable_devicestatus();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceContract.DeviceStatus"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 Heartbeat = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_heartbeat(&has_bits);
          _impl_.heartbeat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DeviceContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // string Mac = 2;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.Mac");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mac(), target);
  }

  // int32 BranchId = 3;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 4;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // optional int32 SectorId = 5;
  if (_internal_has_sectorid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 6;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // optional int32 ValidSectorId = 7;
  if (_internal_has_validsectorid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_validsectorid(), target);
  }

  // string Title = 8;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.Title");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_title(), target);
  }

  // string Note = 9;
  if (!this->_internal_note().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_note().data(), static_cast<int>(this->_internal_note().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.Note");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_note(), target);
  }

  // optional int64 LastTimeOnline = 10;
  if (_internal_has_lasttimeonline()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_lasttimeonline(), target);
  }

  // optional int64 ValidLastTimeOnline = 11;
  if (_internal_has_validlasttimeonline()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_validlasttimeonline(), target);
  }

  // optional float X = 12;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_x(), target);
  }

  // optional float Y = 13;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_y(), target);
  }

  // optional float ValidX = 14;
  if (_internal_has_validx()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_validx(), target);
  }

  // optional float ValidY = 15;
  if (_internal_has_validy()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_validy(), target);
  }

  // string AppVersion = 16;
  if (!this->_internal_appversion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_appversion().data(), static_cast<int>(this->_internal_appversion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.AppVersion");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_appversion(), target);
  }

  // bool IsMoving = 17;
  if (this->_internal_ismoving() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_ismoving(), target);
  }

  // .FallType FallStatus = 18;
  if (this->_internal_fallstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      18, this->_internal_fallstatus(), target);
  }

  // optional float Battery = 19;
  if (_internal_has_battery()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_battery(), target);
  }

  // int32 DeviceTypeId = 20;
  if (this->_internal_devicetypeid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_devicetypeid(), target);
  }

  // string DeviceType = 21;
  if (!this->_internal_devicetype().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_devicetype().data(), static_cast<int>(this->_internal_devicetype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.DeviceType");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_devicetype(), target);
  }

  // string Login = 22;
  if (!this->_internal_login().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_login().data(), static_cast<int>(this->_internal_login().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.Login");
    target = stream->WriteStringMaybeAliased(
        22, this->_internal_login(), target);
  }

  // bool Position = 23;
  if (this->_internal_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_position(), target);
  }

  // bool Geofence = 24;
  if (this->_internal_geofence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_geofence(), target);
  }

  // optional uint32 GeofenceRange = 25;
  if (_internal_has_geofencerange()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_geofencerange(), target);
  }

  // string Password = 26;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.Password");
    target = stream->WriteStringMaybeAliased(
        26, this->_internal_password(), target);
  }

  // repeated .LayerContract Layers = 27;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_layers_size()); i < n; i++) {
    const auto& repfield = this->_internal_layers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string DeviceStatus = 28;
  if (!this->_internal_devicestatus().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_devicestatus().data(), static_cast<int>(this->_internal_devicestatus().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceContract.DeviceStatus");
    target = stream->WriteStringMaybeAliased(
        28, this->_internal_devicestatus(), target);
  }

  // optional int64 Heartbeat = 29;
  if (_internal_has_heartbeat()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(29, this->_internal_heartbeat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DeviceContract)
  return target;
}

size_t DeviceContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DeviceContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .LayerContract Layers = 27;
  total_size += 2UL * this->_internal_layers_size();
  for (const auto& msg : this->_impl_.layers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Mac = 2;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  // string Title = 8;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Note = 9;
  if (!this->_internal_note().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_note());
  }

  // string AppVersion = 16;
  if (!this->_internal_appversion().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_appversion());
  }

  // string DeviceType = 21;
  if (!this->_internal_devicetype().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_devicetype());
  }

  // string Login = 22;
  if (!this->_internal_login().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login());
  }

  // string Password = 26;
  if (!this->_internal_password().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  // string DeviceStatus = 28;
  if (!this->_internal_devicestatus().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_devicestatus());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .BranchContract Branch = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.branch_);
    }

    // optional .SectorContract Sector = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sector_);
    }

  }
  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 BranchId = 3;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  if (cached_has_bits & 0x000000fcu) {
    // optional int32 SectorId = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
    }

    // optional int32 ValidSectorId = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_validsectorid());
    }

    // optional int64 LastTimeOnline = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_lasttimeonline());
    }

    // optional int64 ValidLastTimeOnline = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_validlasttimeonline());
    }

    // optional float X = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float Y = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional float ValidX = 14;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float ValidY = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  // .FallType FallStatus = 18;
  if (this->_internal_fallstatus() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_fallstatus());
  }

  // optional float Battery = 19;
  if (cached_has_bits & 0x00000400u) {
    total_size += 2 + 4;
  }

  // int32 DeviceTypeId = 20;
  if (this->_internal_devicetypeid() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_devicetypeid());
  }

  // bool IsMoving = 17;
  if (this->_internal_ismoving() != 0) {
    total_size += 2 + 1;
  }

  // bool Position = 23;
  if (this->_internal_position() != 0) {
    total_size += 2 + 1;
  }

  // bool Geofence = 24;
  if (this->_internal_geofence() != 0) {
    total_size += 2 + 1;
  }

  if (cached_has_bits & 0x00001800u) {
    // optional int64 Heartbeat = 29;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_heartbeat());
    }

    // optional uint32 GeofenceRange = 25;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_geofencerange());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeviceContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeviceContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeviceContract::GetClassData() const { return &_class_data_; }


void DeviceContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeviceContract*>(&to_msg);
  auto& from = static_cast<const DeviceContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DeviceContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.layers_.MergeFrom(from._impl_.layers_);
  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_note().empty()) {
    _this->_internal_set_note(from._internal_note());
  }
  if (!from._internal_appversion().empty()) {
    _this->_internal_set_appversion(from._internal_appversion());
  }
  if (!from._internal_devicetype().empty()) {
    _this->_internal_set_devicetype(from._internal_devicetype());
  }
  if (!from._internal_login().empty()) {
    _this->_internal_set_login(from._internal_login());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  if (!from._internal_devicestatus().empty()) {
    _this->_internal_set_devicestatus(from._internal_devicestatus());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
          from._internal_branch());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
          from._internal_sector());
    }
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  if (cached_has_bits & 0x000000fcu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sectorid_ = from._impl_.sectorid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.validsectorid_ = from._impl_.validsectorid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.lasttimeonline_ = from._impl_.lasttimeonline_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.validlasttimeonline_ = from._impl_.validlasttimeonline_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.validx_ = from._impl_.validx_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.validy_ = from._impl_.validy_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_fallstatus() != 0) {
    _this->_internal_set_fallstatus(from._internal_fallstatus());
  }
  if (cached_has_bits & 0x00000400u) {
    _this->_internal_set_battery(from._internal_battery());
  }
  if (from._internal_devicetypeid() != 0) {
    _this->_internal_set_devicetypeid(from._internal_devicetypeid());
  }
  if (from._internal_ismoving() != 0) {
    _this->_internal_set_ismoving(from._internal_ismoving());
  }
  if (from._internal_position() != 0) {
    _this->_internal_set_position(from._internal_position());
  }
  if (from._internal_geofence() != 0) {
    _this->_internal_set_geofence(from._internal_geofence());
  }
  if (cached_has_bits & 0x00001800u) {
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.heartbeat_ = from._impl_.heartbeat_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.geofencerange_ = from._impl_.geofencerange_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeviceContract::CopyFrom(const DeviceContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DeviceContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceContract::IsInitialized() const {
  return true;
}

void DeviceContract::InternalSwap(DeviceContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.layers_.InternalSwap(&other->_impl_.layers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.note_, lhs_arena,
      &other->_impl_.note_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.appversion_, lhs_arena,
      &other->_impl_.appversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.devicetype_, lhs_arena,
      &other->_impl_.devicetype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_, lhs_arena,
      &other->_impl_.login_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.devicestatus_, lhs_arena,
      &other->_impl_.devicestatus_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DeviceContract, _impl_.geofencerange_)
      + sizeof(DeviceContract::_impl_.geofencerange_)
      - PROTOBUF_FIELD_OFFSET(DeviceContract, _impl_.branch_)>(
          reinterpret_cast<char*>(&_impl_.branch_),
          reinterpret_cast<char*>(&other->_impl_.branch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DeviceContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[1]);
}

// ===================================================================

class SectorContract::_Internal {
 public:
  using HasBits = decltype(std::declval<SectorContract>()._impl_._has_bits_);
  static const ::BranchContract& branch(const SectorContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::BranchContract&
SectorContract::_Internal::branch(const SectorContract* msg) {
  return *msg->_impl_.branch_;
}
SectorContract::SectorContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SectorContract)
}
SectorContract::SectorContract(const SectorContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SectorContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpsitems_){from._impl_.gpsitems_}
    , decltype(_impl_.areas_){from._impl_.areas_}
    , decltype(_impl_.barriers_){from._impl_.barriers_}
    , decltype(_impl_.beacons_){from._impl_.beacons_}
    , decltype(_impl_.sensors_){from._impl_.sensors_}
    , decltype(_impl_.paths_){from._impl_.paths_}
    , decltype(_impl_.guid_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.configuration_){}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.barrierheight_){}
    , decltype(_impl_.barrierwidth_){}
    , decltype(_impl_.sectorheight_){}
    , decltype(_impl_.sectorwidth_){}
    , decltype(_impl_.modified_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.guid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_guid().empty()) {
    _this->_impl_.guid_.Set(from._internal_guid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_configuration().empty()) {
    _this->_impl_.configuration_.Set(from._internal_configuration(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.modified_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.modified_));
  // @@protoc_insertion_point(copy_constructor:SectorContract)
}

inline void SectorContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gpsitems_){arena}
    , decltype(_impl_.areas_){arena}
    , decltype(_impl_.barriers_){arena}
    , decltype(_impl_.beacons_){arena}
    , decltype(_impl_.sensors_){arena}
    , decltype(_impl_.paths_){arena}
    , decltype(_impl_.guid_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.configuration_){}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.barrierheight_){0}
    , decltype(_impl_.barrierwidth_){0}
    , decltype(_impl_.sectorheight_){0}
    , decltype(_impl_.sectorwidth_){0}
    , decltype(_impl_.modified_){int64_t{0}}
  };
  _impl_.guid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SectorContract::~SectorContract() {
  // @@protoc_insertion_point(destructor:SectorContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SectorContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.gpsitems_.~RepeatedPtrField();
  _impl_.areas_.~RepeatedPtrField();
  _impl_.barriers_.~RepeatedPtrField();
  _impl_.beacons_.~RepeatedPtrField();
  _impl_.sensors_.~RepeatedPtrField();
  _impl_.paths_.~RepeatedPtrField();
  _impl_.guid_.Destroy();
  _impl_.title_.Destroy();
  _impl_.configuration_.Destroy();
  if (this != internal_default_instance()) delete _impl_.branch_;
}

void SectorContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SectorContract::Clear() {
// @@protoc_insertion_point(message_clear_start:SectorContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.gpsitems_.Clear();
  _impl_.areas_.Clear();
  _impl_.barriers_.Clear();
  _impl_.beacons_.Clear();
  _impl_.sensors_.Clear();
  _impl_.paths_.Clear();
  _impl_.guid_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.configuration_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.branch_ != nullptr);
    _impl_.branch_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.modified_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.modified_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SectorContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_guid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SectorContract.Guid"));
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Title = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SectorContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // float BarrierHeight = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.barrierheight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float BarrierWidth = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.barrierwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float SectorHeight = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.sectorheight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float SectorWidth = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.sectorwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int64 Modified = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.modified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .GpsItemContract GpsItems = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_gpsitems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .AreaContract Areas = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_areas(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .BarrierContract Barriers = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_barriers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .BeaconContract Beacons = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_beacons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .SensorContract Sensors = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string Configuration = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_configuration();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SectorContract.Configuration"));
        } else
          goto handle_unusual;
        continue;
      // repeated .PathContract Paths = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_paths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SectorContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SectorContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // string Guid = 2;
  if (!this->_internal_guid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_guid().data(), static_cast<int>(this->_internal_guid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SectorContract.Guid");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_guid(), target);
  }

  // int32 BranchId = 3;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 4;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // string Title = 5;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SectorContract.Title");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_title(), target);
  }

  // float BarrierHeight = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_barrierheight = this->_internal_barrierheight();
  uint32_t raw_barrierheight;
  memcpy(&raw_barrierheight, &tmp_barrierheight, sizeof(tmp_barrierheight));
  if (raw_barrierheight != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_barrierheight(), target);
  }

  // float BarrierWidth = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_barrierwidth = this->_internal_barrierwidth();
  uint32_t raw_barrierwidth;
  memcpy(&raw_barrierwidth, &tmp_barrierwidth, sizeof(tmp_barrierwidth));
  if (raw_barrierwidth != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_barrierwidth(), target);
  }

  // float SectorHeight = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_sectorheight = this->_internal_sectorheight();
  uint32_t raw_sectorheight;
  memcpy(&raw_sectorheight, &tmp_sectorheight, sizeof(tmp_sectorheight));
  if (raw_sectorheight != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_sectorheight(), target);
  }

  // float SectorWidth = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_sectorwidth = this->_internal_sectorwidth();
  uint32_t raw_sectorwidth;
  memcpy(&raw_sectorwidth, &tmp_sectorwidth, sizeof(tmp_sectorwidth));
  if (raw_sectorwidth != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_sectorwidth(), target);
  }

  // int64 Modified = 10;
  if (this->_internal_modified() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_modified(), target);
  }

  // repeated .GpsItemContract GpsItems = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_gpsitems_size()); i < n; i++) {
    const auto& repfield = this->_internal_gpsitems(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .AreaContract Areas = 12;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_areas_size()); i < n; i++) {
    const auto& repfield = this->_internal_areas(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(12, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .BarrierContract Barriers = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_barriers_size()); i < n; i++) {
    const auto& repfield = this->_internal_barriers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .BeaconContract Beacons = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_beacons_size()); i < n; i++) {
    const auto& repfield = this->_internal_beacons(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .SensorContract Sensors = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sensors_size()); i < n; i++) {
    const auto& repfield = this->_internal_sensors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string Configuration = 16;
  if (!this->_internal_configuration().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_configuration().data(), static_cast<int>(this->_internal_configuration().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SectorContract.Configuration");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_configuration(), target);
  }

  // repeated .PathContract Paths = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_paths_size()); i < n; i++) {
    const auto& repfield = this->_internal_paths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SectorContract)
  return target;
}

size_t SectorContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SectorContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .GpsItemContract GpsItems = 11;
  total_size += 1UL * this->_internal_gpsitems_size();
  for (const auto& msg : this->_impl_.gpsitems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .AreaContract Areas = 12;
  total_size += 1UL * this->_internal_areas_size();
  for (const auto& msg : this->_impl_.areas_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .BarrierContract Barriers = 13;
  total_size += 1UL * this->_internal_barriers_size();
  for (const auto& msg : this->_impl_.barriers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .BeaconContract Beacons = 14;
  total_size += 1UL * this->_internal_beacons_size();
  for (const auto& msg : this->_impl_.beacons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .SensorContract Sensors = 15;
  total_size += 1UL * this->_internal_sensors_size();
  for (const auto& msg : this->_impl_.sensors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PathContract Paths = 17;
  total_size += 2UL * this->_internal_paths_size();
  for (const auto& msg : this->_impl_.paths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Guid = 2;
  if (!this->_internal_guid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_guid());
  }

  // string Title = 5;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Configuration = 16;
  if (!this->_internal_configuration().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_configuration());
  }

  // optional .BranchContract Branch = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.branch_);
  }

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 BranchId = 3;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  // float BarrierHeight = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_barrierheight = this->_internal_barrierheight();
  uint32_t raw_barrierheight;
  memcpy(&raw_barrierheight, &tmp_barrierheight, sizeof(tmp_barrierheight));
  if (raw_barrierheight != 0) {
    total_size += 1 + 4;
  }

  // float BarrierWidth = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_barrierwidth = this->_internal_barrierwidth();
  uint32_t raw_barrierwidth;
  memcpy(&raw_barrierwidth, &tmp_barrierwidth, sizeof(tmp_barrierwidth));
  if (raw_barrierwidth != 0) {
    total_size += 1 + 4;
  }

  // float SectorHeight = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_sectorheight = this->_internal_sectorheight();
  uint32_t raw_sectorheight;
  memcpy(&raw_sectorheight, &tmp_sectorheight, sizeof(tmp_sectorheight));
  if (raw_sectorheight != 0) {
    total_size += 1 + 4;
  }

  // float SectorWidth = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_sectorwidth = this->_internal_sectorwidth();
  uint32_t raw_sectorwidth;
  memcpy(&raw_sectorwidth, &tmp_sectorwidth, sizeof(tmp_sectorwidth));
  if (raw_sectorwidth != 0) {
    total_size += 1 + 4;
  }

  // int64 Modified = 10;
  if (this->_internal_modified() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_modified());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SectorContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SectorContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SectorContract::GetClassData() const { return &_class_data_; }


void SectorContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SectorContract*>(&to_msg);
  auto& from = static_cast<const SectorContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SectorContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.gpsitems_.MergeFrom(from._impl_.gpsitems_);
  _this->_impl_.areas_.MergeFrom(from._impl_.areas_);
  _this->_impl_.barriers_.MergeFrom(from._impl_.barriers_);
  _this->_impl_.beacons_.MergeFrom(from._impl_.beacons_);
  _this->_impl_.sensors_.MergeFrom(from._impl_.sensors_);
  _this->_impl_.paths_.MergeFrom(from._impl_.paths_);
  if (!from._internal_guid().empty()) {
    _this->_internal_set_guid(from._internal_guid());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_configuration().empty()) {
    _this->_internal_set_configuration(from._internal_configuration());
  }
  if (from._internal_has_branch()) {
    _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
        from._internal_branch());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_barrierheight = from._internal_barrierheight();
  uint32_t raw_barrierheight;
  memcpy(&raw_barrierheight, &tmp_barrierheight, sizeof(tmp_barrierheight));
  if (raw_barrierheight != 0) {
    _this->_internal_set_barrierheight(from._internal_barrierheight());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_barrierwidth = from._internal_barrierwidth();
  uint32_t raw_barrierwidth;
  memcpy(&raw_barrierwidth, &tmp_barrierwidth, sizeof(tmp_barrierwidth));
  if (raw_barrierwidth != 0) {
    _this->_internal_set_barrierwidth(from._internal_barrierwidth());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_sectorheight = from._internal_sectorheight();
  uint32_t raw_sectorheight;
  memcpy(&raw_sectorheight, &tmp_sectorheight, sizeof(tmp_sectorheight));
  if (raw_sectorheight != 0) {
    _this->_internal_set_sectorheight(from._internal_sectorheight());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_sectorwidth = from._internal_sectorwidth();
  uint32_t raw_sectorwidth;
  memcpy(&raw_sectorwidth, &tmp_sectorwidth, sizeof(tmp_sectorwidth));
  if (raw_sectorwidth != 0) {
    _this->_internal_set_sectorwidth(from._internal_sectorwidth());
  }
  if (from._internal_modified() != 0) {
    _this->_internal_set_modified(from._internal_modified());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SectorContract::CopyFrom(const SectorContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SectorContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SectorContract::IsInitialized() const {
  return true;
}

void SectorContract::InternalSwap(SectorContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.gpsitems_.InternalSwap(&other->_impl_.gpsitems_);
  _impl_.areas_.InternalSwap(&other->_impl_.areas_);
  _impl_.barriers_.InternalSwap(&other->_impl_.barriers_);
  _impl_.beacons_.InternalSwap(&other->_impl_.beacons_);
  _impl_.sensors_.InternalSwap(&other->_impl_.sensors_);
  _impl_.paths_.InternalSwap(&other->_impl_.paths_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.guid_, lhs_arena,
      &other->_impl_.guid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.configuration_, lhs_arena,
      &other->_impl_.configuration_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SectorContract, _impl_.modified_)
      + sizeof(SectorContract::_impl_.modified_)
      - PROTOBUF_FIELD_OFFSET(SectorContract, _impl_.branch_)>(
          reinterpret_cast<char*>(&_impl_.branch_),
          reinterpret_cast<char*>(&other->_impl_.branch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SectorContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[2]);
}

// ===================================================================

class BranchContract::_Internal {
 public:
  static const ::Guid& guid(const BranchContract* msg);
};

const ::Guid&
BranchContract::_Internal::guid(const BranchContract* msg) {
  return *msg->_impl_.guid_;
}
BranchContract::BranchContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BranchContract)
}
BranchContract::BranchContract(const BranchContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BranchContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sectors_){from._impl_.sectors_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.guid_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.latitude_){}
    , decltype(_impl_.longtitude_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_timezone().empty()) {
    _this->_impl_.timezone_.Set(from._internal_timezone(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_guid()) {
    _this->_impl_.guid_ = new ::Guid(*from._impl_.guid_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.longtitude_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.longtitude_));
  // @@protoc_insertion_point(copy_constructor:BranchContract)
}

inline void BranchContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sectors_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.timezone_){}
    , decltype(_impl_.guid_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.latitude_){0}
    , decltype(_impl_.longtitude_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.timezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BranchContract::~BranchContract() {
  // @@protoc_insertion_point(destructor:BranchContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BranchContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sectors_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.timezone_.Destroy();
  if (this != internal_default_instance()) delete _impl_.guid_;
}

void BranchContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BranchContract::Clear() {
// @@protoc_insertion_point(message_clear_start:BranchContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sectors_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.timezone_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.guid_ != nullptr) {
    delete _impl_.guid_;
  }
  _impl_.guid_ = nullptr;
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.longtitude_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.longtitude_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BranchContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "BranchContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // .Guid Guid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_guid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string TimeZone = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_timezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "BranchContract.TimeZone"));
        } else
          goto handle_unusual;
        continue;
      // float Latitude = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Longtitude = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.longtitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .SectorContract Sectors = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sectors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BranchContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BranchContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // string Title = 2;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "BranchContract.Title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // .Guid Guid = 3;
  if (this->_internal_has_guid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::guid(this),
        _Internal::guid(this).GetCachedSize(), target, stream);
  }

  // string TimeZone = 4;
  if (!this->_internal_timezone().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_timezone().data(), static_cast<int>(this->_internal_timezone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "BranchContract.TimeZone");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_timezone(), target);
  }

  // float Latitude = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_latitude = this->_internal_latitude();
  uint32_t raw_latitude;
  memcpy(&raw_latitude, &tmp_latitude, sizeof(tmp_latitude));
  if (raw_latitude != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_latitude(), target);
  }

  // float Longtitude = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_longtitude = this->_internal_longtitude();
  uint32_t raw_longtitude;
  memcpy(&raw_longtitude, &tmp_longtitude, sizeof(tmp_longtitude));
  if (raw_longtitude != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_longtitude(), target);
  }

  // repeated .SectorContract Sectors = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sectors_size()); i < n; i++) {
    const auto& repfield = this->_internal_sectors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BranchContract)
  return target;
}

size_t BranchContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BranchContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SectorContract Sectors = 7;
  total_size += 1UL * this->_internal_sectors_size();
  for (const auto& msg : this->_impl_.sectors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Title = 2;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string TimeZone = 4;
  if (!this->_internal_timezone().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_timezone());
  }

  // .Guid Guid = 3;
  if (this->_internal_has_guid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.guid_);
  }

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // float Latitude = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_latitude = this->_internal_latitude();
  uint32_t raw_latitude;
  memcpy(&raw_latitude, &tmp_latitude, sizeof(tmp_latitude));
  if (raw_latitude != 0) {
    total_size += 1 + 4;
  }

  // float Longtitude = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_longtitude = this->_internal_longtitude();
  uint32_t raw_longtitude;
  memcpy(&raw_longtitude, &tmp_longtitude, sizeof(tmp_longtitude));
  if (raw_longtitude != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BranchContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BranchContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BranchContract::GetClassData() const { return &_class_data_; }


void BranchContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BranchContract*>(&to_msg);
  auto& from = static_cast<const BranchContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:BranchContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sectors_.MergeFrom(from._impl_.sectors_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_timezone().empty()) {
    _this->_internal_set_timezone(from._internal_timezone());
  }
  if (from._internal_has_guid()) {
    _this->_internal_mutable_guid()->::Guid::MergeFrom(
        from._internal_guid());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_latitude = from._internal_latitude();
  uint32_t raw_latitude;
  memcpy(&raw_latitude, &tmp_latitude, sizeof(tmp_latitude));
  if (raw_latitude != 0) {
    _this->_internal_set_latitude(from._internal_latitude());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_longtitude = from._internal_longtitude();
  uint32_t raw_longtitude;
  memcpy(&raw_longtitude, &tmp_longtitude, sizeof(tmp_longtitude));
  if (raw_longtitude != 0) {
    _this->_internal_set_longtitude(from._internal_longtitude());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BranchContract::CopyFrom(const BranchContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BranchContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BranchContract::IsInitialized() const {
  return true;
}

void BranchContract::InternalSwap(BranchContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sectors_.InternalSwap(&other->_impl_.sectors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.timezone_, lhs_arena,
      &other->_impl_.timezone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BranchContract, _impl_.longtitude_)
      + sizeof(BranchContract::_impl_.longtitude_)
      - PROTOBUF_FIELD_OFFSET(BranchContract, _impl_.guid_)>(
          reinterpret_cast<char*>(&_impl_.guid_),
          reinterpret_cast<char*>(&other->_impl_.guid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BranchContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[3]);
}

// ===================================================================

class LayerContract::_Internal {
 public:
  using HasBits = decltype(std::declval<LayerContract>()._impl_._has_bits_);
  static const ::BranchContract& branch(const LayerContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::BranchContract&
LayerContract::_Internal::branch(const LayerContract* msg) {
  return *msg->_impl_.branch_;
}
LayerContract::LayerContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LayerContract)
}
LayerContract::LayerContract(const LayerContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LayerContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.areas_){from._impl_.areas_}
    , decltype(_impl_.devices_){from._impl_.devices_}
    , decltype(_impl_.paths_){from._impl_.paths_}
    , decltype(_impl_.children_){from._impl_.children_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.icon_){}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.created_){}
    , decltype(_impl_.updated_){}
    , decltype(_impl_.visible_){}
    , decltype(_impl_.localization_){}
    , decltype(_impl_.isnogo_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_icon().empty()) {
    _this->_impl_.icon_.Set(from._internal_icon(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isnogo_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.isnogo_));
  // @@protoc_insertion_point(copy_constructor:LayerContract)
}

inline void LayerContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.areas_){arena}
    , decltype(_impl_.devices_){arena}
    , decltype(_impl_.paths_){arena}
    , decltype(_impl_.children_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.icon_){}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.created_){int64_t{0}}
    , decltype(_impl_.updated_){int64_t{0}}
    , decltype(_impl_.visible_){false}
    , decltype(_impl_.localization_){false}
    , decltype(_impl_.isnogo_){false}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LayerContract::~LayerContract() {
  // @@protoc_insertion_point(destructor:LayerContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LayerContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.areas_.~RepeatedPtrField();
  _impl_.devices_.~RepeatedPtrField();
  _impl_.paths_.~RepeatedPtrField();
  _impl_.children_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.icon_.Destroy();
  if (this != internal_default_instance()) delete _impl_.branch_;
}

void LayerContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LayerContract::Clear() {
// @@protoc_insertion_point(message_clear_start:LayerContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.areas_.Clear();
  _impl_.devices_.Clear();
  _impl_.paths_.Clear();
  _impl_.children_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.icon_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.branch_ != nullptr);
    _impl_.branch_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.isnogo_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.isnogo_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LayerContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Title = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LayerContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // string Icon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_icon();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LayerContract.Icon"));
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Visible = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Localization = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.localization_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 Created = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 Updated = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AreaContract Areas = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_areas(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .DeviceContract Devices = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool IsNoGo = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.isnogo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PathContract Paths = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_paths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .LayerContract Children = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_children(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LayerContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LayerContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // string Title = 2;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LayerContract.Title");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_title(), target);
  }

  // string Icon = 3;
  if (!this->_internal_icon().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_icon().data(), static_cast<int>(this->_internal_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LayerContract.Icon");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_icon(), target);
  }

  // int32 BranchId = 4;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 5;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // bool Visible = 6;
  if (this->_internal_visible() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_visible(), target);
  }

  // bool Localization = 7;
  if (this->_internal_localization() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_localization(), target);
  }

  // int64 Created = 8;
  if (this->_internal_created() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_created(), target);
  }

  // int64 Updated = 9;
  if (this->_internal_updated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_updated(), target);
  }

  // repeated .AreaContract Areas = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_areas_size()); i < n; i++) {
    const auto& repfield = this->_internal_areas(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .DeviceContract Devices = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_devices_size()); i < n; i++) {
    const auto& repfield = this->_internal_devices(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool IsNoGo = 12;
  if (this->_internal_isnogo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_isnogo(), target);
  }

  // repeated .PathContract Paths = 13;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_paths_size()); i < n; i++) {
    const auto& repfield = this->_internal_paths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(13, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .LayerContract Children = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_children_size()); i < n; i++) {
    const auto& repfield = this->_internal_children(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LayerContract)
  return target;
}

size_t LayerContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LayerContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AreaContract Areas = 10;
  total_size += 1UL * this->_internal_areas_size();
  for (const auto& msg : this->_impl_.areas_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .DeviceContract Devices = 11;
  total_size += 1UL * this->_internal_devices_size();
  for (const auto& msg : this->_impl_.devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PathContract Paths = 13;
  total_size += 1UL * this->_internal_paths_size();
  for (const auto& msg : this->_impl_.paths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .LayerContract Children = 14;
  total_size += 1UL * this->_internal_children_size();
  for (const auto& msg : this->_impl_.children_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Title = 2;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Icon = 3;
  if (!this->_internal_icon().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_icon());
  }

  // optional .BranchContract Branch = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.branch_);
  }

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 BranchId = 4;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  // int64 Created = 8;
  if (this->_internal_created() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_created());
  }

  // int64 Updated = 9;
  if (this->_internal_updated() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_updated());
  }

  // bool Visible = 6;
  if (this->_internal_visible() != 0) {
    total_size += 1 + 1;
  }

  // bool Localization = 7;
  if (this->_internal_localization() != 0) {
    total_size += 1 + 1;
  }

  // bool IsNoGo = 12;
  if (this->_internal_isnogo() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LayerContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LayerContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LayerContract::GetClassData() const { return &_class_data_; }


void LayerContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LayerContract*>(&to_msg);
  auto& from = static_cast<const LayerContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LayerContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.areas_.MergeFrom(from._impl_.areas_);
  _this->_impl_.devices_.MergeFrom(from._impl_.devices_);
  _this->_impl_.paths_.MergeFrom(from._impl_.paths_);
  _this->_impl_.children_.MergeFrom(from._impl_.children_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_icon().empty()) {
    _this->_internal_set_icon(from._internal_icon());
  }
  if (from._internal_has_branch()) {
    _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
        from._internal_branch());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  if (from._internal_created() != 0) {
    _this->_internal_set_created(from._internal_created());
  }
  if (from._internal_updated() != 0) {
    _this->_internal_set_updated(from._internal_updated());
  }
  if (from._internal_visible() != 0) {
    _this->_internal_set_visible(from._internal_visible());
  }
  if (from._internal_localization() != 0) {
    _this->_internal_set_localization(from._internal_localization());
  }
  if (from._internal_isnogo() != 0) {
    _this->_internal_set_isnogo(from._internal_isnogo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LayerContract::CopyFrom(const LayerContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LayerContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerContract::IsInitialized() const {
  return true;
}

void LayerContract::InternalSwap(LayerContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.areas_.InternalSwap(&other->_impl_.areas_);
  _impl_.devices_.InternalSwap(&other->_impl_.devices_);
  _impl_.paths_.InternalSwap(&other->_impl_.paths_);
  _impl_.children_.InternalSwap(&other->_impl_.children_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.icon_, lhs_arena,
      &other->_impl_.icon_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LayerContract, _impl_.isnogo_)
      + sizeof(LayerContract::_impl_.isnogo_)
      - PROTOBUF_FIELD_OFFSET(LayerContract, _impl_.branch_)>(
          reinterpret_cast<char*>(&_impl_.branch_),
          reinterpret_cast<char*>(&other->_impl_.branch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LayerContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[4]);
}

// ===================================================================

class PathContract::_Internal {
 public:
  using HasBits = decltype(std::declval<PathContract>()._impl_._has_bits_);
  static const ::Guid& guid(const PathContract* msg);
  static const ::SectorContract& sector(const PathContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BranchContract& branch(const PathContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_layerid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::LayerContract& layer(const PathContract* msg);
  static void set_has_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::Guid&
PathContract::_Internal::guid(const PathContract* msg) {
  return *msg->_impl_.guid_;
}
const ::SectorContract&
PathContract::_Internal::sector(const PathContract* msg) {
  return *msg->_impl_.sector_;
}
const ::BranchContract&
PathContract::_Internal::branch(const PathContract* msg) {
  return *msg->_impl_.branch_;
}
const ::LayerContract&
PathContract::_Internal::layer(const PathContract* msg) {
  return *msg->_impl_.layer_;
}
PathContract::PathContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PathContract)
}
PathContract::PathContract(const PathContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pathpoints_){from._impl_.pathpoints_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.guid_){nullptr}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.layer_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.layerid_){}
    , decltype(_impl_.created_){}
    , decltype(_impl_.updated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_guid()) {
    _this->_impl_.guid_ = new ::Guid(*from._impl_.guid_);
  }
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  if (from._internal_has_layer()) {
    _this->_impl_.layer_ = new ::LayerContract(*from._impl_.layer_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.updated_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.updated_));
  // @@protoc_insertion_point(copy_constructor:PathContract)
}

inline void PathContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pathpoints_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.guid_){nullptr}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.layer_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.layerid_){0}
    , decltype(_impl_.created_){int64_t{0}}
    , decltype(_impl_.updated_){int64_t{0}}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PathContract::~PathContract() {
  // @@protoc_insertion_point(destructor:PathContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pathpoints_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.color_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.guid_;
  if (this != internal_default_instance()) delete _impl_.sector_;
  if (this != internal_default_instance()) delete _impl_.branch_;
  if (this != internal_default_instance()) delete _impl_.layer_;
}

void PathContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathContract::Clear() {
// @@protoc_insertion_point(message_clear_start:PathContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pathpoints_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.color_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.guid_ != nullptr) {
    delete _impl_.guid_;
  }
  _impl_.guid_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.sector_ != nullptr);
      _impl_.sector_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.branch_ != nullptr);
      _impl_.branch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.layer_ != nullptr);
      _impl_.layer_->Clear();
    }
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.branchid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.branchid_));
  _impl_.layerid_ = 0;
  ::memset(&_impl_.created_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.updated_) -
      reinterpret_cast<char*>(&_impl_.created_)) + sizeof(_impl_.updated_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Guid Guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_guid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "PathContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // int32 SectorId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 LayerId = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_layerid(&has_bits);
          _impl_.layerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .LayerContract Layer = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_layer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Color = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "PathContract.Color"));
        } else
          goto handle_unusual;
        continue;
      // repeated .PathPointContract PathPoints = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pathpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string Description = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "PathContract.Description"));
        } else
          goto handle_unusual;
        continue;
      // int64 Created = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 Updated = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PathContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // .Guid Guid = 2;
  if (this->_internal_has_guid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::guid(this),
        _Internal::guid(this).GetCachedSize(), target, stream);
  }

  // string Title = 3;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "PathContract.Title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // int32 SectorId = 4;
  if (this->_internal_sectorid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 5;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // int32 BranchId = 6;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 7;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // optional int32 LayerId = 8;
  if (_internal_has_layerid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_layerid(), target);
  }

  // optional .LayerContract Layer = 9;
  if (_internal_has_layer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::layer(this),
        _Internal::layer(this).GetCachedSize(), target, stream);
  }

  // string Color = 10;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "PathContract.Color");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_color(), target);
  }

  // repeated .PathPointContract PathPoints = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pathpoints_size()); i < n; i++) {
    const auto& repfield = this->_internal_pathpoints(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string Description = 12;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "PathContract.Description");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_description(), target);
  }

  // int64 Created = 13;
  if (this->_internal_created() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_created(), target);
  }

  // int64 Updated = 14;
  if (this->_internal_updated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_updated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PathContract)
  return target;
}

size_t PathContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PathContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PathPointContract PathPoints = 11;
  total_size += 1UL * this->_internal_pathpoints_size();
  for (const auto& msg : this->_impl_.pathpoints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Title = 3;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Color = 10;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // string Description = 12;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .Guid Guid = 2;
  if (this->_internal_has_guid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.guid_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SectorContract Sector = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sector_);
    }

    // optional .BranchContract Branch = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.branch_);
    }

    // optional .LayerContract Layer = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.layer_);
    }

  }
  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 SectorId = 4;
  if (this->_internal_sectorid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
  }

  // int32 BranchId = 6;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  // optional int32 LayerId = 8;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_layerid());
  }

  // int64 Created = 13;
  if (this->_internal_created() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_created());
  }

  // int64 Updated = 14;
  if (this->_internal_updated() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_updated());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathContract::GetClassData() const { return &_class_data_; }


void PathContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathContract*>(&to_msg);
  auto& from = static_cast<const PathContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:PathContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pathpoints_.MergeFrom(from._impl_.pathpoints_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_guid()) {
    _this->_internal_mutable_guid()->::Guid::MergeFrom(
        from._internal_guid());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
          from._internal_sector());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
          from._internal_branch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_layer()->::LayerContract::MergeFrom(
          from._internal_layer());
    }
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_sectorid() != 0) {
    _this->_internal_set_sectorid(from._internal_sectorid());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  if (cached_has_bits & 0x00000008u) {
    _this->_internal_set_layerid(from._internal_layerid());
  }
  if (from._internal_created() != 0) {
    _this->_internal_set_created(from._internal_created());
  }
  if (from._internal_updated() != 0) {
    _this->_internal_set_updated(from._internal_updated());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathContract::CopyFrom(const PathContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PathContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathContract::IsInitialized() const {
  return true;
}

void PathContract::InternalSwap(PathContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pathpoints_.InternalSwap(&other->_impl_.pathpoints_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathContract, _impl_.updated_)
      + sizeof(PathContract::_impl_.updated_)
      - PROTOBUF_FIELD_OFFSET(PathContract, _impl_.guid_)>(
          reinterpret_cast<char*>(&_impl_.guid_),
          reinterpret_cast<char*>(&other->_impl_.guid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[5]);
}

// ===================================================================

class PathPointContract::_Internal {
 public:
  using HasBits = decltype(std::declval<PathPointContract>()._impl_._has_bits_);
  static const ::PathContract& path(const PathPointContract* msg);
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BranchContract& branch(const PathPointContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_areaid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::AreaContract& area(const PathPointContract* msg);
  static void set_has_area(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::PathContract&
PathPointContract::_Internal::path(const PathPointContract* msg) {
  return *msg->_impl_.path_;
}
const ::BranchContract&
PathPointContract::_Internal::branch(const PathPointContract* msg) {
  return *msg->_impl_.branch_;
}
const ::AreaContract&
PathPointContract::_Internal::area(const PathPointContract* msg) {
  return *msg->_impl_.area_;
}
PathPointContract::PathPointContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PathPointContract)
}
PathPointContract::PathPointContract(const PathPointContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathPointContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.area_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.pathid_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.areaid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::PathContract(*from._impl_.path_);
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  if (from._internal_has_area()) {
    _this->_impl_.area_ = new ::AreaContract(*from._impl_.area_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.areaid_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.areaid_));
  // @@protoc_insertion_point(copy_constructor:PathPointContract)
}

inline void PathPointContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.area_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.pathid_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.index_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.areaid_){0}
  };
}

PathPointContract::~PathPointContract() {
  // @@protoc_insertion_point(destructor:PathPointContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathPointContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.path_;
  if (this != internal_default_instance()) delete _impl_.branch_;
  if (this != internal_default_instance()) delete _impl_.area_;
}

void PathPointContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathPointContract::Clear() {
// @@protoc_insertion_point(message_clear_start:PathPointContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.path_ != nullptr);
      _impl_.path_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.branch_ != nullptr);
      _impl_.branch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.area_ != nullptr);
      _impl_.area_->Clear();
    }
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.y_));
  _impl_.areaid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathPointContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PathId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.pathid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PathContract Path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float X = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Y = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 AreaId = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_areaid(&has_bits);
          _impl_.areaid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AreaContract Area = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_area(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathPointContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PathPointContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // int32 PathId = 2;
  if (this->_internal_pathid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pathid(), target);
  }

  // optional .PathContract Path = 3;
  if (_internal_has_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  // int32 BranchId = 4;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 5;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // int32 Index = 6;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_index(), target);
  }

  // float X = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_x(), target);
  }

  // float Y = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_y(), target);
  }

  // optional int32 AreaId = 9;
  if (_internal_has_areaid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_areaid(), target);
  }

  // optional .AreaContract Area = 10;
  if (_internal_has_area()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::area(this),
        _Internal::area(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PathPointContract)
  return target;
}

size_t PathPointContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PathPointContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .PathContract Path = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_);
    }

    // optional .BranchContract Branch = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.branch_);
    }

    // optional .AreaContract Area = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.area_);
    }

  }
  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 PathId = 2;
  if (this->_internal_pathid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pathid());
  }

  // int32 BranchId = 4;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  // int32 Index = 6;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  // float X = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float Y = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // optional int32 AreaId = 9;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_areaid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathPointContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathPointContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathPointContract::GetClassData() const { return &_class_data_; }


void PathPointContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathPointContract*>(&to_msg);
  auto& from = static_cast<const PathPointContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:PathPointContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_path()->::PathContract::MergeFrom(
          from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
          from._internal_branch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_area()->::AreaContract::MergeFrom(
          from._internal_area());
    }
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_pathid() != 0) {
    _this->_internal_set_pathid(from._internal_pathid());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (cached_has_bits & 0x00000008u) {
    _this->_internal_set_areaid(from._internal_areaid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathPointContract::CopyFrom(const PathPointContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PathPointContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathPointContract::IsInitialized() const {
  return true;
}

void PathPointContract::InternalSwap(PathPointContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathPointContract, _impl_.areaid_)
      + sizeof(PathPointContract::_impl_.areaid_)
      - PROTOBUF_FIELD_OFFSET(PathPointContract, _impl_.path_)>(
          reinterpret_cast<char*>(&_impl_.path_),
          reinterpret_cast<char*>(&other->_impl_.path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathPointContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[6]);
}

// ===================================================================

class AreaContract::_Internal {
 public:
  using HasBits = decltype(std::declval<AreaContract>()._impl_._has_bits_);
  static const ::Guid& guid(const AreaContract* msg);
  static const ::SectorContract& sector(const AreaContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BranchContract& branch(const AreaContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_layerid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::LayerContract& layer(const AreaContract* msg);
  static void set_has_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_targetbranchid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::Guid&
AreaContract::_Internal::guid(const AreaContract* msg) {
  return *msg->_impl_.guid_;
}
const ::SectorContract&
AreaContract::_Internal::sector(const AreaContract* msg) {
  return *msg->_impl_.sector_;
}
const ::BranchContract&
AreaContract::_Internal::branch(const AreaContract* msg) {
  return *msg->_impl_.branch_;
}
const ::LayerContract&
AreaContract::_Internal::layer(const AreaContract* msg) {
  return *msg->_impl_.layer_;
}
AreaContract::AreaContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AreaContract)
}
AreaContract::AreaContract(const AreaContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AreaContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coordinates_){from._impl_.coordinates_}
    , decltype(_impl_.title_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.guid_){nullptr}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.layer_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.layerid_){}
    , decltype(_impl_.created_){}
    , decltype(_impl_.updated_){}
    , decltype(_impl_.targetbranchid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_guid()) {
    _this->_impl_.guid_ = new ::Guid(*from._impl_.guid_);
  }
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  if (from._internal_has_layer()) {
    _this->_impl_.layer_ = new ::LayerContract(*from._impl_.layer_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.targetbranchid_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.targetbranchid_));
  // @@protoc_insertion_point(copy_constructor:AreaContract)
}

inline void AreaContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.coordinates_){arena}
    , decltype(_impl_.title_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.guid_){nullptr}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.layer_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.layerid_){0}
    , decltype(_impl_.created_){int64_t{0}}
    , decltype(_impl_.updated_){int64_t{0}}
    , decltype(_impl_.targetbranchid_){0}
  };
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AreaContract::~AreaContract() {
  // @@protoc_insertion_point(destructor:AreaContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AreaContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.coordinates_.~RepeatedPtrField();
  _impl_.title_.Destroy();
  _impl_.color_.Destroy();
  _impl_.description_.Destroy();
  if (this != internal_default_instance()) delete _impl_.guid_;
  if (this != internal_default_instance()) delete _impl_.sector_;
  if (this != internal_default_instance()) delete _impl_.branch_;
  if (this != internal_default_instance()) delete _impl_.layer_;
}

void AreaContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AreaContract::Clear() {
// @@protoc_insertion_point(message_clear_start:AreaContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.coordinates_.Clear();
  _impl_.title_.ClearToEmpty();
  _impl_.color_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.guid_ != nullptr) {
    delete _impl_.guid_;
  }
  _impl_.guid_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.sector_ != nullptr);
      _impl_.sector_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.branch_ != nullptr);
      _impl_.branch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.layer_ != nullptr);
      _impl_.layer_->Clear();
    }
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.branchid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.branchid_));
  _impl_.layerid_ = 0;
  ::memset(&_impl_.created_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.updated_) -
      reinterpret_cast<char*>(&_impl_.created_)) + sizeof(_impl_.updated_));
  _impl_.targetbranchid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AreaContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Guid Guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_guid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AreaContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // int32 SectorId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 LayerId = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_layerid(&has_bits);
          _impl_.layerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .LayerContract Layer = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_layer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Color = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AreaContract.Color"));
        } else
          goto handle_unusual;
        continue;
      // repeated .PointContract Coordinates = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_coordinates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string Description = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AreaContract.Description"));
        } else
          goto handle_unusual;
        continue;
      // int64 Created = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 Updated = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 TargetBranchId = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_targetbranchid(&has_bits);
          _impl_.targetbranchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AreaContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AreaContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // .Guid Guid = 2;
  if (this->_internal_has_guid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::guid(this),
        _Internal::guid(this).GetCachedSize(), target, stream);
  }

  // string Title = 3;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AreaContract.Title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // int32 SectorId = 4;
  if (this->_internal_sectorid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 5;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // int32 BranchId = 6;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 7;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // optional int32 LayerId = 8;
  if (_internal_has_layerid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_layerid(), target);
  }

  // optional .LayerContract Layer = 9;
  if (_internal_has_layer()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::layer(this),
        _Internal::layer(this).GetCachedSize(), target, stream);
  }

  // string Color = 10;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AreaContract.Color");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_color(), target);
  }

  // repeated .PointContract Coordinates = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_coordinates_size()); i < n; i++) {
    const auto& repfield = this->_internal_coordinates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string Description = 12;
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AreaContract.Description");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_description(), target);
  }

  // int64 Created = 13;
  if (this->_internal_created() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_created(), target);
  }

  // int64 Updated = 14;
  if (this->_internal_updated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_updated(), target);
  }

  // optional int32 TargetBranchId = 15;
  if (_internal_has_targetbranchid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_targetbranchid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AreaContract)
  return target;
}

size_t AreaContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AreaContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PointContract Coordinates = 11;
  total_size += 1UL * this->_internal_coordinates_size();
  for (const auto& msg : this->_impl_.coordinates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Title = 3;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Color = 10;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // string Description = 12;
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // .Guid Guid = 2;
  if (this->_internal_has_guid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.guid_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .SectorContract Sector = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sector_);
    }

    // optional .BranchContract Branch = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.branch_);
    }

    // optional .LayerContract Layer = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.layer_);
    }

  }
  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 SectorId = 4;
  if (this->_internal_sectorid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
  }

  // int32 BranchId = 6;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  // optional int32 LayerId = 8;
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_layerid());
  }

  // int64 Created = 13;
  if (this->_internal_created() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_created());
  }

  // int64 Updated = 14;
  if (this->_internal_updated() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_updated());
  }

  // optional int32 TargetBranchId = 15;
  if (cached_has_bits & 0x00000010u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_targetbranchid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AreaContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AreaContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AreaContract::GetClassData() const { return &_class_data_; }


void AreaContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AreaContract*>(&to_msg);
  auto& from = static_cast<const AreaContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AreaContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.coordinates_.MergeFrom(from._impl_.coordinates_);
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (from._internal_has_guid()) {
    _this->_internal_mutable_guid()->::Guid::MergeFrom(
        from._internal_guid());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
          from._internal_sector());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
          from._internal_branch());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_layer()->::LayerContract::MergeFrom(
          from._internal_layer());
    }
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_sectorid() != 0) {
    _this->_internal_set_sectorid(from._internal_sectorid());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  if (cached_has_bits & 0x00000008u) {
    _this->_internal_set_layerid(from._internal_layerid());
  }
  if (from._internal_created() != 0) {
    _this->_internal_set_created(from._internal_created());
  }
  if (from._internal_updated() != 0) {
    _this->_internal_set_updated(from._internal_updated());
  }
  if (cached_has_bits & 0x00000010u) {
    _this->_internal_set_targetbranchid(from._internal_targetbranchid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AreaContract::CopyFrom(const AreaContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AreaContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AreaContract::IsInitialized() const {
  return true;
}

void AreaContract::InternalSwap(AreaContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.coordinates_.InternalSwap(&other->_impl_.coordinates_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AreaContract, _impl_.targetbranchid_)
      + sizeof(AreaContract::_impl_.targetbranchid_)
      - PROTOBUF_FIELD_OFFSET(AreaContract, _impl_.guid_)>(
          reinterpret_cast<char*>(&_impl_.guid_),
          reinterpret_cast<char*>(&other->_impl_.guid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AreaContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[7]);
}

// ===================================================================

class PointContract::_Internal {
 public:
};

PointContract::PointContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PointContract)
}
PointContract::PointContract(const PointContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PointContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:PointContract)
}

inline void PointContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PointContract::~PointContract() {
  // @@protoc_insertion_point(destructor:PointContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PointContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PointContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PointContract::Clear() {
// @@protoc_insertion_point(message_clear_start:PointContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PointContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float X = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PointContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PointContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float X = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float Y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PointContract)
  return target;
}

size_t PointContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PointContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float X = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float Y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PointContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PointContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PointContract::GetClassData() const { return &_class_data_; }


void PointContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PointContract*>(&to_msg);
  auto& from = static_cast<const PointContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:PointContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PointContract::CopyFrom(const PointContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PointContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointContract::IsInitialized() const {
  return true;
}

void PointContract::InternalSwap(PointContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PointContract, _impl_.y_)
      + sizeof(PointContract::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(PointContract, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PointContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[8]);
}

// ===================================================================

class DeviceLocationContract::_Internal {
 public:
};

DeviceLocationContract::DeviceLocationContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DeviceLocationContract)
}
DeviceLocationContract::DeviceLocationContract(const DeviceLocationContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeviceLocationContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.locations_){from._impl_.locations_}
    , decltype(_impl_.login_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_login().empty()) {
    _this->_impl_.login_.Set(from._internal_login(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:DeviceLocationContract)
}

inline void DeviceLocationContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.locations_){arena}
    , decltype(_impl_.login_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DeviceLocationContract::~DeviceLocationContract() {
  // @@protoc_insertion_point(destructor:DeviceLocationContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeviceLocationContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.locations_.~RepeatedPtrField();
  _impl_.login_.Destroy();
}

void DeviceLocationContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeviceLocationContract::Clear() {
// @@protoc_insertion_point(message_clear_start:DeviceLocationContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.locations_.Clear();
  _impl_.login_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeviceLocationContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Login = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DeviceLocationContract.Login"));
        } else
          goto handle_unusual;
        continue;
      // repeated .LocationContract Locations = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeviceLocationContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DeviceLocationContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Login = 1;
  if (!this->_internal_login().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_login().data(), static_cast<int>(this->_internal_login().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DeviceLocationContract.Login");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_login(), target);
  }

  // repeated .LocationContract Locations = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locations_size()); i < n; i++) {
    const auto& repfield = this->_internal_locations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DeviceLocationContract)
  return target;
}

size_t DeviceLocationContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DeviceLocationContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .LocationContract Locations = 2;
  total_size += 1UL * this->_internal_locations_size();
  for (const auto& msg : this->_impl_.locations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Login = 1;
  if (!this->_internal_login().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeviceLocationContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeviceLocationContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeviceLocationContract::GetClassData() const { return &_class_data_; }


void DeviceLocationContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeviceLocationContract*>(&to_msg);
  auto& from = static_cast<const DeviceLocationContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DeviceLocationContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.locations_.MergeFrom(from._impl_.locations_);
  if (!from._internal_login().empty()) {
    _this->_internal_set_login(from._internal_login());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeviceLocationContract::CopyFrom(const DeviceLocationContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DeviceLocationContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceLocationContract::IsInitialized() const {
  return true;
}

void DeviceLocationContract::InternalSwap(DeviceLocationContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.locations_.InternalSwap(&other->_impl_.locations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_, lhs_arena,
      &other->_impl_.login_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DeviceLocationContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[9]);
}

// ===================================================================

class LocationContract::_Internal {
 public:
  using HasBits = decltype(std::declval<LocationContract>()._impl_._has_bits_);
  static void set_has_sectorid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_battery(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

LocationContract::LocationContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LocationContract)
}
LocationContract::LocationContract(const LocationContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocationContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.distances_){from._impl_.distances_}
    , decltype(_impl_.localizationareas_){from._impl_.localizationareas_}
    , /*decltype(_impl_._localizationareas_cached_byte_size_)*/{0}
    , decltype(_impl_.nogoareas_){from._impl_.nogoareas_}
    , /*decltype(_impl_._nogoareas_cached_byte_size_)*/{0}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.interval_){}
    , decltype(_impl_.battery_){}
    , decltype(_impl_.ismoving_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ismoving_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.ismoving_));
  // @@protoc_insertion_point(copy_constructor:LocationContract)
}

inline void LocationContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.distances_){arena}
    , decltype(_impl_.localizationareas_){arena}
    , /*decltype(_impl_._localizationareas_cached_byte_size_)*/{0}
    , decltype(_impl_.nogoareas_){arena}
    , /*decltype(_impl_._nogoareas_cached_byte_size_)*/{0}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.interval_){0}
    , decltype(_impl_.battery_){0u}
    , decltype(_impl_.ismoving_){false}
  };
}

LocationContract::~LocationContract() {
  // @@protoc_insertion_point(destructor:LocationContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocationContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.distances_.~RepeatedPtrField();
  _impl_.localizationareas_.~RepeatedField();
  _impl_.nogoareas_.~RepeatedField();
}

void LocationContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocationContract::Clear() {
// @@protoc_insertion_point(message_clear_start:LocationContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.distances_.Clear();
  _impl_.localizationareas_.Clear();
  _impl_.nogoareas_.Clear();
  _impl_.timestamp_ = int64_t{0};
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.sectorid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.battery_) -
        reinterpret_cast<char*>(&_impl_.sectorid_)) + sizeof(_impl_.battery_));
  }
  _impl_.ismoving_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocationContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 Timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 SectorId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sectorid(&has_bits);
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float X = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Z = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 Interval = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_interval(&has_bits);
          _impl_.interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 battery = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_battery(&has_bits);
          _impl_.battery_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool IsMoving = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.ismoving_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .DistanceContract Distances = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_distances(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 LocalizationAreas = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_localizationareas(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 80) {
          _internal_add_localizationareas(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 NoGoAreas = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_nogoareas(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 88) {
          _internal_add_nogoareas(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocationContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LocationContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 Timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // optional int32 SectorId = 2;
  if (_internal_has_sectorid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sectorid(), target);
  }

  // optional float X = 3;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_x(), target);
  }

  // optional float Y = 4;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_y(), target);
  }

  // optional float Z = 5;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_z(), target);
  }

  // optional int32 Interval = 6;
  if (_internal_has_interval()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_interval(), target);
  }

  // optional uint32 battery = 7;
  if (_internal_has_battery()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_battery(), target);
  }

  // bool IsMoving = 8;
  if (this->_internal_ismoving() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_ismoving(), target);
  }

  // repeated .DistanceContract Distances = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_distances_size()); i < n; i++) {
    const auto& repfield = this->_internal_distances(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int32 LocalizationAreas = 10;
  {
    int byte_size = _impl_._localizationareas_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          10, _internal_localizationareas(), byte_size, target);
    }
  }

  // repeated int32 NoGoAreas = 11;
  {
    int byte_size = _impl_._nogoareas_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          11, _internal_nogoareas(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LocationContract)
  return target;
}

size_t LocationContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LocationContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .DistanceContract Distances = 9;
  total_size += 1UL * this->_internal_distances_size();
  for (const auto& msg : this->_impl_.distances_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 LocalizationAreas = 10;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.localizationareas_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._localizationareas_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int32 NoGoAreas = 11;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.nogoareas_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._nogoareas_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int64 Timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int32 SectorId = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
    }

    // optional float X = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float Y = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float Z = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 Interval = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_interval());
    }

    // optional uint32 battery = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_battery());
    }

  }
  // bool IsMoving = 8;
  if (this->_internal_ismoving() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocationContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocationContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocationContract::GetClassData() const { return &_class_data_; }


void LocationContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocationContract*>(&to_msg);
  auto& from = static_cast<const LocationContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LocationContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.distances_.MergeFrom(from._impl_.distances_);
  _this->_impl_.localizationareas_.MergeFrom(from._impl_.localizationareas_);
  _this->_impl_.nogoareas_.MergeFrom(from._impl_.nogoareas_);
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sectorid_ = from._impl_.sectorid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.interval_ = from._impl_.interval_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.battery_ = from._impl_.battery_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_ismoving() != 0) {
    _this->_internal_set_ismoving(from._internal_ismoving());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocationContract::CopyFrom(const LocationContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LocationContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocationContract::IsInitialized() const {
  return true;
}

void LocationContract::InternalSwap(LocationContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.distances_.InternalSwap(&other->_impl_.distances_);
  _impl_.localizationareas_.InternalSwap(&other->_impl_.localizationareas_);
  _impl_.nogoareas_.InternalSwap(&other->_impl_.nogoareas_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocationContract, _impl_.ismoving_)
      + sizeof(LocationContract::_impl_.ismoving_)
      - PROTOBUF_FIELD_OFFSET(LocationContract, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LocationContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[10]);
}

// ===================================================================

class DistanceContract::_Internal {
 public:
};

DistanceContract::DistanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DistanceContract)
}
DistanceContract::DistanceContract(const DistanceContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DistanceContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.beaconid_){}
    , decltype(_impl_.distance_){}
    , decltype(_impl_.rssi_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.beaconid_, &from._impl_.beaconid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rssi_) -
    reinterpret_cast<char*>(&_impl_.beaconid_)) + sizeof(_impl_.rssi_));
  // @@protoc_insertion_point(copy_constructor:DistanceContract)
}

inline void DistanceContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.beaconid_){0}
    , decltype(_impl_.distance_){0}
    , decltype(_impl_.rssi_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DistanceContract::~DistanceContract() {
  // @@protoc_insertion_point(destructor:DistanceContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DistanceContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DistanceContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DistanceContract::Clear() {
// @@protoc_insertion_point(message_clear_start:DistanceContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.beaconid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rssi_) -
      reinterpret_cast<char*>(&_impl_.beaconid_)) + sizeof(_impl_.rssi_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DistanceContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 BeaconId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.beaconid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float Distance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 RSSI = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DistanceContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DistanceContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 BeaconId = 1;
  if (this->_internal_beaconid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_beaconid(), target);
  }

  // float Distance = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance = this->_internal_distance();
  uint32_t raw_distance;
  memcpy(&raw_distance, &tmp_distance, sizeof(tmp_distance));
  if (raw_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_distance(), target);
  }

  // int32 RSSI = 3;
  if (this->_internal_rssi() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_rssi(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DistanceContract)
  return target;
}

size_t DistanceContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DistanceContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 BeaconId = 1;
  if (this->_internal_beaconid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_beaconid());
  }

  // float Distance = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance = this->_internal_distance();
  uint32_t raw_distance;
  memcpy(&raw_distance, &tmp_distance, sizeof(tmp_distance));
  if (raw_distance != 0) {
    total_size += 1 + 4;
  }

  // int32 RSSI = 3;
  if (this->_internal_rssi() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_rssi());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DistanceContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DistanceContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DistanceContract::GetClassData() const { return &_class_data_; }


void DistanceContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DistanceContract*>(&to_msg);
  auto& from = static_cast<const DistanceContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DistanceContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_beaconid() != 0) {
    _this->_internal_set_beaconid(from._internal_beaconid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_distance = from._internal_distance();
  uint32_t raw_distance;
  memcpy(&raw_distance, &tmp_distance, sizeof(tmp_distance));
  if (raw_distance != 0) {
    _this->_internal_set_distance(from._internal_distance());
  }
  if (from._internal_rssi() != 0) {
    _this->_internal_set_rssi(from._internal_rssi());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DistanceContract::CopyFrom(const DistanceContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DistanceContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DistanceContract::IsInitialized() const {
  return true;
}

void DistanceContract::InternalSwap(DistanceContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DistanceContract, _impl_.rssi_)
      + sizeof(DistanceContract::_impl_.rssi_)
      - PROTOBUF_FIELD_OFFSET(DistanceContract, _impl_.beaconid_)>(
          reinterpret_cast<char*>(&_impl_.beaconid_),
          reinterpret_cast<char*>(&other->_impl_.beaconid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DistanceContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[11]);
}

// ===================================================================

class LoginContract::_Internal {
 public:
};

LoginContract::LoginContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LoginContract)
}
LoginContract::LoginContract(const LoginContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LoginContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.login_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_login().empty()) {
    _this->_impl_.login_.Set(from._internal_login(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:LoginContract)
}

inline void LoginContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.login_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginContract::~LoginContract() {
  // @@protoc_insertion_point(destructor:LoginContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LoginContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.login_.Destroy();
}

void LoginContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LoginContract::Clear() {
// @@protoc_insertion_point(message_clear_start:LoginContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.login_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoginContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Login = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LoginContract.Login"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LoginContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LoginContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Login = 1;
  if (!this->_internal_login().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_login().data(), static_cast<int>(this->_internal_login().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LoginContract.Login");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_login(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LoginContract)
  return target;
}

size_t LoginContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LoginContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Login = 1;
  if (!this->_internal_login().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoginContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LoginContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoginContract::GetClassData() const { return &_class_data_; }


void LoginContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LoginContract*>(&to_msg);
  auto& from = static_cast<const LoginContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LoginContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_login().empty()) {
    _this->_internal_set_login(from._internal_login());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoginContract::CopyFrom(const LoginContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LoginContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginContract::IsInitialized() const {
  return true;
}

void LoginContract::InternalSwap(LoginContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_, lhs_arena,
      &other->_impl_.login_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LoginContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[12]);
}

// ===================================================================

class AuthenticationResponseContract::_Internal {
 public:
};

AuthenticationResponseContract::AuthenticationResponseContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AuthenticationResponseContract)
}
AuthenticationResponseContract::AuthenticationResponseContract(const AuthenticationResponseContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AuthenticationResponseContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.client_){}
    , decltype(_impl_.token_){}
    , decltype(_impl_.branch_){}
    , decltype(_impl_.expiration_){}
    , decltype(_impl_.created_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client().empty()) {
    _this->_impl_.client_.Set(from._internal_client(), 
      _this->GetArenaForAllocation());
  }
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_token().empty()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.branch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.branch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_branch().empty()) {
    _this->_impl_.branch_.Set(from._internal_branch(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.expiration_, &from._impl_.expiration_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.created_) -
    reinterpret_cast<char*>(&_impl_.expiration_)) + sizeof(_impl_.created_));
  // @@protoc_insertion_point(copy_constructor:AuthenticationResponseContract)
}

inline void AuthenticationResponseContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.client_){}
    , decltype(_impl_.token_){}
    , decltype(_impl_.branch_){}
    , decltype(_impl_.expiration_){uint64_t{0u}}
    , decltype(_impl_.created_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.client_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.branch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.branch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthenticationResponseContract::~AuthenticationResponseContract() {
  // @@protoc_insertion_point(destructor:AuthenticationResponseContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AuthenticationResponseContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_.Destroy();
  _impl_.token_.Destroy();
  _impl_.branch_.Destroy();
}

void AuthenticationResponseContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AuthenticationResponseContract::Clear() {
// @@protoc_insertion_point(message_clear_start:AuthenticationResponseContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.client_.ClearToEmpty();
  _impl_.token_.ClearToEmpty();
  _impl_.branch_.ClearToEmpty();
  ::memset(&_impl_.expiration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.created_) -
      reinterpret_cast<char*>(&_impl_.expiration_)) + sizeof(_impl_.created_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AuthenticationResponseContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AuthenticationResponseContract.Client"));
        } else
          goto handle_unusual;
        continue;
      // string Token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AuthenticationResponseContract.Token"));
        } else
          goto handle_unusual;
        continue;
      // uint64 Expiration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.expiration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 Created = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Branch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_branch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AuthenticationResponseContract.Branch"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AuthenticationResponseContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AuthenticationResponseContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Client = 1;
  if (!this->_internal_client().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client().data(), static_cast<int>(this->_internal_client().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AuthenticationResponseContract.Client");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client(), target);
  }

  // string Token = 2;
  if (!this->_internal_token().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AuthenticationResponseContract.Token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token(), target);
  }

  // uint64 Expiration = 3;
  if (this->_internal_expiration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_expiration(), target);
  }

  // uint64 Created = 4;
  if (this->_internal_created() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_created(), target);
  }

  // string Branch = 5;
  if (!this->_internal_branch().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_branch().data(), static_cast<int>(this->_internal_branch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AuthenticationResponseContract.Branch");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_branch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AuthenticationResponseContract)
  return target;
}

size_t AuthenticationResponseContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AuthenticationResponseContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Client = 1;
  if (!this->_internal_client().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client());
  }

  // string Token = 2;
  if (!this->_internal_token().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_token());
  }

  // string Branch = 5;
  if (!this->_internal_branch().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_branch());
  }

  // uint64 Expiration = 3;
  if (this->_internal_expiration() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_expiration());
  }

  // uint64 Created = 4;
  if (this->_internal_created() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_created());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AuthenticationResponseContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AuthenticationResponseContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AuthenticationResponseContract::GetClassData() const { return &_class_data_; }


void AuthenticationResponseContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AuthenticationResponseContract*>(&to_msg);
  auto& from = static_cast<const AuthenticationResponseContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AuthenticationResponseContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_client().empty()) {
    _this->_internal_set_client(from._internal_client());
  }
  if (!from._internal_token().empty()) {
    _this->_internal_set_token(from._internal_token());
  }
  if (!from._internal_branch().empty()) {
    _this->_internal_set_branch(from._internal_branch());
  }
  if (from._internal_expiration() != 0) {
    _this->_internal_set_expiration(from._internal_expiration());
  }
  if (from._internal_created() != 0) {
    _this->_internal_set_created(from._internal_created());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AuthenticationResponseContract::CopyFrom(const AuthenticationResponseContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AuthenticationResponseContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticationResponseContract::IsInitialized() const {
  return true;
}

void AuthenticationResponseContract::InternalSwap(AuthenticationResponseContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_, lhs_arena,
      &other->_impl_.client_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.branch_, lhs_arena,
      &other->_impl_.branch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AuthenticationResponseContract, _impl_.created_)
      + sizeof(AuthenticationResponseContract::_impl_.created_)
      - PROTOBUF_FIELD_OFFSET(AuthenticationResponseContract, _impl_.expiration_)>(
          reinterpret_cast<char*>(&_impl_.expiration_),
          reinterpret_cast<char*>(&other->_impl_.expiration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AuthenticationResponseContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[13]);
}

// ===================================================================

class CredentialContract::_Internal {
 public:
};

CredentialContract::CredentialContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CredentialContract)
}
CredentialContract::CredentialContract(const CredentialContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CredentialContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.client_){}
    , decltype(_impl_.login_){}
    , decltype(_impl_.password_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.client_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client().empty()) {
    _this->_impl_.client_.Set(from._internal_client(), 
      _this->GetArenaForAllocation());
  }
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_login().empty()) {
    _this->_impl_.login_.Set(from._internal_login(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CredentialContract)
}

inline void CredentialContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.client_){}
    , decltype(_impl_.login_){}
    , decltype(_impl_.password_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.client_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CredentialContract::~CredentialContract() {
  // @@protoc_insertion_point(destructor:CredentialContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CredentialContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_.Destroy();
  _impl_.login_.Destroy();
  _impl_.password_.Destroy();
}

void CredentialContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CredentialContract::Clear() {
// @@protoc_insertion_point(message_clear_start:CredentialContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.client_.ClearToEmpty();
  _impl_.login_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CredentialContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_client();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CredentialContract.Client"));
        } else
          goto handle_unusual;
        continue;
      // string Login = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CredentialContract.Login"));
        } else
          goto handle_unusual;
        continue;
      // string Password = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CredentialContract.Password"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CredentialContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CredentialContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Client = 1;
  if (!this->_internal_client().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client().data(), static_cast<int>(this->_internal_client().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CredentialContract.Client");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_client(), target);
  }

  // string Login = 2;
  if (!this->_internal_login().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_login().data(), static_cast<int>(this->_internal_login().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CredentialContract.Login");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_login(), target);
  }

  // string Password = 3;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CredentialContract.Password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CredentialContract)
  return target;
}

size_t CredentialContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CredentialContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Client = 1;
  if (!this->_internal_client().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client());
  }

  // string Login = 2;
  if (!this->_internal_login().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login());
  }

  // string Password = 3;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CredentialContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CredentialContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CredentialContract::GetClassData() const { return &_class_data_; }


void CredentialContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CredentialContract*>(&to_msg);
  auto& from = static_cast<const CredentialContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CredentialContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_client().empty()) {
    _this->_internal_set_client(from._internal_client());
  }
  if (!from._internal_login().empty()) {
    _this->_internal_set_login(from._internal_login());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CredentialContract::CopyFrom(const CredentialContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CredentialContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CredentialContract::IsInitialized() const {
  return true;
}

void CredentialContract::InternalSwap(CredentialContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_, lhs_arena,
      &other->_impl_.client_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_, lhs_arena,
      &other->_impl_.login_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CredentialContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[14]);
}

// ===================================================================

class PostResponseContract::_Internal {
 public:
};

PostResponseContract::PostResponseContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PostResponseContract)
}
PostResponseContract::PostResponseContract(const PostResponseContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PostResponseContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.errormessage_){}
    , decltype(_impl_.success_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.errormessage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_errormessage().empty()) {
    _this->_impl_.errormessage_.Set(from._internal_errormessage(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.success_ = from._impl_.success_;
  // @@protoc_insertion_point(copy_constructor:PostResponseContract)
}

inline void PostResponseContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.errormessage_){}
    , decltype(_impl_.success_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.errormessage_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PostResponseContract::~PostResponseContract() {
  // @@protoc_insertion_point(destructor:PostResponseContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PostResponseContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.errormessage_.Destroy();
}

void PostResponseContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PostResponseContract::Clear() {
// @@protoc_insertion_point(message_clear_start:PostResponseContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.errormessage_.ClearToEmpty();
  _impl_.success_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PostResponseContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool Success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ErrorMessage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_errormessage();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "PostResponseContract.ErrorMessage"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PostResponseContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PostResponseContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool Success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // string ErrorMessage = 2;
  if (!this->_internal_errormessage().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_errormessage().data(), static_cast<int>(this->_internal_errormessage().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "PostResponseContract.ErrorMessage");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_errormessage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PostResponseContract)
  return target;
}

size_t PostResponseContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PostResponseContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ErrorMessage = 2;
  if (!this->_internal_errormessage().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_errormessage());
  }

  // bool Success = 1;
  if (this->_internal_success() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PostResponseContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PostResponseContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PostResponseContract::GetClassData() const { return &_class_data_; }


void PostResponseContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PostResponseContract*>(&to_msg);
  auto& from = static_cast<const PostResponseContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:PostResponseContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_errormessage().empty()) {
    _this->_internal_set_errormessage(from._internal_errormessage());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PostResponseContract::CopyFrom(const PostResponseContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PostResponseContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PostResponseContract::IsInitialized() const {
  return true;
}

void PostResponseContract::InternalSwap(PostResponseContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.errormessage_, lhs_arena,
      &other->_impl_.errormessage_, rhs_arena
  );
  swap(_impl_.success_, other->_impl_.success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PostResponseContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[15]);
}

// ===================================================================

class GpsItemContract::_Internal {
 public:
  using HasBits = decltype(std::declval<GpsItemContract>()._impl_._has_bits_);
  static const ::SectorContract& sector(const GpsItemContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::SectorContract&
GpsItemContract::_Internal::sector(const GpsItemContract* msg) {
  return *msg->_impl_.sector_;
}
GpsItemContract::GpsItemContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:GpsItemContract)
}
GpsItemContract::GpsItemContract(const GpsItemContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GpsItemContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.latitude_){}
    , decltype(_impl_.longitude_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.longitude_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.longitude_));
  // @@protoc_insertion_point(copy_constructor:GpsItemContract)
}

inline void GpsItemContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.latitude_){0}
    , decltype(_impl_.longitude_){0}
  };
}

GpsItemContract::~GpsItemContract() {
  // @@protoc_insertion_point(destructor:GpsItemContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GpsItemContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sector_;
}

void GpsItemContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GpsItemContract::Clear() {
// @@protoc_insertion_point(message_clear_start:GpsItemContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.sector_ != nullptr);
    _impl_.sector_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.longitude_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.longitude_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GpsItemContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 SectorId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float X = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // double Latitude = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double Longitude = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GpsItemContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GpsItemContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // int32 SectorId = 2;
  if (this->_internal_sectorid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 3;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // float X = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_x(), target);
  }

  // float Y = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_y(), target);
  }

  // double Latitude = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_latitude = this->_internal_latitude();
  uint64_t raw_latitude;
  memcpy(&raw_latitude, &tmp_latitude, sizeof(tmp_latitude));
  if (raw_latitude != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_latitude(), target);
  }

  // double Longitude = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_longitude = this->_internal_longitude();
  uint64_t raw_longitude;
  memcpy(&raw_longitude, &tmp_longitude, sizeof(tmp_longitude));
  if (raw_longitude != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_longitude(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GpsItemContract)
  return target;
}

size_t GpsItemContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GpsItemContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .SectorContract Sector = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sector_);
  }

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // int32 SectorId = 2;
  if (this->_internal_sectorid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
  }

  // float X = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float Y = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // double Latitude = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_latitude = this->_internal_latitude();
  uint64_t raw_latitude;
  memcpy(&raw_latitude, &tmp_latitude, sizeof(tmp_latitude));
  if (raw_latitude != 0) {
    total_size += 1 + 8;
  }

  // double Longitude = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_longitude = this->_internal_longitude();
  uint64_t raw_longitude;
  memcpy(&raw_longitude, &tmp_longitude, sizeof(tmp_longitude));
  if (raw_longitude != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GpsItemContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GpsItemContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GpsItemContract::GetClassData() const { return &_class_data_; }


void GpsItemContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GpsItemContract*>(&to_msg);
  auto& from = static_cast<const GpsItemContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:GpsItemContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sector()) {
    _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
        from._internal_sector());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_sectorid() != 0) {
    _this->_internal_set_sectorid(from._internal_sectorid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_latitude = from._internal_latitude();
  uint64_t raw_latitude;
  memcpy(&raw_latitude, &tmp_latitude, sizeof(tmp_latitude));
  if (raw_latitude != 0) {
    _this->_internal_set_latitude(from._internal_latitude());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_longitude = from._internal_longitude();
  uint64_t raw_longitude;
  memcpy(&raw_longitude, &tmp_longitude, sizeof(tmp_longitude));
  if (raw_longitude != 0) {
    _this->_internal_set_longitude(from._internal_longitude());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GpsItemContract::CopyFrom(const GpsItemContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GpsItemContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpsItemContract::IsInitialized() const {
  return true;
}

void GpsItemContract::InternalSwap(GpsItemContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GpsItemContract, _impl_.longitude_)
      + sizeof(GpsItemContract::_impl_.longitude_)
      - PROTOBUF_FIELD_OFFSET(GpsItemContract, _impl_.sector_)>(
          reinterpret_cast<char*>(&_impl_.sector_),
          reinterpret_cast<char*>(&other->_impl_.sector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GpsItemContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[16]);
}

// ===================================================================

class BarrierContract::_Internal {
 public:
  using HasBits = decltype(std::declval<BarrierContract>()._impl_._has_bits_);
  static const ::SectorContract& sector(const BarrierContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BranchContract& branch(const BarrierContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SectorContract&
BarrierContract::_Internal::sector(const BarrierContract* msg) {
  return *msg->_impl_.sector_;
}
const ::BranchContract&
BarrierContract::_Internal::branch(const BarrierContract* msg) {
  return *msg->_impl_.branch_;
}
BarrierContract::BarrierContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BarrierContract)
}
BarrierContract::BarrierContract(const BarrierContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BarrierContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.branchid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.branchid_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.branchid_));
  // @@protoc_insertion_point(copy_constructor:BarrierContract)
}

inline void BarrierContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.branchid_){0}
  };
}

BarrierContract::~BarrierContract() {
  // @@protoc_insertion_point(destructor:BarrierContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BarrierContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.sector_;
  if (this != internal_default_instance()) delete _impl_.branch_;
}

void BarrierContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BarrierContract::Clear() {
// @@protoc_insertion_point(message_clear_start:BarrierContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.sector_ != nullptr);
      _impl_.sector_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.branch_ != nullptr);
      _impl_.branch_->Clear();
    }
  }
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.branchid_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.branchid_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BarrierContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 X = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 SectorId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BarrierContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BarrierContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 X = 1;
  if (this->_internal_x() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // int32 Y = 2;
  if (this->_internal_y() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // int32 SectorId = 3;
  if (this->_internal_sectorid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 4;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // int32 BranchId = 5;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 6;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BarrierContract)
  return target;
}

size_t BarrierContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BarrierContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SectorContract Sector = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sector_);
    }

    // optional .BranchContract Branch = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.branch_);
    }

  }
  // int32 X = 1;
  if (this->_internal_x() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
  }

  // int32 Y = 2;
  if (this->_internal_y() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
  }

  // int32 SectorId = 3;
  if (this->_internal_sectorid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
  }

  // int32 BranchId = 5;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BarrierContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BarrierContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BarrierContract::GetClassData() const { return &_class_data_; }


void BarrierContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BarrierContract*>(&to_msg);
  auto& from = static_cast<const BarrierContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:BarrierContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
          from._internal_sector());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
          from._internal_branch());
    }
  }
  if (from._internal_x() != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  if (from._internal_y() != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  if (from._internal_sectorid() != 0) {
    _this->_internal_set_sectorid(from._internal_sectorid());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BarrierContract::CopyFrom(const BarrierContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BarrierContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BarrierContract::IsInitialized() const {
  return true;
}

void BarrierContract::InternalSwap(BarrierContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BarrierContract, _impl_.branchid_)
      + sizeof(BarrierContract::_impl_.branchid_)
      - PROTOBUF_FIELD_OFFSET(BarrierContract, _impl_.sector_)>(
          reinterpret_cast<char*>(&_impl_.sector_),
          reinterpret_cast<char*>(&other->_impl_.sector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BarrierContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[17]);
}

// ===================================================================

class BeaconContract::_Internal {
 public:
  using HasBits = decltype(std::declval<BeaconContract>()._impl_._has_bits_);
  static void set_has_sectorid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::SectorContract& sector(const BeaconContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::BranchContract& branch(const BeaconContract* msg);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_geofencerange(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_lasttimeonline(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::SectorContract&
BeaconContract::_Internal::sector(const BeaconContract* msg) {
  return *msg->_impl_.sector_;
}
const ::BranchContract&
BeaconContract::_Internal::branch(const BeaconContract* msg) {
  return *msg->_impl_.branch_;
}
BeaconContract::BeaconContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BeaconContract)
}
BeaconContract::BeaconContract(const BeaconContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BeaconContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.cluster_){}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.branchid_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.typeid__){}
    , decltype(_impl_.active_){}
    , decltype(_impl_.position_){}
    , decltype(_impl_.geofence_){}
    , decltype(_impl_.usegps_){}
    , decltype(_impl_.lasttimeonline_){}
    , decltype(_impl_.geofencerange_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cluster_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cluster_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cluster().empty()) {
    _this->_impl_.cluster_.Set(from._internal_cluster(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  if (from._internal_has_branch()) {
    _this->_impl_.branch_ = new ::BranchContract(*from._impl_.branch_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.geofencerange_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.geofencerange_));
  // @@protoc_insertion_point(copy_constructor:BeaconContract)
}

inline void BeaconContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.cluster_){}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.branch_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.branchid_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.typeid__){0}
    , decltype(_impl_.active_){false}
    , decltype(_impl_.position_){false}
    , decltype(_impl_.geofence_){false}
    , decltype(_impl_.usegps_){false}
    , decltype(_impl_.lasttimeonline_){int64_t{0}}
    , decltype(_impl_.geofencerange_){0}
  };
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cluster_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cluster_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BeaconContract::~BeaconContract() {
  // @@protoc_insertion_point(destructor:BeaconContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BeaconContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mac_.Destroy();
  _impl_.title_.Destroy();
  _impl_.cluster_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sector_;
  if (this != internal_default_instance()) delete _impl_.branch_;
}

void BeaconContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BeaconContract::Clear() {
// @@protoc_insertion_point(message_clear_start:BeaconContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mac_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.cluster_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.sector_ != nullptr);
      _impl_.sector_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.branch_ != nullptr);
      _impl_.branch_->Clear();
    }
  }
  _impl_.id_ = 0;
  _impl_.sectorid_ = 0;
  _impl_.branchid_ = 0;
  if (cached_has_bits & 0x00000078u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.typeid__) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.typeid__));
  }
  ::memset(&_impl_.active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.usegps_) -
      reinterpret_cast<char*>(&_impl_.active_)) + sizeof(_impl_.usegps_));
  _impl_.lasttimeonline_ = int64_t{0};
  _impl_.geofencerange_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BeaconContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 SectorId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sectorid(&has_bits);
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 BranchId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.branchid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .BranchContract Branch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_branch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Mac = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "BeaconContract.Mac"));
        } else
          goto handle_unusual;
        continue;
      // optional float X = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Y = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Z = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string Title = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "BeaconContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // bool Active = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 TypeId = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_typeid_(&has_bits);
          _impl_.typeid__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Position = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool Geofence = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.geofence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float GeofenceRange = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_geofencerange(&has_bits);
          _impl_.geofencerange_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string Cluster = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_cluster();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "BeaconContract.Cluster"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 LastTimeOnline = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_lasttimeonline(&has_bits);
          _impl_.lasttimeonline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool UseGps = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.usegps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BeaconContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BeaconContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional int32 SectorId = 2;
  if (_internal_has_sectorid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 3;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // int32 BranchId = 4;
  if (this->_internal_branchid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_branchid(), target);
  }

  // optional .BranchContract Branch = 5;
  if (_internal_has_branch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::branch(this),
        _Internal::branch(this).GetCachedSize(), target, stream);
  }

  // string Mac = 6;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "BeaconContract.Mac");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_mac(), target);
  }

  // optional float X = 7;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_x(), target);
  }

  // optional float Y = 8;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_y(), target);
  }

  // optional float Z = 9;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_z(), target);
  }

  // string Title = 10;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "BeaconContract.Title");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_title(), target);
  }

  // bool Active = 11;
  if (this->_internal_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_active(), target);
  }

  // optional int32 TypeId = 12;
  if (_internal_has_typeid_()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_typeid_(), target);
  }

  // bool Position = 14;
  if (this->_internal_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_position(), target);
  }

  // bool Geofence = 15;
  if (this->_internal_geofence() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_geofence(), target);
  }

  // optional float GeofenceRange = 16;
  if (_internal_has_geofencerange()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_geofencerange(), target);
  }

  // string Cluster = 17;
  if (!this->_internal_cluster().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cluster().data(), static_cast<int>(this->_internal_cluster().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "BeaconContract.Cluster");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_cluster(), target);
  }

  // optional int64 LastTimeOnline = 18;
  if (_internal_has_lasttimeonline()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(18, this->_internal_lasttimeonline(), target);
  }

  // bool UseGps = 19;
  if (this->_internal_usegps() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_usegps(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BeaconContract)
  return target;
}

size_t BeaconContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BeaconContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Mac = 6;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  // string Title = 10;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Cluster = 17;
  if (!this->_internal_cluster().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cluster());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SectorContract Sector = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sector_);
    }

    // optional .BranchContract Branch = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.branch_);
    }

  }
  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  // optional int32 SectorId = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
  }

  // int32 BranchId = 4;
  if (this->_internal_branchid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_branchid());
  }

  if (cached_has_bits & 0x00000078u) {
    // optional float X = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float Y = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float Z = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 TypeId = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_typeid_());
    }

  }
  // bool Active = 11;
  if (this->_internal_active() != 0) {
    total_size += 1 + 1;
  }

  // bool Position = 14;
  if (this->_internal_position() != 0) {
    total_size += 1 + 1;
  }

  // bool Geofence = 15;
  if (this->_internal_geofence() != 0) {
    total_size += 1 + 1;
  }

  // bool UseGps = 19;
  if (this->_internal_usegps() != 0) {
    total_size += 2 + 1;
  }

  // optional int64 LastTimeOnline = 18;
  if (cached_has_bits & 0x00000080u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int64Size(
        this->_internal_lasttimeonline());
  }

  // optional float GeofenceRange = 16;
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BeaconContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BeaconContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BeaconContract::GetClassData() const { return &_class_data_; }


void BeaconContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BeaconContract*>(&to_msg);
  auto& from = static_cast<const BeaconContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:BeaconContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_cluster().empty()) {
    _this->_internal_set_cluster(from._internal_cluster());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
          from._internal_sector());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_branch()->::BranchContract::MergeFrom(
          from._internal_branch());
    }
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (cached_has_bits & 0x00000004u) {
    _this->_internal_set_sectorid(from._internal_sectorid());
  }
  if (from._internal_branchid() != 0) {
    _this->_internal_set_branchid(from._internal_branchid());
  }
  if (cached_has_bits & 0x00000078u) {
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.typeid__ = from._impl_.typeid__;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_active() != 0) {
    _this->_internal_set_active(from._internal_active());
  }
  if (from._internal_position() != 0) {
    _this->_internal_set_position(from._internal_position());
  }
  if (from._internal_geofence() != 0) {
    _this->_internal_set_geofence(from._internal_geofence());
  }
  if (from._internal_usegps() != 0) {
    _this->_internal_set_usegps(from._internal_usegps());
  }
  if (cached_has_bits & 0x00000080u) {
    _this->_internal_set_lasttimeonline(from._internal_lasttimeonline());
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_geofencerange(from._internal_geofencerange());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BeaconContract::CopyFrom(const BeaconContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BeaconContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeaconContract::IsInitialized() const {
  return true;
}

void BeaconContract::InternalSwap(BeaconContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cluster_, lhs_arena,
      &other->_impl_.cluster_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeaconContract, _impl_.geofencerange_)
      + sizeof(BeaconContract::_impl_.geofencerange_)
      - PROTOBUF_FIELD_OFFSET(BeaconContract, _impl_.sector_)>(
          reinterpret_cast<char*>(&_impl_.sector_),
          reinterpret_cast<char*>(&other->_impl_.sector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BeaconContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[18]);
}

// ===================================================================

class BeaconPositionContract::_Internal {
 public:
  using HasBits = decltype(std::declval<BeaconPositionContract>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BeaconPositionContract::BeaconPositionContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:BeaconPositionContract)
}
BeaconPositionContract::BeaconPositionContract(const BeaconPositionContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BeaconPositionContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:BeaconPositionContract)
}

inline void BeaconPositionContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

BeaconPositionContract::~BeaconPositionContract() {
  // @@protoc_insertion_point(destructor:BeaconPositionContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BeaconPositionContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BeaconPositionContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BeaconPositionContract::Clear() {
// @@protoc_insertion_point(message_clear_start:BeaconPositionContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = 0;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BeaconPositionContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float X = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BeaconPositionContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:BeaconPositionContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional float X = 2;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_x(), target);
  }

  // optional float Y = 3;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:BeaconPositionContract)
  return target;
}

size_t BeaconPositionContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:BeaconPositionContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float X = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float Y = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BeaconPositionContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BeaconPositionContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BeaconPositionContract::GetClassData() const { return &_class_data_; }


void BeaconPositionContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BeaconPositionContract*>(&to_msg);
  auto& from = static_cast<const BeaconPositionContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:BeaconPositionContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BeaconPositionContract::CopyFrom(const BeaconPositionContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:BeaconPositionContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeaconPositionContract::IsInitialized() const {
  return true;
}

void BeaconPositionContract::InternalSwap(BeaconPositionContract* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BeaconPositionContract, _impl_.y_)
      + sizeof(BeaconPositionContract::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(BeaconPositionContract, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BeaconPositionContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[19]);
}

// ===================================================================

class SensorContract::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorContract>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_battery(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sectorid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::SectorContract& sector(const SensorContract* msg);
  static void set_has_sector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_areaid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::AreaContract& area(const SensorContract* msg);
  static void set_has_area(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::SectorContract&
SensorContract::_Internal::sector(const SensorContract* msg) {
  return *msg->_impl_.sector_;
}
const ::AreaContract&
SensorContract::_Internal::area(const SensorContract* msg) {
  return *msg->_impl_.area_;
}
SensorContract::SensorContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SensorContract)
}
SensorContract::SensorContract(const SensorContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sensordata_){from._impl_.sensordata_}
    , decltype(_impl_.login_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.note_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.area_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.battery_){}
    , decltype(_impl_.sectorid_){}
    , decltype(_impl_.areaid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_login().empty()) {
    _this->_impl_.login_.Set(from._internal_login(), 
      _this->GetArenaForAllocation());
  }
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_title().empty()) {
    _this->_impl_.title_.Set(from._internal_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.note_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.note_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_note().empty()) {
    _this->_impl_.note_.Set(from._internal_note(), 
      _this->GetArenaForAllocation());
  }
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_password().empty()) {
    _this->_impl_.password_.Set(from._internal_password(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sector()) {
    _this->_impl_.sector_ = new ::SectorContract(*from._impl_.sector_);
  }
  if (from._internal_has_area()) {
    _this->_impl_.area_ = new ::AreaContract(*from._impl_.area_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.areaid_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.areaid_));
  // @@protoc_insertion_point(copy_constructor:SensorContract)
}

inline void SensorContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sensordata_){arena}
    , decltype(_impl_.login_){}
    , decltype(_impl_.title_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.note_){}
    , decltype(_impl_.password_){}
    , decltype(_impl_.sector_){nullptr}
    , decltype(_impl_.area_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.battery_){0}
    , decltype(_impl_.sectorid_){0}
    , decltype(_impl_.areaid_){0}
  };
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.note_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.note_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SensorContract::~SensorContract() {
  // @@protoc_insertion_point(destructor:SensorContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sensordata_.~RepeatedPtrField();
  _impl_.login_.Destroy();
  _impl_.title_.Destroy();
  _impl_.mac_.Destroy();
  _impl_.note_.Destroy();
  _impl_.password_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sector_;
  if (this != internal_default_instance()) delete _impl_.area_;
}

void SensorContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorContract::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sensordata_.Clear();
  _impl_.login_.ClearToEmpty();
  _impl_.title_.ClearToEmpty();
  _impl_.mac_.ClearToEmpty();
  _impl_.note_.ClearToEmpty();
  _impl_.password_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.sector_ != nullptr);
      _impl_.sector_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.area_ != nullptr);
      _impl_.area_->Clear();
    }
  }
  _impl_.id_ = 0;
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.areaid_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.areaid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Login = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorContract.Login"));
        } else
          goto handle_unusual;
        continue;
      // string Title = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorContract.Title"));
        } else
          goto handle_unusual;
        continue;
      // string Mac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorContract.Mac"));
        } else
          goto handle_unusual;
        continue;
      // string Note = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_note();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorContract.Note"));
        } else
          goto handle_unusual;
        continue;
      // optional float X = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float Battery = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_battery(&has_bits);
          _impl_.battery_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 SectorId = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_sectorid(&has_bits);
          _impl_.sectorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .SectorContract Sector = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_sector(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .SensorDataContract SensorData = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensordata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 AreaId = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_areaid(&has_bits);
          _impl_.areaid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .AreaContract Area = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_area(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Password = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorContract.Password"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // string Login = 2;
  if (!this->_internal_login().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_login().data(), static_cast<int>(this->_internal_login().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorContract.Login");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_login(), target);
  }

  // string Title = 3;
  if (!this->_internal_title().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorContract.Title");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_title(), target);
  }

  // string Mac = 4;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorContract.Mac");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_mac(), target);
  }

  // string Note = 5;
  if (!this->_internal_note().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_note().data(), static_cast<int>(this->_internal_note().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorContract.Note");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_note(), target);
  }

  // optional float X = 6;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_x(), target);
  }

  // optional float y = 7;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_y(), target);
  }

  // optional float Battery = 8;
  if (_internal_has_battery()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_battery(), target);
  }

  // optional int32 SectorId = 9;
  if (_internal_has_sectorid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_sectorid(), target);
  }

  // optional .SectorContract Sector = 10;
  if (_internal_has_sector()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::sector(this),
        _Internal::sector(this).GetCachedSize(), target, stream);
  }

  // repeated .SensorDataContract SensorData = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sensordata_size()); i < n; i++) {
    const auto& repfield = this->_internal_sensordata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 AreaId = 12;
  if (_internal_has_areaid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_areaid(), target);
  }

  // optional .AreaContract Area = 13;
  if (_internal_has_area()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::area(this),
        _Internal::area(this).GetCachedSize(), target, stream);
  }

  // string Password = 14;
  if (!this->_internal_password().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorContract.Password");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorContract)
  return target;
}

size_t SensorContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SensorDataContract SensorData = 11;
  total_size += 1UL * this->_internal_sensordata_size();
  for (const auto& msg : this->_impl_.sensordata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Login = 2;
  if (!this->_internal_login().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login());
  }

  // string Title = 3;
  if (!this->_internal_title().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_title());
  }

  // string Mac = 4;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  // string Note = 5;
  if (!this->_internal_note().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_note());
  }

  // string Password = 14;
  if (!this->_internal_password().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_password());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .SectorContract Sector = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.sector_);
    }

    // optional .AreaContract Area = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.area_);
    }

  }
  // int32 Id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional float X = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float y = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float Battery = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 SectorId = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sectorid());
    }

    // optional int32 AreaId = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_areaid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorContract::GetClassData() const { return &_class_data_; }


void SensorContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorContract*>(&to_msg);
  auto& from = static_cast<const SensorContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SensorContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sensordata_.MergeFrom(from._impl_.sensordata_);
  if (!from._internal_login().empty()) {
    _this->_internal_set_login(from._internal_login());
  }
  if (!from._internal_title().empty()) {
    _this->_internal_set_title(from._internal_title());
  }
  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  if (!from._internal_note().empty()) {
    _this->_internal_set_note(from._internal_note());
  }
  if (!from._internal_password().empty()) {
    _this->_internal_set_password(from._internal_password());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_sector()->::SectorContract::MergeFrom(
          from._internal_sector());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_area()->::AreaContract::MergeFrom(
          from._internal_area());
    }
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (cached_has_bits & 0x0000007cu) {
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.battery_ = from._impl_.battery_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sectorid_ = from._impl_.sectorid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.areaid_ = from._impl_.areaid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorContract::CopyFrom(const SensorContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorContract::IsInitialized() const {
  return true;
}

void SensorContract::InternalSwap(SensorContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.sensordata_.InternalSwap(&other->_impl_.sensordata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_, lhs_arena,
      &other->_impl_.login_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.title_, lhs_arena,
      &other->_impl_.title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.note_, lhs_arena,
      &other->_impl_.note_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.password_, lhs_arena,
      &other->_impl_.password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorContract, _impl_.areaid_)
      + sizeof(SensorContract::_impl_.areaid_)
      - PROTOBUF_FIELD_OFFSET(SensorContract, _impl_.sector_)>(
          reinterpret_cast<char*>(&_impl_.sector_),
          reinterpret_cast<char*>(&other->_impl_.sector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[20]);
}

// ===================================================================

class SensorDataContract::_Internal {
 public:
  static const ::RangeContract& range(const SensorDataContract* msg);
};

const ::RangeContract&
SensorDataContract::_Internal::range(const SensorDataContract* msg) {
  return *msg->_impl_.range_;
}
SensorDataContract::SensorDataContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SensorDataContract)
}
SensorDataContract::SensorDataContract(const SensorDataContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorDataContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.quantity_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.datatype_){}
    , decltype(_impl_.range_){nullptr}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unit().empty()) {
    _this->_impl_.unit_.Set(from._internal_unit(), 
      _this->GetArenaForAllocation());
  }
  _impl_.datatype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datatype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_datatype().empty()) {
    _this->_impl_.datatype_.Set(from._internal_datatype(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_range()) {
    _this->_impl_.range_ = new ::RangeContract(*from._impl_.range_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.index_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.index_));
  // @@protoc_insertion_point(copy_constructor:SensorDataContract)
}

inline void SensorDataContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.quantity_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.datatype_){}
    , decltype(_impl_.range_){nullptr}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.index_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.datatype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datatype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SensorDataContract::~SensorDataContract() {
  // @@protoc_insertion_point(destructor:SensorDataContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorDataContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.quantity_.Destroy();
  _impl_.value_.Destroy();
  _impl_.unit_.Destroy();
  _impl_.datatype_.Destroy();
  if (this != internal_default_instance()) delete _impl_.range_;
}

void SensorDataContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorDataContract::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorDataContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quantity_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _impl_.unit_.ClearToEmpty();
  _impl_.datatype_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.range_ != nullptr) {
    delete _impl_.range_;
  }
  _impl_.range_ = nullptr;
  ::memset(&_impl_.timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.index_) -
      reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.index_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorDataContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Quantity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataContract.Quantity"));
        } else
          goto handle_unusual;
        continue;
      // string Value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataContract.Value"));
        } else
          goto handle_unusual;
        continue;
      // string Unit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_unit();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataContract.Unit"));
        } else
          goto handle_unusual;
        continue;
      // string DataType = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_datatype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataContract.DataType"));
        } else
          goto handle_unusual;
        continue;
      // int64 Timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .RangeContract Range = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorDataContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorDataContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Quantity = 1;
  if (!this->_internal_quantity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_quantity().data(), static_cast<int>(this->_internal_quantity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataContract.Quantity");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_quantity(), target);
  }

  // string Value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataContract.Value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  // string Unit = 3;
  if (!this->_internal_unit().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unit().data(), static_cast<int>(this->_internal_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataContract.Unit");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_unit(), target);
  }

  // string DataType = 4;
  if (!this->_internal_datatype().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_datatype().data(), static_cast<int>(this->_internal_datatype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataContract.DataType");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_datatype(), target);
  }

  // int64 Timestamp = 5;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_timestamp(), target);
  }

  // .RangeContract Range = 6;
  if (this->_internal_has_range()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::range(this),
        _Internal::range(this).GetCachedSize(), target, stream);
  }

  // int32 Index = 7;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorDataContract)
  return target;
}

size_t SensorDataContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorDataContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Quantity = 1;
  if (!this->_internal_quantity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_quantity());
  }

  // string Value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // string Unit = 3;
  if (!this->_internal_unit().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unit());
  }

  // string DataType = 4;
  if (!this->_internal_datatype().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_datatype());
  }

  // .RangeContract Range = 6;
  if (this->_internal_has_range()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.range_);
  }

  // int64 Timestamp = 5;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  // int32 Index = 7;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorDataContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorDataContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorDataContract::GetClassData() const { return &_class_data_; }


void SensorDataContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorDataContract*>(&to_msg);
  auto& from = static_cast<const SensorDataContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SensorDataContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (!from._internal_unit().empty()) {
    _this->_internal_set_unit(from._internal_unit());
  }
  if (!from._internal_datatype().empty()) {
    _this->_internal_set_datatype(from._internal_datatype());
  }
  if (from._internal_has_range()) {
    _this->_internal_mutable_range()->::RangeContract::MergeFrom(
        from._internal_range());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorDataContract::CopyFrom(const SensorDataContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorDataContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDataContract::IsInitialized() const {
  return true;
}

void SensorDataContract::InternalSwap(SensorDataContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.quantity_, lhs_arena,
      &other->_impl_.quantity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unit_, lhs_arena,
      &other->_impl_.unit_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.datatype_, lhs_arena,
      &other->_impl_.datatype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorDataContract, _impl_.index_)
      + sizeof(SensorDataContract::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(SensorDataContract, _impl_.range_)>(
          reinterpret_cast<char*>(&_impl_.range_),
          reinterpret_cast<char*>(&other->_impl_.range_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorDataContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[21]);
}

// ===================================================================

class SensorBatchContract::_Internal {
 public:
};

SensorBatchContract::SensorBatchContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SensorBatchContract)
}
SensorBatchContract::SensorBatchContract(const SensorBatchContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorBatchContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sensordata_){from._impl_.sensordata_}
    , decltype(_impl_.login_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_login().empty()) {
    _this->_impl_.login_.Set(from._internal_login(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:SensorBatchContract)
}

inline void SensorBatchContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sensordata_){arena}
    , decltype(_impl_.login_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.login_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.login_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SensorBatchContract::~SensorBatchContract() {
  // @@protoc_insertion_point(destructor:SensorBatchContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorBatchContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sensordata_.~RepeatedPtrField();
  _impl_.login_.Destroy();
}

void SensorBatchContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorBatchContract::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorBatchContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sensordata_.Clear();
  _impl_.login_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorBatchContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Login = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_login();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorBatchContract.Login"));
        } else
          goto handle_unusual;
        continue;
      // repeated .SensorDataBatchContract SensorData = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sensordata(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorBatchContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorBatchContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Login = 1;
  if (!this->_internal_login().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_login().data(), static_cast<int>(this->_internal_login().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorBatchContract.Login");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_login(), target);
  }

  // repeated .SensorDataBatchContract SensorData = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sensordata_size()); i < n; i++) {
    const auto& repfield = this->_internal_sensordata(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorBatchContract)
  return target;
}

size_t SensorBatchContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorBatchContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .SensorDataBatchContract SensorData = 2;
  total_size += 1UL * this->_internal_sensordata_size();
  for (const auto& msg : this->_impl_.sensordata_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Login = 1;
  if (!this->_internal_login().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_login());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorBatchContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorBatchContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorBatchContract::GetClassData() const { return &_class_data_; }


void SensorBatchContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorBatchContract*>(&to_msg);
  auto& from = static_cast<const SensorBatchContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SensorBatchContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sensordata_.MergeFrom(from._impl_.sensordata_);
  if (!from._internal_login().empty()) {
    _this->_internal_set_login(from._internal_login());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorBatchContract::CopyFrom(const SensorBatchContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorBatchContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorBatchContract::IsInitialized() const {
  return true;
}

void SensorBatchContract::InternalSwap(SensorBatchContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.sensordata_.InternalSwap(&other->_impl_.sensordata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.login_, lhs_arena,
      &other->_impl_.login_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorBatchContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[22]);
}

// ===================================================================

class SensorDataBatchContract::_Internal {
 public:
  using HasBits = decltype(std::declval<SensorDataBatchContract>()._impl_._has_bits_);
  static void set_has_valueok(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SensorDataBatchContract::SensorDataBatchContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SensorDataBatchContract)
}
SensorDataBatchContract::SensorDataBatchContract(const SensorDataBatchContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorDataBatchContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.datatype_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.valueok_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quantity().empty()) {
    _this->_impl_.quantity_.Set(from._internal_quantity(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_unit().empty()) {
    _this->_impl_.unit_.Set(from._internal_unit(), 
      _this->GetArenaForAllocation());
  }
  _impl_.datatype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datatype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_datatype().empty()) {
    _this->_impl_.datatype_.Set(from._internal_datatype(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.valueok_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.valueok_));
  // @@protoc_insertion_point(copy_constructor:SensorDataBatchContract)
}

inline void SensorDataBatchContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.quantity_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.unit_){}
    , decltype(_impl_.datatype_){}
    , decltype(_impl_.timestamp_){int64_t{0}}
    , decltype(_impl_.valueok_){false}
  };
  _impl_.quantity_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quantity_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.unit_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unit_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.datatype_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.datatype_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SensorDataBatchContract::~SensorDataBatchContract() {
  // @@protoc_insertion_point(destructor:SensorDataBatchContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorDataBatchContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.quantity_.Destroy();
  _impl_.value_.Destroy();
  _impl_.unit_.Destroy();
  _impl_.datatype_.Destroy();
}

void SensorDataBatchContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorDataBatchContract::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorDataBatchContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quantity_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _impl_.unit_.ClearToEmpty();
  _impl_.datatype_.ClearToEmpty();
  _impl_.timestamp_ = int64_t{0};
  _impl_.valueok_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorDataBatchContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 Timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string Quantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quantity();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataBatchContract.Quantity"));
        } else
          goto handle_unusual;
        continue;
      // string Value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataBatchContract.Value"));
        } else
          goto handle_unusual;
        continue;
      // string Unit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_unit();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataBatchContract.Unit"));
        } else
          goto handle_unusual;
        continue;
      // string DataType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_datatype();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorDataBatchContract.DataType"));
        } else
          goto handle_unusual;
        continue;
      // optional bool ValueOK = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_valueok(&has_bits);
          _impl_.valueok_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorDataBatchContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorDataBatchContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 Timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp(), target);
  }

  // string Quantity = 2;
  if (!this->_internal_quantity().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_quantity().data(), static_cast<int>(this->_internal_quantity().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataBatchContract.Quantity");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_quantity(), target);
  }

  // string Value = 3;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataBatchContract.Value");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_value(), target);
  }

  // string Unit = 4;
  if (!this->_internal_unit().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unit().data(), static_cast<int>(this->_internal_unit().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataBatchContract.Unit");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_unit(), target);
  }

  // string DataType = 5;
  if (!this->_internal_datatype().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_datatype().data(), static_cast<int>(this->_internal_datatype().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorDataBatchContract.DataType");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_datatype(), target);
  }

  // optional bool ValueOK = 6;
  if (_internal_has_valueok()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_valueok(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorDataBatchContract)
  return target;
}

size_t SensorDataBatchContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorDataBatchContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Quantity = 2;
  if (!this->_internal_quantity().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_quantity());
  }

  // string Value = 3;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  // string Unit = 4;
  if (!this->_internal_unit().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_unit());
  }

  // string DataType = 5;
  if (!this->_internal_datatype().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_datatype());
  }

  // int64 Timestamp = 1;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp());
  }

  // optional bool ValueOK = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorDataBatchContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorDataBatchContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorDataBatchContract::GetClassData() const { return &_class_data_; }


void SensorDataBatchContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorDataBatchContract*>(&to_msg);
  auto& from = static_cast<const SensorDataBatchContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SensorDataBatchContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_quantity().empty()) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  if (!from._internal_unit().empty()) {
    _this->_internal_set_unit(from._internal_unit());
  }
  if (!from._internal_datatype().empty()) {
    _this->_internal_set_datatype(from._internal_datatype());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  if (from._internal_has_valueok()) {
    _this->_internal_set_valueok(from._internal_valueok());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorDataBatchContract::CopyFrom(const SensorDataBatchContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorDataBatchContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDataBatchContract::IsInitialized() const {
  return true;
}

void SensorDataBatchContract::InternalSwap(SensorDataBatchContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.quantity_, lhs_arena,
      &other->_impl_.quantity_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unit_, lhs_arena,
      &other->_impl_.unit_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.datatype_, lhs_arena,
      &other->_impl_.datatype_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorDataBatchContract, _impl_.valueok_)
      + sizeof(SensorDataBatchContract::_impl_.valueok_)
      - PROTOBUF_FIELD_OFFSET(SensorDataBatchContract, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorDataBatchContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[23]);
}

// ===================================================================

class SensorAppInfoContract::_Internal {
 public:
};

SensorAppInfoContract::SensorAppInfoContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SensorAppInfoContract)
}
SensorAppInfoContract::SensorAppInfoContract(const SensorAppInfoContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SensorAppInfoContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.size_ = from._impl_.size_;
  // @@protoc_insertion_point(copy_constructor:SensorAppInfoContract)
}

inline void SensorAppInfoContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.size_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SensorAppInfoContract::~SensorAppInfoContract() {
  // @@protoc_insertion_point(destructor:SensorAppInfoContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SensorAppInfoContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.Destroy();
}

void SensorAppInfoContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SensorAppInfoContract::Clear() {
// @@protoc_insertion_point(message_clear_start:SensorAppInfoContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_.ClearToEmpty();
  _impl_.size_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorAppInfoContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SensorAppInfoContract.Version"));
        } else
          goto handle_unusual;
        continue;
      // int64 Size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorAppInfoContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SensorAppInfoContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Version = 1;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SensorAppInfoContract.Version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // int64 Size = 2;
  if (this->_internal_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SensorAppInfoContract)
  return target;
}

size_t SensorAppInfoContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SensorAppInfoContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Version = 1;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // int64 Size = 2;
  if (this->_internal_size() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorAppInfoContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SensorAppInfoContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorAppInfoContract::GetClassData() const { return &_class_data_; }


void SensorAppInfoContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SensorAppInfoContract*>(&to_msg);
  auto& from = static_cast<const SensorAppInfoContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SensorAppInfoContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_size() != 0) {
    _this->_internal_set_size(from._internal_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorAppInfoContract::CopyFrom(const SensorAppInfoContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SensorAppInfoContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorAppInfoContract::IsInitialized() const {
  return true;
}

void SensorAppInfoContract::InternalSwap(SensorAppInfoContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  swap(_impl_.size_, other->_impl_.size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorAppInfoContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[24]);
}

// ===================================================================

class RangeContract::_Internal {
 public:
};

RangeContract::RangeContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RangeContract)
}
RangeContract::RangeContract(const RangeContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangeContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ranges_){from._impl_.ranges_}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_type().empty()) {
    _this->_impl_.type_.Set(from._internal_type(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:RangeContract)
}

inline void RangeContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ranges_){arena}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RangeContract::~RangeContract() {
  // @@protoc_insertion_point(destructor:RangeContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangeContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ranges_.~RepeatedPtrField();
  _impl_.type_.Destroy();
}

void RangeContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangeContract::Clear() {
// @@protoc_insertion_point(message_clear_start:RangeContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ranges_.Clear();
  _impl_.type_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangeContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RangeContract.Type"));
        } else
          goto handle_unusual;
        continue;
      // repeated .RangesContract Ranges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangeContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RangeContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Type = 1;
  if (!this->_internal_type().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RangeContract.Type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // repeated .RangesContract Ranges = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ranges_size()); i < n; i++) {
    const auto& repfield = this->_internal_ranges(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RangeContract)
  return target;
}

size_t RangeContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RangeContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RangesContract Ranges = 2;
  total_size += 1UL * this->_internal_ranges_size();
  for (const auto& msg : this->_impl_.ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string Type = 1;
  if (!this->_internal_type().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangeContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangeContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangeContract::GetClassData() const { return &_class_data_; }


void RangeContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangeContract*>(&to_msg);
  auto& from = static_cast<const RangeContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RangeContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ranges_.MergeFrom(from._impl_.ranges_);
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangeContract::CopyFrom(const RangeContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RangeContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeContract::IsInitialized() const {
  return true;
}

void RangeContract::InternalSwap(RangeContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ranges_.InternalSwap(&other->_impl_.ranges_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.type_, lhs_arena,
      &other->_impl_.type_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RangeContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[25]);
}

// ===================================================================

class RangesContract::_Internal {
 public:
};

RangesContract::RangesContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RangesContract)
}
RangesContract::RangesContract(const RangesContract& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RangesContract* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:RangesContract)
}

inline void RangesContract::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.value_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RangesContract::~RangesContract() {
  // @@protoc_insertion_point(destructor:RangesContract)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RangesContract::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
  _impl_.value_.Destroy();
}

void RangesContract::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RangesContract::Clear() {
// @@protoc_insertion_point(message_clear_start:RangesContract)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  _impl_.value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RangesContract::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string Color = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RangesContract.Color"));
        } else
          goto handle_unusual;
        continue;
      // string Value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RangesContract.Value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RangesContract::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RangesContract)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string Color = 1;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RangesContract.Color");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_color(), target);
  }

  // string Value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RangesContract.Value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RangesContract)
  return target;
}

size_t RangesContract::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RangesContract)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Color = 1;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // string Value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RangesContract::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RangesContract::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RangesContract::GetClassData() const { return &_class_data_; }


void RangesContract::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RangesContract*>(&to_msg);
  auto& from = static_cast<const RangesContract&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RangesContract)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  if (!from._internal_value().empty()) {
    _this->_internal_set_value(from._internal_value());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RangesContract::CopyFrom(const RangesContract& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RangesContract)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangesContract::IsInitialized() const {
  return true;
}

void RangesContract::InternalSwap(RangesContract* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RangesContract::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_core_2eproto_getter, &descriptor_table_core_2eproto_once,
      file_level_metadata_core_2eproto[26]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Guid*
Arena::CreateMaybeMessage< ::Guid >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Guid >(arena);
}
template<> PROTOBUF_NOINLINE ::DeviceContract*
Arena::CreateMaybeMessage< ::DeviceContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DeviceContract >(arena);
}
template<> PROTOBUF_NOINLINE ::SectorContract*
Arena::CreateMaybeMessage< ::SectorContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SectorContract >(arena);
}
template<> PROTOBUF_NOINLINE ::BranchContract*
Arena::CreateMaybeMessage< ::BranchContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BranchContract >(arena);
}
template<> PROTOBUF_NOINLINE ::LayerContract*
Arena::CreateMaybeMessage< ::LayerContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LayerContract >(arena);
}
template<> PROTOBUF_NOINLINE ::PathContract*
Arena::CreateMaybeMessage< ::PathContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PathContract >(arena);
}
template<> PROTOBUF_NOINLINE ::PathPointContract*
Arena::CreateMaybeMessage< ::PathPointContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PathPointContract >(arena);
}
template<> PROTOBUF_NOINLINE ::AreaContract*
Arena::CreateMaybeMessage< ::AreaContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AreaContract >(arena);
}
template<> PROTOBUF_NOINLINE ::PointContract*
Arena::CreateMaybeMessage< ::PointContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PointContract >(arena);
}
template<> PROTOBUF_NOINLINE ::DeviceLocationContract*
Arena::CreateMaybeMessage< ::DeviceLocationContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DeviceLocationContract >(arena);
}
template<> PROTOBUF_NOINLINE ::LocationContract*
Arena::CreateMaybeMessage< ::LocationContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LocationContract >(arena);
}
template<> PROTOBUF_NOINLINE ::DistanceContract*
Arena::CreateMaybeMessage< ::DistanceContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DistanceContract >(arena);
}
template<> PROTOBUF_NOINLINE ::LoginContract*
Arena::CreateMaybeMessage< ::LoginContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LoginContract >(arena);
}
template<> PROTOBUF_NOINLINE ::AuthenticationResponseContract*
Arena::CreateMaybeMessage< ::AuthenticationResponseContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AuthenticationResponseContract >(arena);
}
template<> PROTOBUF_NOINLINE ::CredentialContract*
Arena::CreateMaybeMessage< ::CredentialContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CredentialContract >(arena);
}
template<> PROTOBUF_NOINLINE ::PostResponseContract*
Arena::CreateMaybeMessage< ::PostResponseContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PostResponseContract >(arena);
}
template<> PROTOBUF_NOINLINE ::GpsItemContract*
Arena::CreateMaybeMessage< ::GpsItemContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GpsItemContract >(arena);
}
template<> PROTOBUF_NOINLINE ::BarrierContract*
Arena::CreateMaybeMessage< ::BarrierContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BarrierContract >(arena);
}
template<> PROTOBUF_NOINLINE ::BeaconContract*
Arena::CreateMaybeMessage< ::BeaconContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BeaconContract >(arena);
}
template<> PROTOBUF_NOINLINE ::BeaconPositionContract*
Arena::CreateMaybeMessage< ::BeaconPositionContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::BeaconPositionContract >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorContract*
Arena::CreateMaybeMessage< ::SensorContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorContract >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorDataContract*
Arena::CreateMaybeMessage< ::SensorDataContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorDataContract >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorBatchContract*
Arena::CreateMaybeMessage< ::SensorBatchContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorBatchContract >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorDataBatchContract*
Arena::CreateMaybeMessage< ::SensorDataBatchContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorDataBatchContract >(arena);
}
template<> PROTOBUF_NOINLINE ::SensorAppInfoContract*
Arena::CreateMaybeMessage< ::SensorAppInfoContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SensorAppInfoContract >(arena);
}
template<> PROTOBUF_NOINLINE ::RangeContract*
Arena::CreateMaybeMessage< ::RangeContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RangeContract >(arena);
}
template<> PROTOBUF_NOINLINE ::RangesContract*
Arena::CreateMaybeMessage< ::RangesContract >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RangesContract >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

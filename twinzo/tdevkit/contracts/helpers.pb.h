// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: helpers.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_helpers_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_helpers_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "core.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_helpers_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_helpers_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_helpers_2eproto;
class AreaContractList;
struct AreaContractListDefaultTypeInternal;
extern AreaContractListDefaultTypeInternal _AreaContractList_default_instance_;
class DeviceContractList;
struct DeviceContractListDefaultTypeInternal;
extern DeviceContractListDefaultTypeInternal _DeviceContractList_default_instance_;
class DeviceLocationContractList;
struct DeviceLocationContractListDefaultTypeInternal;
extern DeviceLocationContractListDefaultTypeInternal _DeviceLocationContractList_default_instance_;
class DistanceContractList;
struct DistanceContractListDefaultTypeInternal;
extern DistanceContractListDefaultTypeInternal _DistanceContractList_default_instance_;
class LayerContractList;
struct LayerContractListDefaultTypeInternal;
extern LayerContractListDefaultTypeInternal _LayerContractList_default_instance_;
class LocationContractList;
struct LocationContractListDefaultTypeInternal;
extern LocationContractListDefaultTypeInternal _LocationContractList_default_instance_;
class SensorBatchContractList;
struct SensorBatchContractListDefaultTypeInternal;
extern SensorBatchContractListDefaultTypeInternal _SensorBatchContractList_default_instance_;
class SensorContractList;
struct SensorContractListDefaultTypeInternal;
extern SensorContractListDefaultTypeInternal _SensorContractList_default_instance_;
class SensorDataBatchContractList;
struct SensorDataBatchContractListDefaultTypeInternal;
extern SensorDataBatchContractListDefaultTypeInternal _SensorDataBatchContractList_default_instance_;
class SensorDataContractList;
struct SensorDataContractListDefaultTypeInternal;
extern SensorDataContractListDefaultTypeInternal _SensorDataContractList_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AreaContractList* Arena::CreateMaybeMessage<::AreaContractList>(Arena*);
template<> ::DeviceContractList* Arena::CreateMaybeMessage<::DeviceContractList>(Arena*);
template<> ::DeviceLocationContractList* Arena::CreateMaybeMessage<::DeviceLocationContractList>(Arena*);
template<> ::DistanceContractList* Arena::CreateMaybeMessage<::DistanceContractList>(Arena*);
template<> ::LayerContractList* Arena::CreateMaybeMessage<::LayerContractList>(Arena*);
template<> ::LocationContractList* Arena::CreateMaybeMessage<::LocationContractList>(Arena*);
template<> ::SensorBatchContractList* Arena::CreateMaybeMessage<::SensorBatchContractList>(Arena*);
template<> ::SensorContractList* Arena::CreateMaybeMessage<::SensorContractList>(Arena*);
template<> ::SensorDataBatchContractList* Arena::CreateMaybeMessage<::SensorDataBatchContractList>(Arena*);
template<> ::SensorDataContractList* Arena::CreateMaybeMessage<::SensorDataContractList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class DeviceContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceContractList) */ {
 public:
  inline DeviceContractList() : DeviceContractList(nullptr) {}
  ~DeviceContractList() override;
  explicit PROTOBUF_CONSTEXPR DeviceContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceContractList(const DeviceContractList& from);
  DeviceContractList(DeviceContractList&& from) noexcept
    : DeviceContractList() {
    *this = ::std::move(from);
  }

  inline DeviceContractList& operator=(const DeviceContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceContractList& operator=(DeviceContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceContractList* internal_default_instance() {
    return reinterpret_cast<const DeviceContractList*>(
               &_DeviceContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceContractList& a, DeviceContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceContractList& from) {
    DeviceContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceContractList";
  }
  protected:
  explicit DeviceContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .DeviceContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::DeviceContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >*
      mutable_contracts();
  private:
  const ::DeviceContract& _internal_contracts(int index) const;
  ::DeviceContract* _internal_add_contracts();
  public:
  const ::DeviceContract& contracts(int index) const;
  ::DeviceContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:DeviceContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class DeviceLocationContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceLocationContractList) */ {
 public:
  inline DeviceLocationContractList() : DeviceLocationContractList(nullptr) {}
  ~DeviceLocationContractList() override;
  explicit PROTOBUF_CONSTEXPR DeviceLocationContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLocationContractList(const DeviceLocationContractList& from);
  DeviceLocationContractList(DeviceLocationContractList&& from) noexcept
    : DeviceLocationContractList() {
    *this = ::std::move(from);
  }

  inline DeviceLocationContractList& operator=(const DeviceLocationContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLocationContractList& operator=(DeviceLocationContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceLocationContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLocationContractList* internal_default_instance() {
    return reinterpret_cast<const DeviceLocationContractList*>(
               &_DeviceLocationContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceLocationContractList& a, DeviceLocationContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLocationContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLocationContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLocationContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLocationContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceLocationContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceLocationContractList& from) {
    DeviceLocationContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceLocationContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceLocationContractList";
  }
  protected:
  explicit DeviceLocationContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .DeviceLocationContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::DeviceLocationContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceLocationContract >*
      mutable_contracts();
  private:
  const ::DeviceLocationContract& _internal_contracts(int index) const;
  ::DeviceLocationContract* _internal_add_contracts();
  public:
  const ::DeviceLocationContract& contracts(int index) const;
  ::DeviceLocationContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceLocationContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:DeviceLocationContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceLocationContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class LocationContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LocationContractList) */ {
 public:
  inline LocationContractList() : LocationContractList(nullptr) {}
  ~LocationContractList() override;
  explicit PROTOBUF_CONSTEXPR LocationContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationContractList(const LocationContractList& from);
  LocationContractList(LocationContractList&& from) noexcept
    : LocationContractList() {
    *this = ::std::move(from);
  }

  inline LocationContractList& operator=(const LocationContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationContractList& operator=(LocationContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationContractList* internal_default_instance() {
    return reinterpret_cast<const LocationContractList*>(
               &_LocationContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LocationContractList& a, LocationContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationContractList& from) {
    LocationContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LocationContractList";
  }
  protected:
  explicit LocationContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .LocationContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::LocationContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >*
      mutable_contracts();
  private:
  const ::LocationContract& _internal_contracts(int index) const;
  ::LocationContract* _internal_add_contracts();
  public:
  const ::LocationContract& contracts(int index) const;
  ::LocationContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:LocationContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class DistanceContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DistanceContractList) */ {
 public:
  inline DistanceContractList() : DistanceContractList(nullptr) {}
  ~DistanceContractList() override;
  explicit PROTOBUF_CONSTEXPR DistanceContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistanceContractList(const DistanceContractList& from);
  DistanceContractList(DistanceContractList&& from) noexcept
    : DistanceContractList() {
    *this = ::std::move(from);
  }

  inline DistanceContractList& operator=(const DistanceContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistanceContractList& operator=(DistanceContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistanceContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistanceContractList* internal_default_instance() {
    return reinterpret_cast<const DistanceContractList*>(
               &_DistanceContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DistanceContractList& a, DistanceContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(DistanceContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistanceContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistanceContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DistanceContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DistanceContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DistanceContractList& from) {
    DistanceContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistanceContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DistanceContractList";
  }
  protected:
  explicit DistanceContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .DistanceContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::DistanceContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >*
      mutable_contracts();
  private:
  const ::DistanceContract& _internal_contracts(int index) const;
  ::DistanceContract* _internal_add_contracts();
  public:
  const ::DistanceContract& contracts(int index) const;
  ::DistanceContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:DistanceContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class LayerContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LayerContractList) */ {
 public:
  inline LayerContractList() : LayerContractList(nullptr) {}
  ~LayerContractList() override;
  explicit PROTOBUF_CONSTEXPR LayerContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayerContractList(const LayerContractList& from);
  LayerContractList(LayerContractList&& from) noexcept
    : LayerContractList() {
    *this = ::std::move(from);
  }

  inline LayerContractList& operator=(const LayerContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerContractList& operator=(LayerContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayerContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayerContractList* internal_default_instance() {
    return reinterpret_cast<const LayerContractList*>(
               &_LayerContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LayerContractList& a, LayerContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayerContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayerContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayerContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayerContractList& from) {
    LayerContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LayerContractList";
  }
  protected:
  explicit LayerContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .LayerContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::LayerContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >*
      mutable_contracts();
  private:
  const ::LayerContract& _internal_contracts(int index) const;
  ::LayerContract* _internal_add_contracts();
  public:
  const ::LayerContract& contracts(int index) const;
  ::LayerContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:LayerContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class AreaContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AreaContractList) */ {
 public:
  inline AreaContractList() : AreaContractList(nullptr) {}
  ~AreaContractList() override;
  explicit PROTOBUF_CONSTEXPR AreaContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaContractList(const AreaContractList& from);
  AreaContractList(AreaContractList&& from) noexcept
    : AreaContractList() {
    *this = ::std::move(from);
  }

  inline AreaContractList& operator=(const AreaContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaContractList& operator=(AreaContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaContractList* internal_default_instance() {
    return reinterpret_cast<const AreaContractList*>(
               &_AreaContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AreaContractList& a, AreaContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaContractList& from) {
    AreaContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AreaContractList";
  }
  protected:
  explicit AreaContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .AreaContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::AreaContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >*
      mutable_contracts();
  private:
  const ::AreaContract& _internal_contracts(int index) const;
  ::AreaContract* _internal_add_contracts();
  public:
  const ::AreaContract& contracts(int index) const;
  ::AreaContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:AreaContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class SensorContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorContractList) */ {
 public:
  inline SensorContractList() : SensorContractList(nullptr) {}
  ~SensorContractList() override;
  explicit PROTOBUF_CONSTEXPR SensorContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorContractList(const SensorContractList& from);
  SensorContractList(SensorContractList&& from) noexcept
    : SensorContractList() {
    *this = ::std::move(from);
  }

  inline SensorContractList& operator=(const SensorContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorContractList& operator=(SensorContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorContractList* internal_default_instance() {
    return reinterpret_cast<const SensorContractList*>(
               &_SensorContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SensorContractList& a, SensorContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorContractList& from) {
    SensorContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorContractList";
  }
  protected:
  explicit SensorContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .SensorContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::SensorContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >*
      mutable_contracts();
  private:
  const ::SensorContract& _internal_contracts(int index) const;
  ::SensorContract* _internal_add_contracts();
  public:
  const ::SensorContract& contracts(int index) const;
  ::SensorContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:SensorContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class SensorDataContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorDataContractList) */ {
 public:
  inline SensorDataContractList() : SensorDataContractList(nullptr) {}
  ~SensorDataContractList() override;
  explicit PROTOBUF_CONSTEXPR SensorDataContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorDataContractList(const SensorDataContractList& from);
  SensorDataContractList(SensorDataContractList&& from) noexcept
    : SensorDataContractList() {
    *this = ::std::move(from);
  }

  inline SensorDataContractList& operator=(const SensorDataContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDataContractList& operator=(SensorDataContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorDataContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorDataContractList* internal_default_instance() {
    return reinterpret_cast<const SensorDataContractList*>(
               &_SensorDataContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SensorDataContractList& a, SensorDataContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorDataContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorDataContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorDataContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorDataContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorDataContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorDataContractList& from) {
    SensorDataContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDataContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorDataContractList";
  }
  protected:
  explicit SensorDataContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .SensorDataContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::SensorDataContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >*
      mutable_contracts();
  private:
  const ::SensorDataContract& _internal_contracts(int index) const;
  ::SensorDataContract* _internal_add_contracts();
  public:
  const ::SensorDataContract& contracts(int index) const;
  ::SensorDataContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:SensorDataContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class SensorBatchContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorBatchContractList) */ {
 public:
  inline SensorBatchContractList() : SensorBatchContractList(nullptr) {}
  ~SensorBatchContractList() override;
  explicit PROTOBUF_CONSTEXPR SensorBatchContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorBatchContractList(const SensorBatchContractList& from);
  SensorBatchContractList(SensorBatchContractList&& from) noexcept
    : SensorBatchContractList() {
    *this = ::std::move(from);
  }

  inline SensorBatchContractList& operator=(const SensorBatchContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorBatchContractList& operator=(SensorBatchContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorBatchContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorBatchContractList* internal_default_instance() {
    return reinterpret_cast<const SensorBatchContractList*>(
               &_SensorBatchContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SensorBatchContractList& a, SensorBatchContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorBatchContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorBatchContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorBatchContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorBatchContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorBatchContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorBatchContractList& from) {
    SensorBatchContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorBatchContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorBatchContractList";
  }
  protected:
  explicit SensorBatchContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .SensorBatchContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::SensorBatchContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorBatchContract >*
      mutable_contracts();
  private:
  const ::SensorBatchContract& _internal_contracts(int index) const;
  ::SensorBatchContract* _internal_add_contracts();
  public:
  const ::SensorBatchContract& contracts(int index) const;
  ::SensorBatchContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorBatchContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:SensorBatchContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorBatchContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// -------------------------------------------------------------------

class SensorDataBatchContractList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorDataBatchContractList) */ {
 public:
  inline SensorDataBatchContractList() : SensorDataBatchContractList(nullptr) {}
  ~SensorDataBatchContractList() override;
  explicit PROTOBUF_CONSTEXPR SensorDataBatchContractList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorDataBatchContractList(const SensorDataBatchContractList& from);
  SensorDataBatchContractList(SensorDataBatchContractList&& from) noexcept
    : SensorDataBatchContractList() {
    *this = ::std::move(from);
  }

  inline SensorDataBatchContractList& operator=(const SensorDataBatchContractList& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDataBatchContractList& operator=(SensorDataBatchContractList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorDataBatchContractList& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorDataBatchContractList* internal_default_instance() {
    return reinterpret_cast<const SensorDataBatchContractList*>(
               &_SensorDataBatchContractList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SensorDataBatchContractList& a, SensorDataBatchContractList& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorDataBatchContractList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorDataBatchContractList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorDataBatchContractList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorDataBatchContractList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorDataBatchContractList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorDataBatchContractList& from) {
    SensorDataBatchContractList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDataBatchContractList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorDataBatchContractList";
  }
  protected:
  explicit SensorDataBatchContractList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContractsFieldNumber = 1,
  };
  // repeated .SensorDataBatchContract contracts = 1;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  ::SensorDataBatchContract* mutable_contracts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >*
      mutable_contracts();
  private:
  const ::SensorDataBatchContract& _internal_contracts(int index) const;
  ::SensorDataBatchContract* _internal_add_contracts();
  public:
  const ::SensorDataBatchContract& contracts(int index) const;
  ::SensorDataBatchContract* add_contracts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >&
      contracts() const;

  // @@protoc_insertion_point(class_scope:SensorDataBatchContractList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract > contracts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_helpers_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceContractList

// repeated .DeviceContract contracts = 1;
inline int DeviceContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int DeviceContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::DeviceContract* DeviceContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:DeviceContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >*
DeviceContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:DeviceContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::DeviceContract& DeviceContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::DeviceContract& DeviceContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:DeviceContractList.contracts)
  return _internal_contracts(index);
}
inline ::DeviceContract* DeviceContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::DeviceContract* DeviceContractList::add_contracts() {
  ::DeviceContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:DeviceContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >&
DeviceContractList::contracts() const {
  // @@protoc_insertion_point(field_list:DeviceContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// DeviceLocationContractList

// repeated .DeviceLocationContract contracts = 1;
inline int DeviceLocationContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int DeviceLocationContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::DeviceLocationContract* DeviceLocationContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:DeviceLocationContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceLocationContract >*
DeviceLocationContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:DeviceLocationContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::DeviceLocationContract& DeviceLocationContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::DeviceLocationContract& DeviceLocationContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:DeviceLocationContractList.contracts)
  return _internal_contracts(index);
}
inline ::DeviceLocationContract* DeviceLocationContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::DeviceLocationContract* DeviceLocationContractList::add_contracts() {
  ::DeviceLocationContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:DeviceLocationContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceLocationContract >&
DeviceLocationContractList::contracts() const {
  // @@protoc_insertion_point(field_list:DeviceLocationContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// LocationContractList

// repeated .LocationContract contracts = 1;
inline int LocationContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int LocationContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::LocationContract* LocationContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:LocationContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >*
LocationContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:LocationContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::LocationContract& LocationContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::LocationContract& LocationContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:LocationContractList.contracts)
  return _internal_contracts(index);
}
inline ::LocationContract* LocationContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::LocationContract* LocationContractList::add_contracts() {
  ::LocationContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:LocationContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >&
LocationContractList::contracts() const {
  // @@protoc_insertion_point(field_list:LocationContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// DistanceContractList

// repeated .DistanceContract contracts = 1;
inline int DistanceContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int DistanceContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::DistanceContract* DistanceContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:DistanceContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >*
DistanceContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:DistanceContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::DistanceContract& DistanceContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::DistanceContract& DistanceContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:DistanceContractList.contracts)
  return _internal_contracts(index);
}
inline ::DistanceContract* DistanceContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::DistanceContract* DistanceContractList::add_contracts() {
  ::DistanceContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:DistanceContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >&
DistanceContractList::contracts() const {
  // @@protoc_insertion_point(field_list:DistanceContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// LayerContractList

// repeated .LayerContract contracts = 1;
inline int LayerContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int LayerContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::LayerContract* LayerContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:LayerContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >*
LayerContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:LayerContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::LayerContract& LayerContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::LayerContract& LayerContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:LayerContractList.contracts)
  return _internal_contracts(index);
}
inline ::LayerContract* LayerContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::LayerContract* LayerContractList::add_contracts() {
  ::LayerContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:LayerContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >&
LayerContractList::contracts() const {
  // @@protoc_insertion_point(field_list:LayerContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// AreaContractList

// repeated .AreaContract contracts = 1;
inline int AreaContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int AreaContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::AreaContract* AreaContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:AreaContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >*
AreaContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:AreaContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::AreaContract& AreaContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::AreaContract& AreaContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:AreaContractList.contracts)
  return _internal_contracts(index);
}
inline ::AreaContract* AreaContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::AreaContract* AreaContractList::add_contracts() {
  ::AreaContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:AreaContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >&
AreaContractList::contracts() const {
  // @@protoc_insertion_point(field_list:AreaContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// SensorContractList

// repeated .SensorContract contracts = 1;
inline int SensorContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int SensorContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::SensorContract* SensorContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:SensorContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >*
SensorContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:SensorContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::SensorContract& SensorContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::SensorContract& SensorContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:SensorContractList.contracts)
  return _internal_contracts(index);
}
inline ::SensorContract* SensorContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::SensorContract* SensorContractList::add_contracts() {
  ::SensorContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:SensorContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >&
SensorContractList::contracts() const {
  // @@protoc_insertion_point(field_list:SensorContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// SensorDataContractList

// repeated .SensorDataContract contracts = 1;
inline int SensorDataContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int SensorDataContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::SensorDataContract* SensorDataContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:SensorDataContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >*
SensorDataContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:SensorDataContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::SensorDataContract& SensorDataContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::SensorDataContract& SensorDataContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:SensorDataContractList.contracts)
  return _internal_contracts(index);
}
inline ::SensorDataContract* SensorDataContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::SensorDataContract* SensorDataContractList::add_contracts() {
  ::SensorDataContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:SensorDataContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >&
SensorDataContractList::contracts() const {
  // @@protoc_insertion_point(field_list:SensorDataContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// SensorBatchContractList

// repeated .SensorBatchContract contracts = 1;
inline int SensorBatchContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int SensorBatchContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::SensorBatchContract* SensorBatchContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:SensorBatchContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorBatchContract >*
SensorBatchContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:SensorBatchContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::SensorBatchContract& SensorBatchContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::SensorBatchContract& SensorBatchContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:SensorBatchContractList.contracts)
  return _internal_contracts(index);
}
inline ::SensorBatchContract* SensorBatchContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::SensorBatchContract* SensorBatchContractList::add_contracts() {
  ::SensorBatchContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:SensorBatchContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorBatchContract >&
SensorBatchContractList::contracts() const {
  // @@protoc_insertion_point(field_list:SensorBatchContractList.contracts)
  return _impl_.contracts_;
}

// -------------------------------------------------------------------

// SensorDataBatchContractList

// repeated .SensorDataBatchContract contracts = 1;
inline int SensorDataBatchContractList::_internal_contracts_size() const {
  return _impl_.contracts_.size();
}
inline int SensorDataBatchContractList::contracts_size() const {
  return _internal_contracts_size();
}
inline ::SensorDataBatchContract* SensorDataBatchContractList::mutable_contracts(int index) {
  // @@protoc_insertion_point(field_mutable:SensorDataBatchContractList.contracts)
  return _impl_.contracts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >*
SensorDataBatchContractList::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_list:SensorDataBatchContractList.contracts)
  return &_impl_.contracts_;
}
inline const ::SensorDataBatchContract& SensorDataBatchContractList::_internal_contracts(int index) const {
  return _impl_.contracts_.Get(index);
}
inline const ::SensorDataBatchContract& SensorDataBatchContractList::contracts(int index) const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContractList.contracts)
  return _internal_contracts(index);
}
inline ::SensorDataBatchContract* SensorDataBatchContractList::_internal_add_contracts() {
  return _impl_.contracts_.Add();
}
inline ::SensorDataBatchContract* SensorDataBatchContractList::add_contracts() {
  ::SensorDataBatchContract* _add = _internal_add_contracts();
  // @@protoc_insertion_point(field_add:SensorDataBatchContractList.contracts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >&
SensorDataBatchContractList::contracts() const {
  // @@protoc_insertion_point(field_list:SensorDataBatchContractList.contracts)
  return _impl_.contracts_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_helpers_2eproto

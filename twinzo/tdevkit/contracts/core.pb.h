// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_core_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_core_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_core_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_core_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_core_2eproto;
class AreaContract;
struct AreaContractDefaultTypeInternal;
extern AreaContractDefaultTypeInternal _AreaContract_default_instance_;
class AuthenticationResponseContract;
struct AuthenticationResponseContractDefaultTypeInternal;
extern AuthenticationResponseContractDefaultTypeInternal _AuthenticationResponseContract_default_instance_;
class BarrierContract;
struct BarrierContractDefaultTypeInternal;
extern BarrierContractDefaultTypeInternal _BarrierContract_default_instance_;
class BeaconContract;
struct BeaconContractDefaultTypeInternal;
extern BeaconContractDefaultTypeInternal _BeaconContract_default_instance_;
class BeaconPositionContract;
struct BeaconPositionContractDefaultTypeInternal;
extern BeaconPositionContractDefaultTypeInternal _BeaconPositionContract_default_instance_;
class BranchContract;
struct BranchContractDefaultTypeInternal;
extern BranchContractDefaultTypeInternal _BranchContract_default_instance_;
class CredentialContract;
struct CredentialContractDefaultTypeInternal;
extern CredentialContractDefaultTypeInternal _CredentialContract_default_instance_;
class DeviceContract;
struct DeviceContractDefaultTypeInternal;
extern DeviceContractDefaultTypeInternal _DeviceContract_default_instance_;
class DeviceLocationContract;
struct DeviceLocationContractDefaultTypeInternal;
extern DeviceLocationContractDefaultTypeInternal _DeviceLocationContract_default_instance_;
class DistanceContract;
struct DistanceContractDefaultTypeInternal;
extern DistanceContractDefaultTypeInternal _DistanceContract_default_instance_;
class GpsItemContract;
struct GpsItemContractDefaultTypeInternal;
extern GpsItemContractDefaultTypeInternal _GpsItemContract_default_instance_;
class Guid;
struct GuidDefaultTypeInternal;
extern GuidDefaultTypeInternal _Guid_default_instance_;
class LayerContract;
struct LayerContractDefaultTypeInternal;
extern LayerContractDefaultTypeInternal _LayerContract_default_instance_;
class LocationContract;
struct LocationContractDefaultTypeInternal;
extern LocationContractDefaultTypeInternal _LocationContract_default_instance_;
class LoginContract;
struct LoginContractDefaultTypeInternal;
extern LoginContractDefaultTypeInternal _LoginContract_default_instance_;
class PathContract;
struct PathContractDefaultTypeInternal;
extern PathContractDefaultTypeInternal _PathContract_default_instance_;
class PathPointContract;
struct PathPointContractDefaultTypeInternal;
extern PathPointContractDefaultTypeInternal _PathPointContract_default_instance_;
class PointContract;
struct PointContractDefaultTypeInternal;
extern PointContractDefaultTypeInternal _PointContract_default_instance_;
class PostResponseContract;
struct PostResponseContractDefaultTypeInternal;
extern PostResponseContractDefaultTypeInternal _PostResponseContract_default_instance_;
class RangeContract;
struct RangeContractDefaultTypeInternal;
extern RangeContractDefaultTypeInternal _RangeContract_default_instance_;
class RangesContract;
struct RangesContractDefaultTypeInternal;
extern RangesContractDefaultTypeInternal _RangesContract_default_instance_;
class SectorContract;
struct SectorContractDefaultTypeInternal;
extern SectorContractDefaultTypeInternal _SectorContract_default_instance_;
class SensorAppInfoContract;
struct SensorAppInfoContractDefaultTypeInternal;
extern SensorAppInfoContractDefaultTypeInternal _SensorAppInfoContract_default_instance_;
class SensorBatchContract;
struct SensorBatchContractDefaultTypeInternal;
extern SensorBatchContractDefaultTypeInternal _SensorBatchContract_default_instance_;
class SensorContract;
struct SensorContractDefaultTypeInternal;
extern SensorContractDefaultTypeInternal _SensorContract_default_instance_;
class SensorDataBatchContract;
struct SensorDataBatchContractDefaultTypeInternal;
extern SensorDataBatchContractDefaultTypeInternal _SensorDataBatchContract_default_instance_;
class SensorDataContract;
struct SensorDataContractDefaultTypeInternal;
extern SensorDataContractDefaultTypeInternal _SensorDataContract_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AreaContract* Arena::CreateMaybeMessage<::AreaContract>(Arena*);
template<> ::AuthenticationResponseContract* Arena::CreateMaybeMessage<::AuthenticationResponseContract>(Arena*);
template<> ::BarrierContract* Arena::CreateMaybeMessage<::BarrierContract>(Arena*);
template<> ::BeaconContract* Arena::CreateMaybeMessage<::BeaconContract>(Arena*);
template<> ::BeaconPositionContract* Arena::CreateMaybeMessage<::BeaconPositionContract>(Arena*);
template<> ::BranchContract* Arena::CreateMaybeMessage<::BranchContract>(Arena*);
template<> ::CredentialContract* Arena::CreateMaybeMessage<::CredentialContract>(Arena*);
template<> ::DeviceContract* Arena::CreateMaybeMessage<::DeviceContract>(Arena*);
template<> ::DeviceLocationContract* Arena::CreateMaybeMessage<::DeviceLocationContract>(Arena*);
template<> ::DistanceContract* Arena::CreateMaybeMessage<::DistanceContract>(Arena*);
template<> ::GpsItemContract* Arena::CreateMaybeMessage<::GpsItemContract>(Arena*);
template<> ::Guid* Arena::CreateMaybeMessage<::Guid>(Arena*);
template<> ::LayerContract* Arena::CreateMaybeMessage<::LayerContract>(Arena*);
template<> ::LocationContract* Arena::CreateMaybeMessage<::LocationContract>(Arena*);
template<> ::LoginContract* Arena::CreateMaybeMessage<::LoginContract>(Arena*);
template<> ::PathContract* Arena::CreateMaybeMessage<::PathContract>(Arena*);
template<> ::PathPointContract* Arena::CreateMaybeMessage<::PathPointContract>(Arena*);
template<> ::PointContract* Arena::CreateMaybeMessage<::PointContract>(Arena*);
template<> ::PostResponseContract* Arena::CreateMaybeMessage<::PostResponseContract>(Arena*);
template<> ::RangeContract* Arena::CreateMaybeMessage<::RangeContract>(Arena*);
template<> ::RangesContract* Arena::CreateMaybeMessage<::RangesContract>(Arena*);
template<> ::SectorContract* Arena::CreateMaybeMessage<::SectorContract>(Arena*);
template<> ::SensorAppInfoContract* Arena::CreateMaybeMessage<::SensorAppInfoContract>(Arena*);
template<> ::SensorBatchContract* Arena::CreateMaybeMessage<::SensorBatchContract>(Arena*);
template<> ::SensorContract* Arena::CreateMaybeMessage<::SensorContract>(Arena*);
template<> ::SensorDataBatchContract* Arena::CreateMaybeMessage<::SensorDataBatchContract>(Arena*);
template<> ::SensorDataContract* Arena::CreateMaybeMessage<::SensorDataContract>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class Guid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Guid) */ {
 public:
  inline Guid() : Guid(nullptr) {}
  ~Guid() override;
  explicit PROTOBUF_CONSTEXPR Guid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Guid(const Guid& from);
  Guid(Guid&& from) noexcept
    : Guid() {
    *this = ::std::move(from);
  }

  inline Guid& operator=(const Guid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Guid& operator=(Guid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Guid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Guid* internal_default_instance() {
    return reinterpret_cast<const Guid*>(
               &_Guid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Guid& a, Guid& b) {
    a.Swap(&b);
  }
  inline void Swap(Guid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Guid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Guid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Guid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Guid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Guid& from) {
    Guid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Guid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Guid";
  }
  protected:
  explicit Guid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoFieldNumber = 1,
    kHiFieldNumber = 2,
  };
  // fixed64 lo = 1;
  void clear_lo();
  uint64_t lo() const;
  void set_lo(uint64_t value);
  private:
  uint64_t _internal_lo() const;
  void _internal_set_lo(uint64_t value);
  public:

  // fixed64 hi = 2;
  void clear_hi();
  uint64_t hi() const;
  void set_hi(uint64_t value);
  private:
  uint64_t _internal_hi() const;
  void _internal_set_hi(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Guid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t lo_;
    uint64_t hi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class DeviceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceContract) */ {
 public:
  inline DeviceContract() : DeviceContract(nullptr) {}
  ~DeviceContract() override;
  explicit PROTOBUF_CONSTEXPR DeviceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceContract(const DeviceContract& from);
  DeviceContract(DeviceContract&& from) noexcept
    : DeviceContract() {
    *this = ::std::move(from);
  }

  inline DeviceContract& operator=(const DeviceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceContract& operator=(DeviceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceContract* internal_default_instance() {
    return reinterpret_cast<const DeviceContract*>(
               &_DeviceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceContract& a, DeviceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceContract& from) {
    DeviceContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceContract";
  }
  protected:
  explicit DeviceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 27,
    kMacFieldNumber = 2,
    kTitleFieldNumber = 8,
    kNoteFieldNumber = 9,
    kAppVersionFieldNumber = 16,
    kFallStatusFieldNumber = 18,
    kDeviceTypeFieldNumber = 21,
    kLoginFieldNumber = 22,
    kPasswordFieldNumber = 26,
    kDeviceStatusFieldNumber = 28,
    kBranchFieldNumber = 4,
    kSectorFieldNumber = 6,
    kIdFieldNumber = 1,
    kBranchIdFieldNumber = 3,
    kSectorIdFieldNumber = 5,
    kValidSectorIdFieldNumber = 7,
    kLastTimeOnlineFieldNumber = 10,
    kValidLastTimeOnlineFieldNumber = 11,
    kXFieldNumber = 12,
    kYFieldNumber = 13,
    kValidXFieldNumber = 14,
    kValidYFieldNumber = 15,
    kBatteryFieldNumber = 19,
    kDeviceTypeIdFieldNumber = 20,
    kIsMovingFieldNumber = 17,
    kPositionFieldNumber = 23,
    kGeofenceFieldNumber = 24,
    kGeofenceRangeFieldNumber = 25,
    kHeartbeatFieldNumber = 29,
  };
  // repeated .LayerContract Layers = 27;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::LayerContract* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >*
      mutable_layers();
  private:
  const ::LayerContract& _internal_layers(int index) const;
  ::LayerContract* _internal_add_layers();
  public:
  const ::LayerContract& layers(int index) const;
  ::LayerContract* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >&
      layers() const;

  // string Mac = 2;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string Title = 8;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Note = 9;
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string AppVersion = 16;
  void clear_appversion();
  const std::string& appversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appversion();
  PROTOBUF_NODISCARD std::string* release_appversion();
  void set_allocated_appversion(std::string* appversion);
  private:
  const std::string& _internal_appversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appversion(const std::string& value);
  std::string* _internal_mutable_appversion();
  public:

  // string FallStatus = 18;
  void clear_fallstatus();
  const std::string& fallstatus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fallstatus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fallstatus();
  PROTOBUF_NODISCARD std::string* release_fallstatus();
  void set_allocated_fallstatus(std::string* fallstatus);
  private:
  const std::string& _internal_fallstatus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fallstatus(const std::string& value);
  std::string* _internal_mutable_fallstatus();
  public:

  // string DeviceType = 21;
  void clear_devicetype();
  const std::string& devicetype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicetype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicetype();
  PROTOBUF_NODISCARD std::string* release_devicetype();
  void set_allocated_devicetype(std::string* devicetype);
  private:
  const std::string& _internal_devicetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicetype(const std::string& value);
  std::string* _internal_mutable_devicetype();
  public:

  // string Login = 22;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string Password = 26;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string DeviceStatus = 28;
  void clear_devicestatus();
  const std::string& devicestatus() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicestatus(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicestatus();
  PROTOBUF_NODISCARD std::string* release_devicestatus();
  void set_allocated_devicestatus(std::string* devicestatus);
  private:
  const std::string& _internal_devicestatus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicestatus(const std::string& value);
  std::string* _internal_mutable_devicestatus();
  public:

  // optional .BranchContract Branch = 4;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // optional .SectorContract Sector = 6;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 BranchId = 3;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // optional int32 SectorId = 5;
  bool has_sectorid() const;
  private:
  bool _internal_has_sectorid() const;
  public:
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // optional int32 ValidSectorId = 7;
  bool has_validsectorid() const;
  private:
  bool _internal_has_validsectorid() const;
  public:
  void clear_validsectorid();
  int32_t validsectorid() const;
  void set_validsectorid(int32_t value);
  private:
  int32_t _internal_validsectorid() const;
  void _internal_set_validsectorid(int32_t value);
  public:

  // optional int64 LastTimeOnline = 10;
  bool has_lasttimeonline() const;
  private:
  bool _internal_has_lasttimeonline() const;
  public:
  void clear_lasttimeonline();
  int64_t lasttimeonline() const;
  void set_lasttimeonline(int64_t value);
  private:
  int64_t _internal_lasttimeonline() const;
  void _internal_set_lasttimeonline(int64_t value);
  public:

  // optional int64 ValidLastTimeOnline = 11;
  bool has_validlasttimeonline() const;
  private:
  bool _internal_has_validlasttimeonline() const;
  public:
  void clear_validlasttimeonline();
  int64_t validlasttimeonline() const;
  void set_validlasttimeonline(int64_t value);
  private:
  int64_t _internal_validlasttimeonline() const;
  void _internal_set_validlasttimeonline(int64_t value);
  public:

  // optional float X = 12;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float Y = 13;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float ValidX = 14;
  bool has_validx() const;
  private:
  bool _internal_has_validx() const;
  public:
  void clear_validx();
  float validx() const;
  void set_validx(float value);
  private:
  float _internal_validx() const;
  void _internal_set_validx(float value);
  public:

  // optional float ValidY = 15;
  bool has_validy() const;
  private:
  bool _internal_has_validy() const;
  public:
  void clear_validy();
  float validy() const;
  void set_validy(float value);
  private:
  float _internal_validy() const;
  void _internal_set_validy(float value);
  public:

  // optional float Battery = 19;
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  float battery() const;
  void set_battery(float value);
  private:
  float _internal_battery() const;
  void _internal_set_battery(float value);
  public:

  // int32 DeviceTypeId = 20;
  void clear_devicetypeid();
  int32_t devicetypeid() const;
  void set_devicetypeid(int32_t value);
  private:
  int32_t _internal_devicetypeid() const;
  void _internal_set_devicetypeid(int32_t value);
  public:

  // bool IsMoving = 17;
  void clear_ismoving();
  bool ismoving() const;
  void set_ismoving(bool value);
  private:
  bool _internal_ismoving() const;
  void _internal_set_ismoving(bool value);
  public:

  // bool Position = 23;
  void clear_position();
  bool position() const;
  void set_position(bool value);
  private:
  bool _internal_position() const;
  void _internal_set_position(bool value);
  public:

  // bool Geofence = 24;
  void clear_geofence();
  bool geofence() const;
  void set_geofence(bool value);
  private:
  bool _internal_geofence() const;
  void _internal_set_geofence(bool value);
  public:

  // optional uint32 GeofenceRange = 25;
  bool has_geofencerange() const;
  private:
  bool _internal_has_geofencerange() const;
  public:
  void clear_geofencerange();
  uint32_t geofencerange() const;
  void set_geofencerange(uint32_t value);
  private:
  uint32_t _internal_geofencerange() const;
  void _internal_set_geofencerange(uint32_t value);
  public:

  // optional int64 Heartbeat = 29;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  int64_t heartbeat() const;
  void set_heartbeat(int64_t value);
  private:
  int64_t _internal_heartbeat() const;
  void _internal_set_heartbeat(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:DeviceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract > layers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fallstatus_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicetype_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicestatus_;
    ::BranchContract* branch_;
    ::SectorContract* sector_;
    int32_t id_;
    int32_t branchid_;
    int32_t sectorid_;
    int32_t validsectorid_;
    int64_t lasttimeonline_;
    int64_t validlasttimeonline_;
    float x_;
    float y_;
    float validx_;
    float validy_;
    float battery_;
    int32_t devicetypeid_;
    bool ismoving_;
    bool position_;
    bool geofence_;
    uint32_t geofencerange_;
    int64_t heartbeat_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SectorContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SectorContract) */ {
 public:
  inline SectorContract() : SectorContract(nullptr) {}
  ~SectorContract() override;
  explicit PROTOBUF_CONSTEXPR SectorContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SectorContract(const SectorContract& from);
  SectorContract(SectorContract&& from) noexcept
    : SectorContract() {
    *this = ::std::move(from);
  }

  inline SectorContract& operator=(const SectorContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SectorContract& operator=(SectorContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SectorContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SectorContract* internal_default_instance() {
    return reinterpret_cast<const SectorContract*>(
               &_SectorContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SectorContract& a, SectorContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SectorContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SectorContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SectorContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SectorContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SectorContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SectorContract& from) {
    SectorContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SectorContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SectorContract";
  }
  protected:
  explicit SectorContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGpsItemsFieldNumber = 11,
    kAreasFieldNumber = 12,
    kBarriersFieldNumber = 13,
    kBeaconsFieldNumber = 14,
    kSensorsFieldNumber = 15,
    kPathsFieldNumber = 17,
    kGuidFieldNumber = 2,
    kTitleFieldNumber = 5,
    kConfigurationFieldNumber = 16,
    kBranchFieldNumber = 4,
    kIdFieldNumber = 1,
    kBranchIdFieldNumber = 3,
    kBarrierHeightFieldNumber = 6,
    kBarrierWidthFieldNumber = 7,
    kSectorHeightFieldNumber = 8,
    kSectorWidthFieldNumber = 9,
    kModifiedFieldNumber = 10,
  };
  // repeated .GpsItemContract GpsItems = 11;
  int gpsitems_size() const;
  private:
  int _internal_gpsitems_size() const;
  public:
  void clear_gpsitems();
  ::GpsItemContract* mutable_gpsitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GpsItemContract >*
      mutable_gpsitems();
  private:
  const ::GpsItemContract& _internal_gpsitems(int index) const;
  ::GpsItemContract* _internal_add_gpsitems();
  public:
  const ::GpsItemContract& gpsitems(int index) const;
  ::GpsItemContract* add_gpsitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GpsItemContract >&
      gpsitems() const;

  // repeated .AreaContract Areas = 12;
  int areas_size() const;
  private:
  int _internal_areas_size() const;
  public:
  void clear_areas();
  ::AreaContract* mutable_areas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >*
      mutable_areas();
  private:
  const ::AreaContract& _internal_areas(int index) const;
  ::AreaContract* _internal_add_areas();
  public:
  const ::AreaContract& areas(int index) const;
  ::AreaContract* add_areas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >&
      areas() const;

  // repeated .BarrierContract Barriers = 13;
  int barriers_size() const;
  private:
  int _internal_barriers_size() const;
  public:
  void clear_barriers();
  ::BarrierContract* mutable_barriers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BarrierContract >*
      mutable_barriers();
  private:
  const ::BarrierContract& _internal_barriers(int index) const;
  ::BarrierContract* _internal_add_barriers();
  public:
  const ::BarrierContract& barriers(int index) const;
  ::BarrierContract* add_barriers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BarrierContract >&
      barriers() const;

  // repeated .BeaconContract Beacons = 14;
  int beacons_size() const;
  private:
  int _internal_beacons_size() const;
  public:
  void clear_beacons();
  ::BeaconContract* mutable_beacons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BeaconContract >*
      mutable_beacons();
  private:
  const ::BeaconContract& _internal_beacons(int index) const;
  ::BeaconContract* _internal_add_beacons();
  public:
  const ::BeaconContract& beacons(int index) const;
  ::BeaconContract* add_beacons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BeaconContract >&
      beacons() const;

  // repeated .SensorContract Sensors = 15;
  int sensors_size() const;
  private:
  int _internal_sensors_size() const;
  public:
  void clear_sensors();
  ::SensorContract* mutable_sensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >*
      mutable_sensors();
  private:
  const ::SensorContract& _internal_sensors(int index) const;
  ::SensorContract* _internal_add_sensors();
  public:
  const ::SensorContract& sensors(int index) const;
  ::SensorContract* add_sensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >&
      sensors() const;

  // repeated .PathContract Paths = 17;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::PathContract* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >*
      mutable_paths();
  private:
  const ::PathContract& _internal_paths(int index) const;
  ::PathContract* _internal_add_paths();
  public:
  const ::PathContract& paths(int index) const;
  ::PathContract* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >&
      paths() const;

  // string Guid = 2;
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // string Title = 5;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Configuration = 16;
  void clear_configuration();
  const std::string& configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration();
  PROTOBUF_NODISCARD std::string* release_configuration();
  void set_allocated_configuration(std::string* configuration);
  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(const std::string& value);
  std::string* _internal_mutable_configuration();
  public:

  // optional .BranchContract Branch = 4;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 BranchId = 3;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // float BarrierHeight = 6;
  void clear_barrierheight();
  float barrierheight() const;
  void set_barrierheight(float value);
  private:
  float _internal_barrierheight() const;
  void _internal_set_barrierheight(float value);
  public:

  // float BarrierWidth = 7;
  void clear_barrierwidth();
  float barrierwidth() const;
  void set_barrierwidth(float value);
  private:
  float _internal_barrierwidth() const;
  void _internal_set_barrierwidth(float value);
  public:

  // float SectorHeight = 8;
  void clear_sectorheight();
  float sectorheight() const;
  void set_sectorheight(float value);
  private:
  float _internal_sectorheight() const;
  void _internal_set_sectorheight(float value);
  public:

  // float SectorWidth = 9;
  void clear_sectorwidth();
  float sectorwidth() const;
  void set_sectorwidth(float value);
  private:
  float _internal_sectorwidth() const;
  void _internal_set_sectorwidth(float value);
  public:

  // int64 Modified = 10;
  void clear_modified();
  int64_t modified() const;
  void set_modified(int64_t value);
  private:
  int64_t _internal_modified() const;
  void _internal_set_modified(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SectorContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GpsItemContract > gpsitems_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract > areas_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BarrierContract > barriers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BeaconContract > beacons_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract > sensors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract > paths_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_;
    ::BranchContract* branch_;
    int32_t id_;
    int32_t branchid_;
    float barrierheight_;
    float barrierwidth_;
    float sectorheight_;
    float sectorwidth_;
    int64_t modified_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class BranchContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BranchContract) */ {
 public:
  inline BranchContract() : BranchContract(nullptr) {}
  ~BranchContract() override;
  explicit PROTOBUF_CONSTEXPR BranchContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BranchContract(const BranchContract& from);
  BranchContract(BranchContract&& from) noexcept
    : BranchContract() {
    *this = ::std::move(from);
  }

  inline BranchContract& operator=(const BranchContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline BranchContract& operator=(BranchContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BranchContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const BranchContract* internal_default_instance() {
    return reinterpret_cast<const BranchContract*>(
               &_BranchContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BranchContract& a, BranchContract& b) {
    a.Swap(&b);
  }
  inline void Swap(BranchContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BranchContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BranchContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BranchContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BranchContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BranchContract& from) {
    BranchContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BranchContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BranchContract";
  }
  protected:
  explicit BranchContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectorsFieldNumber = 7,
    kTitleFieldNumber = 2,
    kTimeZoneFieldNumber = 4,
    kGuidFieldNumber = 3,
    kIdFieldNumber = 1,
    kLatitudeFieldNumber = 5,
    kLongtitudeFieldNumber = 6,
  };
  // repeated .SectorContract Sectors = 7;
  int sectors_size() const;
  private:
  int _internal_sectors_size() const;
  public:
  void clear_sectors();
  ::SectorContract* mutable_sectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SectorContract >*
      mutable_sectors();
  private:
  const ::SectorContract& _internal_sectors(int index) const;
  ::SectorContract* _internal_add_sectors();
  public:
  const ::SectorContract& sectors(int index) const;
  ::SectorContract* add_sectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SectorContract >&
      sectors() const;

  // string Title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string TimeZone = 4;
  void clear_timezone();
  const std::string& timezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_timezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_timezone();
  PROTOBUF_NODISCARD std::string* release_timezone();
  void set_allocated_timezone(std::string* timezone);
  private:
  const std::string& _internal_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timezone(const std::string& value);
  std::string* _internal_mutable_timezone();
  public:

  // .Guid Guid = 3;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const ::Guid& guid() const;
  PROTOBUF_NODISCARD ::Guid* release_guid();
  ::Guid* mutable_guid();
  void set_allocated_guid(::Guid* guid);
  private:
  const ::Guid& _internal_guid() const;
  ::Guid* _internal_mutable_guid();
  public:
  void unsafe_arena_set_allocated_guid(
      ::Guid* guid);
  ::Guid* unsafe_arena_release_guid();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // float Latitude = 5;
  void clear_latitude();
  float latitude() const;
  void set_latitude(float value);
  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);
  public:

  // float Longtitude = 6;
  void clear_longtitude();
  float longtitude() const;
  void set_longtitude(float value);
  private:
  float _internal_longtitude() const;
  void _internal_set_longtitude(float value);
  public:

  // @@protoc_insertion_point(class_scope:BranchContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SectorContract > sectors_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timezone_;
    ::Guid* guid_;
    int32_t id_;
    float latitude_;
    float longtitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class LayerContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LayerContract) */ {
 public:
  inline LayerContract() : LayerContract(nullptr) {}
  ~LayerContract() override;
  explicit PROTOBUF_CONSTEXPR LayerContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayerContract(const LayerContract& from);
  LayerContract(LayerContract&& from) noexcept
    : LayerContract() {
    *this = ::std::move(from);
  }

  inline LayerContract& operator=(const LayerContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayerContract& operator=(LayerContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayerContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayerContract* internal_default_instance() {
    return reinterpret_cast<const LayerContract*>(
               &_LayerContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LayerContract& a, LayerContract& b) {
    a.Swap(&b);
  }
  inline void Swap(LayerContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayerContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayerContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayerContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayerContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayerContract& from) {
    LayerContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayerContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LayerContract";
  }
  protected:
  explicit LayerContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAreasFieldNumber = 10,
    kDevicesFieldNumber = 11,
    kPathsFieldNumber = 13,
    kChildrenFieldNumber = 14,
    kTitleFieldNumber = 2,
    kIconFieldNumber = 3,
    kBranchFieldNumber = 5,
    kIdFieldNumber = 1,
    kBranchIdFieldNumber = 4,
    kCreatedFieldNumber = 8,
    kUpdatedFieldNumber = 9,
    kVisibleFieldNumber = 6,
    kLocalizationFieldNumber = 7,
    kIsNoGoFieldNumber = 12,
  };
  // repeated .AreaContract Areas = 10;
  int areas_size() const;
  private:
  int _internal_areas_size() const;
  public:
  void clear_areas();
  ::AreaContract* mutable_areas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >*
      mutable_areas();
  private:
  const ::AreaContract& _internal_areas(int index) const;
  ::AreaContract* _internal_add_areas();
  public:
  const ::AreaContract& areas(int index) const;
  ::AreaContract* add_areas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >&
      areas() const;

  // repeated .DeviceContract Devices = 11;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::DeviceContract* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >*
      mutable_devices();
  private:
  const ::DeviceContract& _internal_devices(int index) const;
  ::DeviceContract* _internal_add_devices();
  public:
  const ::DeviceContract& devices(int index) const;
  ::DeviceContract* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >&
      devices() const;

  // repeated .PathContract Paths = 13;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::PathContract* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >*
      mutable_paths();
  private:
  const ::PathContract& _internal_paths(int index) const;
  ::PathContract* _internal_add_paths();
  public:
  const ::PathContract& paths(int index) const;
  ::PathContract* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >&
      paths() const;

  // repeated .LayerContract Children = 14;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::LayerContract* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >*
      mutable_children();
  private:
  const ::LayerContract& _internal_children(int index) const;
  ::LayerContract* _internal_add_children();
  public:
  const ::LayerContract& children(int index) const;
  ::LayerContract* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >&
      children() const;

  // string Title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Icon = 3;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // optional .BranchContract Branch = 5;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 BranchId = 4;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // int64 Created = 8;
  void clear_created();
  int64_t created() const;
  void set_created(int64_t value);
  private:
  int64_t _internal_created() const;
  void _internal_set_created(int64_t value);
  public:

  // int64 Updated = 9;
  void clear_updated();
  int64_t updated() const;
  void set_updated(int64_t value);
  private:
  int64_t _internal_updated() const;
  void _internal_set_updated(int64_t value);
  public:

  // bool Visible = 6;
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // bool Localization = 7;
  void clear_localization();
  bool localization() const;
  void set_localization(bool value);
  private:
  bool _internal_localization() const;
  void _internal_set_localization(bool value);
  public:

  // bool IsNoGo = 12;
  void clear_isnogo();
  bool isnogo() const;
  void set_isnogo(bool value);
  private:
  bool _internal_isnogo() const;
  void _internal_set_isnogo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LayerContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract > areas_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract > devices_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract > paths_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract > children_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
    ::BranchContract* branch_;
    int32_t id_;
    int32_t branchid_;
    int64_t created_;
    int64_t updated_;
    bool visible_;
    bool localization_;
    bool isnogo_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class PathContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PathContract) */ {
 public:
  inline PathContract() : PathContract(nullptr) {}
  ~PathContract() override;
  explicit PROTOBUF_CONSTEXPR PathContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathContract(const PathContract& from);
  PathContract(PathContract&& from) noexcept
    : PathContract() {
    *this = ::std::move(from);
  }

  inline PathContract& operator=(const PathContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathContract& operator=(PathContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathContract* internal_default_instance() {
    return reinterpret_cast<const PathContract*>(
               &_PathContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PathContract& a, PathContract& b) {
    a.Swap(&b);
  }
  inline void Swap(PathContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathContract& from) {
    PathContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PathContract";
  }
  protected:
  explicit PathContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathPointsFieldNumber = 11,
    kTitleFieldNumber = 3,
    kColorFieldNumber = 10,
    kDescriptionFieldNumber = 12,
    kGuidFieldNumber = 2,
    kSectorFieldNumber = 5,
    kBranchFieldNumber = 7,
    kLayerFieldNumber = 9,
    kIdFieldNumber = 1,
    kSectorIdFieldNumber = 4,
    kBranchIdFieldNumber = 6,
    kLayerIdFieldNumber = 8,
    kCreatedFieldNumber = 13,
    kUpdatedFieldNumber = 14,
  };
  // repeated .PathPointContract PathPoints = 11;
  int pathpoints_size() const;
  private:
  int _internal_pathpoints_size() const;
  public:
  void clear_pathpoints();
  ::PathPointContract* mutable_pathpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathPointContract >*
      mutable_pathpoints();
  private:
  const ::PathPointContract& _internal_pathpoints(int index) const;
  ::PathPointContract* _internal_add_pathpoints();
  public:
  const ::PathPointContract& pathpoints(int index) const;
  ::PathPointContract* add_pathpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathPointContract >&
      pathpoints() const;

  // string Title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Color = 10;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // string Description = 12;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .Guid Guid = 2;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const ::Guid& guid() const;
  PROTOBUF_NODISCARD ::Guid* release_guid();
  ::Guid* mutable_guid();
  void set_allocated_guid(::Guid* guid);
  private:
  const ::Guid& _internal_guid() const;
  ::Guid* _internal_mutable_guid();
  public:
  void unsafe_arena_set_allocated_guid(
      ::Guid* guid);
  ::Guid* unsafe_arena_release_guid();

  // optional .SectorContract Sector = 5;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // optional .BranchContract Branch = 7;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // optional .LayerContract Layer = 9;
  bool has_layer() const;
  private:
  bool _internal_has_layer() const;
  public:
  void clear_layer();
  const ::LayerContract& layer() const;
  PROTOBUF_NODISCARD ::LayerContract* release_layer();
  ::LayerContract* mutable_layer();
  void set_allocated_layer(::LayerContract* layer);
  private:
  const ::LayerContract& _internal_layer() const;
  ::LayerContract* _internal_mutable_layer();
  public:
  void unsafe_arena_set_allocated_layer(
      ::LayerContract* layer);
  ::LayerContract* unsafe_arena_release_layer();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 SectorId = 4;
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // int32 BranchId = 6;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // optional int32 LayerId = 8;
  bool has_layerid() const;
  private:
  bool _internal_has_layerid() const;
  public:
  void clear_layerid();
  int32_t layerid() const;
  void set_layerid(int32_t value);
  private:
  int32_t _internal_layerid() const;
  void _internal_set_layerid(int32_t value);
  public:

  // int64 Created = 13;
  void clear_created();
  int64_t created() const;
  void set_created(int64_t value);
  private:
  int64_t _internal_created() const;
  void _internal_set_created(int64_t value);
  public:

  // int64 Updated = 14;
  void clear_updated();
  int64_t updated() const;
  void set_updated(int64_t value);
  private:
  int64_t _internal_updated() const;
  void _internal_set_updated(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PathContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathPointContract > pathpoints_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::Guid* guid_;
    ::SectorContract* sector_;
    ::BranchContract* branch_;
    ::LayerContract* layer_;
    int32_t id_;
    int32_t sectorid_;
    int32_t branchid_;
    int32_t layerid_;
    int64_t created_;
    int64_t updated_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class PathPointContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PathPointContract) */ {
 public:
  inline PathPointContract() : PathPointContract(nullptr) {}
  ~PathPointContract() override;
  explicit PROTOBUF_CONSTEXPR PathPointContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathPointContract(const PathPointContract& from);
  PathPointContract(PathPointContract&& from) noexcept
    : PathPointContract() {
    *this = ::std::move(from);
  }

  inline PathPointContract& operator=(const PathPointContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathPointContract& operator=(PathPointContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathPointContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathPointContract* internal_default_instance() {
    return reinterpret_cast<const PathPointContract*>(
               &_PathPointContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PathPointContract& a, PathPointContract& b) {
    a.Swap(&b);
  }
  inline void Swap(PathPointContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathPointContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathPointContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathPointContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathPointContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathPointContract& from) {
    PathPointContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathPointContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PathPointContract";
  }
  protected:
  explicit PathPointContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kBranchFieldNumber = 5,
    kAreaFieldNumber = 10,
    kIdFieldNumber = 1,
    kPathIdFieldNumber = 2,
    kBranchIdFieldNumber = 4,
    kIndexFieldNumber = 6,
    kXFieldNumber = 7,
    kYFieldNumber = 8,
    kAreaIdFieldNumber = 9,
  };
  // optional .PathContract Path = 3;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::PathContract& path() const;
  PROTOBUF_NODISCARD ::PathContract* release_path();
  ::PathContract* mutable_path();
  void set_allocated_path(::PathContract* path);
  private:
  const ::PathContract& _internal_path() const;
  ::PathContract* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::PathContract* path);
  ::PathContract* unsafe_arena_release_path();

  // optional .BranchContract Branch = 5;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // optional .AreaContract Area = 10;
  bool has_area() const;
  private:
  bool _internal_has_area() const;
  public:
  void clear_area();
  const ::AreaContract& area() const;
  PROTOBUF_NODISCARD ::AreaContract* release_area();
  ::AreaContract* mutable_area();
  void set_allocated_area(::AreaContract* area);
  private:
  const ::AreaContract& _internal_area() const;
  ::AreaContract* _internal_mutable_area();
  public:
  void unsafe_arena_set_allocated_area(
      ::AreaContract* area);
  ::AreaContract* unsafe_arena_release_area();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 PathId = 2;
  void clear_pathid();
  int32_t pathid() const;
  void set_pathid(int32_t value);
  private:
  int32_t _internal_pathid() const;
  void _internal_set_pathid(int32_t value);
  public:

  // int32 BranchId = 4;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // int32 Index = 6;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // float X = 7;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 8;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional int32 AreaId = 9;
  bool has_areaid() const;
  private:
  bool _internal_has_areaid() const;
  public:
  void clear_areaid();
  int32_t areaid() const;
  void set_areaid(int32_t value);
  private:
  int32_t _internal_areaid() const;
  void _internal_set_areaid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PathPointContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PathContract* path_;
    ::BranchContract* branch_;
    ::AreaContract* area_;
    int32_t id_;
    int32_t pathid_;
    int32_t branchid_;
    int32_t index_;
    float x_;
    float y_;
    int32_t areaid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class AreaContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AreaContract) */ {
 public:
  inline AreaContract() : AreaContract(nullptr) {}
  ~AreaContract() override;
  explicit PROTOBUF_CONSTEXPR AreaContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AreaContract(const AreaContract& from);
  AreaContract(AreaContract&& from) noexcept
    : AreaContract() {
    *this = ::std::move(from);
  }

  inline AreaContract& operator=(const AreaContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaContract& operator=(AreaContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaContract* internal_default_instance() {
    return reinterpret_cast<const AreaContract*>(
               &_AreaContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AreaContract& a, AreaContract& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AreaContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AreaContract& from) {
    AreaContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AreaContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AreaContract";
  }
  protected:
  explicit AreaContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoordinatesFieldNumber = 11,
    kTitleFieldNumber = 3,
    kColorFieldNumber = 10,
    kDescriptionFieldNumber = 12,
    kGuidFieldNumber = 2,
    kSectorFieldNumber = 5,
    kBranchFieldNumber = 7,
    kLayerFieldNumber = 9,
    kIdFieldNumber = 1,
    kSectorIdFieldNumber = 4,
    kBranchIdFieldNumber = 6,
    kLayerIdFieldNumber = 8,
    kCreatedFieldNumber = 13,
    kUpdatedFieldNumber = 14,
    kTargetBranchIdFieldNumber = 15,
  };
  // repeated .PointContract Coordinates = 11;
  int coordinates_size() const;
  private:
  int _internal_coordinates_size() const;
  public:
  void clear_coordinates();
  ::PointContract* mutable_coordinates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PointContract >*
      mutable_coordinates();
  private:
  const ::PointContract& _internal_coordinates(int index) const;
  ::PointContract* _internal_add_coordinates();
  public:
  const ::PointContract& coordinates(int index) const;
  ::PointContract* add_coordinates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PointContract >&
      coordinates() const;

  // string Title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Color = 10;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // string Description = 12;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .Guid Guid = 2;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const ::Guid& guid() const;
  PROTOBUF_NODISCARD ::Guid* release_guid();
  ::Guid* mutable_guid();
  void set_allocated_guid(::Guid* guid);
  private:
  const ::Guid& _internal_guid() const;
  ::Guid* _internal_mutable_guid();
  public:
  void unsafe_arena_set_allocated_guid(
      ::Guid* guid);
  ::Guid* unsafe_arena_release_guid();

  // optional .SectorContract Sector = 5;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // optional .BranchContract Branch = 7;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // optional .LayerContract Layer = 9;
  bool has_layer() const;
  private:
  bool _internal_has_layer() const;
  public:
  void clear_layer();
  const ::LayerContract& layer() const;
  PROTOBUF_NODISCARD ::LayerContract* release_layer();
  ::LayerContract* mutable_layer();
  void set_allocated_layer(::LayerContract* layer);
  private:
  const ::LayerContract& _internal_layer() const;
  ::LayerContract* _internal_mutable_layer();
  public:
  void unsafe_arena_set_allocated_layer(
      ::LayerContract* layer);
  ::LayerContract* unsafe_arena_release_layer();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 SectorId = 4;
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // int32 BranchId = 6;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // optional int32 LayerId = 8;
  bool has_layerid() const;
  private:
  bool _internal_has_layerid() const;
  public:
  void clear_layerid();
  int32_t layerid() const;
  void set_layerid(int32_t value);
  private:
  int32_t _internal_layerid() const;
  void _internal_set_layerid(int32_t value);
  public:

  // int64 Created = 13;
  void clear_created();
  int64_t created() const;
  void set_created(int64_t value);
  private:
  int64_t _internal_created() const;
  void _internal_set_created(int64_t value);
  public:

  // int64 Updated = 14;
  void clear_updated();
  int64_t updated() const;
  void set_updated(int64_t value);
  private:
  int64_t _internal_updated() const;
  void _internal_set_updated(int64_t value);
  public:

  // optional int32 TargetBranchId = 15;
  bool has_targetbranchid() const;
  private:
  bool _internal_has_targetbranchid() const;
  public:
  void clear_targetbranchid();
  int32_t targetbranchid() const;
  void set_targetbranchid(int32_t value);
  private:
  int32_t _internal_targetbranchid() const;
  void _internal_set_targetbranchid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AreaContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PointContract > coordinates_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::Guid* guid_;
    ::SectorContract* sector_;
    ::BranchContract* branch_;
    ::LayerContract* layer_;
    int32_t id_;
    int32_t sectorid_;
    int32_t branchid_;
    int32_t layerid_;
    int64_t created_;
    int64_t updated_;
    int32_t targetbranchid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class PointContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PointContract) */ {
 public:
  inline PointContract() : PointContract(nullptr) {}
  ~PointContract() override;
  explicit PROTOBUF_CONSTEXPR PointContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PointContract(const PointContract& from);
  PointContract(PointContract&& from) noexcept
    : PointContract() {
    *this = ::std::move(from);
  }

  inline PointContract& operator=(const PointContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointContract& operator=(PointContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PointContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const PointContract* internal_default_instance() {
    return reinterpret_cast<const PointContract*>(
               &_PointContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PointContract& a, PointContract& b) {
    a.Swap(&b);
  }
  inline void Swap(PointContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PointContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PointContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PointContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PointContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PointContract& from) {
    PointContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PointContract";
  }
  protected:
  explicit PointContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float X = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:PointContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class DeviceLocationContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeviceLocationContract) */ {
 public:
  inline DeviceLocationContract() : DeviceLocationContract(nullptr) {}
  ~DeviceLocationContract() override;
  explicit PROTOBUF_CONSTEXPR DeviceLocationContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceLocationContract(const DeviceLocationContract& from);
  DeviceLocationContract(DeviceLocationContract&& from) noexcept
    : DeviceLocationContract() {
    *this = ::std::move(from);
  }

  inline DeviceLocationContract& operator=(const DeviceLocationContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceLocationContract& operator=(DeviceLocationContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceLocationContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceLocationContract* internal_default_instance() {
    return reinterpret_cast<const DeviceLocationContract*>(
               &_DeviceLocationContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeviceLocationContract& a, DeviceLocationContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceLocationContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceLocationContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceLocationContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceLocationContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceLocationContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceLocationContract& from) {
    DeviceLocationContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceLocationContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeviceLocationContract";
  }
  protected:
  explicit DeviceLocationContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 2,
    kLoginFieldNumber = 1,
  };
  // repeated .LocationContract Locations = 2;
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::LocationContract* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >*
      mutable_locations();
  private:
  const ::LocationContract& _internal_locations(int index) const;
  ::LocationContract* _internal_add_locations();
  public:
  const ::LocationContract& locations(int index) const;
  ::LocationContract* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >&
      locations() const;

  // string Login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // @@protoc_insertion_point(class_scope:DeviceLocationContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract > locations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class LocationContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LocationContract) */ {
 public:
  inline LocationContract() : LocationContract(nullptr) {}
  ~LocationContract() override;
  explicit PROTOBUF_CONSTEXPR LocationContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationContract(const LocationContract& from);
  LocationContract(LocationContract&& from) noexcept
    : LocationContract() {
    *this = ::std::move(from);
  }

  inline LocationContract& operator=(const LocationContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationContract& operator=(LocationContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocationContract* internal_default_instance() {
    return reinterpret_cast<const LocationContract*>(
               &_LocationContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LocationContract& a, LocationContract& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationContract& from) {
    LocationContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LocationContract";
  }
  protected:
  explicit LocationContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistancesFieldNumber = 9,
    kLocalizationAreasFieldNumber = 10,
    kNoGoAreasFieldNumber = 11,
    kTimestampFieldNumber = 1,
    kSectorIdFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kZFieldNumber = 5,
    kIntervalFieldNumber = 6,
    kBatteryFieldNumber = 7,
    kIsMovingFieldNumber = 8,
  };
  // repeated .DistanceContract Distances = 9;
  int distances_size() const;
  private:
  int _internal_distances_size() const;
  public:
  void clear_distances();
  ::DistanceContract* mutable_distances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >*
      mutable_distances();
  private:
  const ::DistanceContract& _internal_distances(int index) const;
  ::DistanceContract* _internal_add_distances();
  public:
  const ::DistanceContract& distances(int index) const;
  ::DistanceContract* add_distances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >&
      distances() const;

  // repeated int32 LocalizationAreas = 10;
  int localizationareas_size() const;
  private:
  int _internal_localizationareas_size() const;
  public:
  void clear_localizationareas();
  private:
  int32_t _internal_localizationareas(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_localizationareas() const;
  void _internal_add_localizationareas(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_localizationareas();
  public:
  int32_t localizationareas(int index) const;
  void set_localizationareas(int index, int32_t value);
  void add_localizationareas(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      localizationareas() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_localizationareas();

  // repeated int32 NoGoAreas = 11;
  int nogoareas_size() const;
  private:
  int _internal_nogoareas_size() const;
  public:
  void clear_nogoareas();
  private:
  int32_t _internal_nogoareas(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_nogoareas() const;
  void _internal_add_nogoareas(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_nogoareas();
  public:
  int32_t nogoareas(int index) const;
  void set_nogoareas(int index, int32_t value);
  void add_nogoareas(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      nogoareas() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_nogoareas();

  // int64 Timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional int32 SectorId = 2;
  bool has_sectorid() const;
  private:
  bool _internal_has_sectorid() const;
  public:
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // optional float X = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float Y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float Z = 5;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // optional int32 Interval = 6;
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  int32_t interval() const;
  void set_interval(int32_t value);
  private:
  int32_t _internal_interval() const;
  void _internal_set_interval(int32_t value);
  public:

  // optional uint32 battery = 7;
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  uint32_t battery() const;
  void set_battery(uint32_t value);
  private:
  uint32_t _internal_battery() const;
  void _internal_set_battery(uint32_t value);
  public:

  // bool IsMoving = 8;
  void clear_ismoving();
  bool ismoving() const;
  void set_ismoving(bool value);
  private:
  bool _internal_ismoving() const;
  void _internal_set_ismoving(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LocationContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract > distances_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > localizationareas_;
    mutable std::atomic<int> _localizationareas_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > nogoareas_;
    mutable std::atomic<int> _nogoareas_cached_byte_size_;
    int64_t timestamp_;
    int32_t sectorid_;
    float x_;
    float y_;
    float z_;
    int32_t interval_;
    uint32_t battery_;
    bool ismoving_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class DistanceContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DistanceContract) */ {
 public:
  inline DistanceContract() : DistanceContract(nullptr) {}
  ~DistanceContract() override;
  explicit PROTOBUF_CONSTEXPR DistanceContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistanceContract(const DistanceContract& from);
  DistanceContract(DistanceContract&& from) noexcept
    : DistanceContract() {
    *this = ::std::move(from);
  }

  inline DistanceContract& operator=(const DistanceContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistanceContract& operator=(DistanceContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DistanceContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistanceContract* internal_default_instance() {
    return reinterpret_cast<const DistanceContract*>(
               &_DistanceContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DistanceContract& a, DistanceContract& b) {
    a.Swap(&b);
  }
  inline void Swap(DistanceContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistanceContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistanceContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DistanceContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DistanceContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DistanceContract& from) {
    DistanceContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistanceContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DistanceContract";
  }
  protected:
  explicit DistanceContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeaconIdFieldNumber = 1,
    kDistanceFieldNumber = 2,
    kRSSIFieldNumber = 3,
  };
  // int32 BeaconId = 1;
  void clear_beaconid();
  int32_t beaconid() const;
  void set_beaconid(int32_t value);
  private:
  int32_t _internal_beaconid() const;
  void _internal_set_beaconid(int32_t value);
  public:

  // float Distance = 2;
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // int32 RSSI = 3;
  void clear_rssi();
  int32_t rssi() const;
  void set_rssi(int32_t value);
  private:
  int32_t _internal_rssi() const;
  void _internal_set_rssi(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DistanceContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t beaconid_;
    float distance_;
    int32_t rssi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class LoginContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginContract) */ {
 public:
  inline LoginContract() : LoginContract(nullptr) {}
  ~LoginContract() override;
  explicit PROTOBUF_CONSTEXPR LoginContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginContract(const LoginContract& from);
  LoginContract(LoginContract&& from) noexcept
    : LoginContract() {
    *this = ::std::move(from);
  }

  inline LoginContract& operator=(const LoginContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginContract& operator=(LoginContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginContract* internal_default_instance() {
    return reinterpret_cast<const LoginContract*>(
               &_LoginContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LoginContract& a, LoginContract& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginContract& from) {
    LoginContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginContract";
  }
  protected:
  explicit LoginContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 1,
  };
  // string Login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // @@protoc_insertion_point(class_scope:LoginContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class AuthenticationResponseContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AuthenticationResponseContract) */ {
 public:
  inline AuthenticationResponseContract() : AuthenticationResponseContract(nullptr) {}
  ~AuthenticationResponseContract() override;
  explicit PROTOBUF_CONSTEXPR AuthenticationResponseContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthenticationResponseContract(const AuthenticationResponseContract& from);
  AuthenticationResponseContract(AuthenticationResponseContract&& from) noexcept
    : AuthenticationResponseContract() {
    *this = ::std::move(from);
  }

  inline AuthenticationResponseContract& operator=(const AuthenticationResponseContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthenticationResponseContract& operator=(AuthenticationResponseContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthenticationResponseContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthenticationResponseContract* internal_default_instance() {
    return reinterpret_cast<const AuthenticationResponseContract*>(
               &_AuthenticationResponseContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AuthenticationResponseContract& a, AuthenticationResponseContract& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthenticationResponseContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthenticationResponseContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthenticationResponseContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthenticationResponseContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthenticationResponseContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthenticationResponseContract& from) {
    AuthenticationResponseContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthenticationResponseContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AuthenticationResponseContract";
  }
  protected:
  explicit AuthenticationResponseContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientFieldNumber = 1,
    kTokenFieldNumber = 2,
    kBranchFieldNumber = 5,
    kExpirationFieldNumber = 3,
    kCreatedFieldNumber = 4,
  };
  // string Client = 1;
  void clear_client();
  const std::string& client() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client();
  PROTOBUF_NODISCARD std::string* release_client();
  void set_allocated_client(std::string* client);
  private:
  const std::string& _internal_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client(const std::string& value);
  std::string* _internal_mutable_client();
  public:

  // string Token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string Branch = 5;
  void clear_branch();
  const std::string& branch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_branch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_branch();
  PROTOBUF_NODISCARD std::string* release_branch();
  void set_allocated_branch(std::string* branch);
  private:
  const std::string& _internal_branch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_branch(const std::string& value);
  std::string* _internal_mutable_branch();
  public:

  // uint64 Expiration = 3;
  void clear_expiration();
  uint64_t expiration() const;
  void set_expiration(uint64_t value);
  private:
  uint64_t _internal_expiration() const;
  void _internal_set_expiration(uint64_t value);
  public:

  // uint64 Created = 4;
  void clear_created();
  uint64_t created() const;
  void set_created(uint64_t value);
  private:
  uint64_t _internal_created() const;
  void _internal_set_created(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:AuthenticationResponseContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr branch_;
    uint64_t expiration_;
    uint64_t created_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class CredentialContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CredentialContract) */ {
 public:
  inline CredentialContract() : CredentialContract(nullptr) {}
  ~CredentialContract() override;
  explicit PROTOBUF_CONSTEXPR CredentialContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CredentialContract(const CredentialContract& from);
  CredentialContract(CredentialContract&& from) noexcept
    : CredentialContract() {
    *this = ::std::move(from);
  }

  inline CredentialContract& operator=(const CredentialContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline CredentialContract& operator=(CredentialContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CredentialContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const CredentialContract* internal_default_instance() {
    return reinterpret_cast<const CredentialContract*>(
               &_CredentialContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CredentialContract& a, CredentialContract& b) {
    a.Swap(&b);
  }
  inline void Swap(CredentialContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CredentialContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CredentialContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CredentialContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CredentialContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CredentialContract& from) {
    CredentialContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CredentialContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CredentialContract";
  }
  protected:
  explicit CredentialContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientFieldNumber = 1,
    kLoginFieldNumber = 2,
    kPasswordFieldNumber = 3,
  };
  // string Client = 1;
  void clear_client();
  const std::string& client() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client();
  PROTOBUF_NODISCARD std::string* release_client();
  void set_allocated_client(std::string* client);
  private:
  const std::string& _internal_client() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client(const std::string& value);
  std::string* _internal_mutable_client();
  public:

  // string Login = 2;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string Password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:CredentialContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class PostResponseContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PostResponseContract) */ {
 public:
  inline PostResponseContract() : PostResponseContract(nullptr) {}
  ~PostResponseContract() override;
  explicit PROTOBUF_CONSTEXPR PostResponseContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostResponseContract(const PostResponseContract& from);
  PostResponseContract(PostResponseContract&& from) noexcept
    : PostResponseContract() {
    *this = ::std::move(from);
  }

  inline PostResponseContract& operator=(const PostResponseContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostResponseContract& operator=(PostResponseContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostResponseContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostResponseContract* internal_default_instance() {
    return reinterpret_cast<const PostResponseContract*>(
               &_PostResponseContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PostResponseContract& a, PostResponseContract& b) {
    a.Swap(&b);
  }
  inline void Swap(PostResponseContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostResponseContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostResponseContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostResponseContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostResponseContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostResponseContract& from) {
    PostResponseContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostResponseContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PostResponseContract";
  }
  protected:
  explicit PostResponseContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string ErrorMessage = 2;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // bool Success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PostResponseContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class GpsItemContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GpsItemContract) */ {
 public:
  inline GpsItemContract() : GpsItemContract(nullptr) {}
  ~GpsItemContract() override;
  explicit PROTOBUF_CONSTEXPR GpsItemContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GpsItemContract(const GpsItemContract& from);
  GpsItemContract(GpsItemContract&& from) noexcept
    : GpsItemContract() {
    *this = ::std::move(from);
  }

  inline GpsItemContract& operator=(const GpsItemContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline GpsItemContract& operator=(GpsItemContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GpsItemContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const GpsItemContract* internal_default_instance() {
    return reinterpret_cast<const GpsItemContract*>(
               &_GpsItemContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GpsItemContract& a, GpsItemContract& b) {
    a.Swap(&b);
  }
  inline void Swap(GpsItemContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GpsItemContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GpsItemContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GpsItemContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GpsItemContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GpsItemContract& from) {
    GpsItemContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GpsItemContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GpsItemContract";
  }
  protected:
  explicit GpsItemContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectorFieldNumber = 3,
    kIdFieldNumber = 1,
    kSectorIdFieldNumber = 2,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kLatitudeFieldNumber = 6,
    kLongitudeFieldNumber = 7,
  };
  // optional .SectorContract Sector = 3;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 SectorId = 2;
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // float X = 4;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float Y = 5;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // double Latitude = 6;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double Longitude = 7;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // @@protoc_insertion_point(class_scope:GpsItemContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SectorContract* sector_;
    int32_t id_;
    int32_t sectorid_;
    float x_;
    float y_;
    double latitude_;
    double longitude_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class BarrierContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BarrierContract) */ {
 public:
  inline BarrierContract() : BarrierContract(nullptr) {}
  ~BarrierContract() override;
  explicit PROTOBUF_CONSTEXPR BarrierContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BarrierContract(const BarrierContract& from);
  BarrierContract(BarrierContract&& from) noexcept
    : BarrierContract() {
    *this = ::std::move(from);
  }

  inline BarrierContract& operator=(const BarrierContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline BarrierContract& operator=(BarrierContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BarrierContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const BarrierContract* internal_default_instance() {
    return reinterpret_cast<const BarrierContract*>(
               &_BarrierContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BarrierContract& a, BarrierContract& b) {
    a.Swap(&b);
  }
  inline void Swap(BarrierContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BarrierContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BarrierContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BarrierContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BarrierContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BarrierContract& from) {
    BarrierContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarrierContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BarrierContract";
  }
  protected:
  explicit BarrierContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSectorFieldNumber = 4,
    kBranchFieldNumber = 6,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kSectorIdFieldNumber = 3,
    kBranchIdFieldNumber = 5,
  };
  // optional .SectorContract Sector = 4;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // optional .BranchContract Branch = 6;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // int32 X = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 Y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // int32 SectorId = 3;
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // int32 BranchId = 5;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:BarrierContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::SectorContract* sector_;
    ::BranchContract* branch_;
    int32_t x_;
    int32_t y_;
    int32_t sectorid_;
    int32_t branchid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class BeaconContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BeaconContract) */ {
 public:
  inline BeaconContract() : BeaconContract(nullptr) {}
  ~BeaconContract() override;
  explicit PROTOBUF_CONSTEXPR BeaconContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeaconContract(const BeaconContract& from);
  BeaconContract(BeaconContract&& from) noexcept
    : BeaconContract() {
    *this = ::std::move(from);
  }

  inline BeaconContract& operator=(const BeaconContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeaconContract& operator=(BeaconContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeaconContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeaconContract* internal_default_instance() {
    return reinterpret_cast<const BeaconContract*>(
               &_BeaconContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BeaconContract& a, BeaconContract& b) {
    a.Swap(&b);
  }
  inline void Swap(BeaconContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeaconContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeaconContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeaconContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeaconContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeaconContract& from) {
    BeaconContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeaconContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BeaconContract";
  }
  protected:
  explicit BeaconContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacFieldNumber = 6,
    kTitleFieldNumber = 10,
    kClusterFieldNumber = 17,
    kSectorFieldNumber = 3,
    kBranchFieldNumber = 5,
    kIdFieldNumber = 1,
    kSectorIdFieldNumber = 2,
    kBranchIdFieldNumber = 4,
    kXFieldNumber = 7,
    kYFieldNumber = 8,
    kZFieldNumber = 9,
    kTypeIdFieldNumber = 12,
    kActiveFieldNumber = 11,
    kPositionFieldNumber = 14,
    kGeofenceFieldNumber = 15,
    kUseGpsFieldNumber = 19,
    kLastTimeOnlineFieldNumber = 18,
    kGeofenceRangeFieldNumber = 16,
  };
  // string Mac = 6;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string Title = 10;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Cluster = 17;
  void clear_cluster();
  const std::string& cluster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cluster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cluster();
  PROTOBUF_NODISCARD std::string* release_cluster();
  void set_allocated_cluster(std::string* cluster);
  private:
  const std::string& _internal_cluster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cluster(const std::string& value);
  std::string* _internal_mutable_cluster();
  public:

  // optional .SectorContract Sector = 3;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // optional .BranchContract Branch = 5;
  bool has_branch() const;
  private:
  bool _internal_has_branch() const;
  public:
  void clear_branch();
  const ::BranchContract& branch() const;
  PROTOBUF_NODISCARD ::BranchContract* release_branch();
  ::BranchContract* mutable_branch();
  void set_allocated_branch(::BranchContract* branch);
  private:
  const ::BranchContract& _internal_branch() const;
  ::BranchContract* _internal_mutable_branch();
  public:
  void unsafe_arena_set_allocated_branch(
      ::BranchContract* branch);
  ::BranchContract* unsafe_arena_release_branch();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional int32 SectorId = 2;
  bool has_sectorid() const;
  private:
  bool _internal_has_sectorid() const;
  public:
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // int32 BranchId = 4;
  void clear_branchid();
  int32_t branchid() const;
  void set_branchid(int32_t value);
  private:
  int32_t _internal_branchid() const;
  void _internal_set_branchid(int32_t value);
  public:

  // optional float X = 7;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float Y = 8;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float Z = 9;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // optional int32 TypeId = 12;
  bool has_typeid_() const;
  private:
  bool _internal_has_typeid_() const;
  public:
  void clear_typeid_();
  int32_t typeid_() const;
  void set_typeid_(int32_t value);
  private:
  int32_t _internal_typeid_() const;
  void _internal_set_typeid_(int32_t value);
  public:

  // bool Active = 11;
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // bool Position = 14;
  void clear_position();
  bool position() const;
  void set_position(bool value);
  private:
  bool _internal_position() const;
  void _internal_set_position(bool value);
  public:

  // bool Geofence = 15;
  void clear_geofence();
  bool geofence() const;
  void set_geofence(bool value);
  private:
  bool _internal_geofence() const;
  void _internal_set_geofence(bool value);
  public:

  // bool UseGps = 19;
  void clear_usegps();
  bool usegps() const;
  void set_usegps(bool value);
  private:
  bool _internal_usegps() const;
  void _internal_set_usegps(bool value);
  public:

  // optional int64 LastTimeOnline = 18;
  bool has_lasttimeonline() const;
  private:
  bool _internal_has_lasttimeonline() const;
  public:
  void clear_lasttimeonline();
  int64_t lasttimeonline() const;
  void set_lasttimeonline(int64_t value);
  private:
  int64_t _internal_lasttimeonline() const;
  void _internal_set_lasttimeonline(int64_t value);
  public:

  // optional float GeofenceRange = 16;
  bool has_geofencerange() const;
  private:
  bool _internal_has_geofencerange() const;
  public:
  void clear_geofencerange();
  float geofencerange() const;
  void set_geofencerange(float value);
  private:
  float _internal_geofencerange() const;
  void _internal_set_geofencerange(float value);
  public:

  // @@protoc_insertion_point(class_scope:BeaconContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_;
    ::SectorContract* sector_;
    ::BranchContract* branch_;
    int32_t id_;
    int32_t sectorid_;
    int32_t branchid_;
    float x_;
    float y_;
    float z_;
    int32_t typeid__;
    bool active_;
    bool position_;
    bool geofence_;
    bool usegps_;
    int64_t lasttimeonline_;
    float geofencerange_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class BeaconPositionContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BeaconPositionContract) */ {
 public:
  inline BeaconPositionContract() : BeaconPositionContract(nullptr) {}
  ~BeaconPositionContract() override;
  explicit PROTOBUF_CONSTEXPR BeaconPositionContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BeaconPositionContract(const BeaconPositionContract& from);
  BeaconPositionContract(BeaconPositionContract&& from) noexcept
    : BeaconPositionContract() {
    *this = ::std::move(from);
  }

  inline BeaconPositionContract& operator=(const BeaconPositionContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline BeaconPositionContract& operator=(BeaconPositionContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BeaconPositionContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const BeaconPositionContract* internal_default_instance() {
    return reinterpret_cast<const BeaconPositionContract*>(
               &_BeaconPositionContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BeaconPositionContract& a, BeaconPositionContract& b) {
    a.Swap(&b);
  }
  inline void Swap(BeaconPositionContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BeaconPositionContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BeaconPositionContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BeaconPositionContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BeaconPositionContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BeaconPositionContract& from) {
    BeaconPositionContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BeaconPositionContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BeaconPositionContract";
  }
  protected:
  explicit BeaconPositionContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional float X = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float Y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:BeaconPositionContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t id_;
    float x_;
    float y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SensorContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorContract) */ {
 public:
  inline SensorContract() : SensorContract(nullptr) {}
  ~SensorContract() override;
  explicit PROTOBUF_CONSTEXPR SensorContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorContract(const SensorContract& from);
  SensorContract(SensorContract&& from) noexcept
    : SensorContract() {
    *this = ::std::move(from);
  }

  inline SensorContract& operator=(const SensorContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorContract& operator=(SensorContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorContract* internal_default_instance() {
    return reinterpret_cast<const SensorContract*>(
               &_SensorContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SensorContract& a, SensorContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorContract& from) {
    SensorContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorContract";
  }
  protected:
  explicit SensorContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorDataFieldNumber = 11,
    kLoginFieldNumber = 2,
    kTitleFieldNumber = 3,
    kMacFieldNumber = 4,
    kNoteFieldNumber = 5,
    kPasswordFieldNumber = 14,
    kSectorFieldNumber = 10,
    kAreaFieldNumber = 13,
    kIdFieldNumber = 1,
    kXFieldNumber = 6,
    kYFieldNumber = 7,
    kBatteryFieldNumber = 8,
    kSectorIdFieldNumber = 9,
    kAreaIdFieldNumber = 12,
  };
  // repeated .SensorDataContract SensorData = 11;
  int sensordata_size() const;
  private:
  int _internal_sensordata_size() const;
  public:
  void clear_sensordata();
  ::SensorDataContract* mutable_sensordata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >*
      mutable_sensordata();
  private:
  const ::SensorDataContract& _internal_sensordata(int index) const;
  ::SensorDataContract* _internal_add_sensordata();
  public:
  const ::SensorDataContract& sensordata(int index) const;
  ::SensorDataContract* add_sensordata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >&
      sensordata() const;

  // string Login = 2;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string Title = 3;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Mac = 4;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string Note = 5;
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string Password = 14;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional .SectorContract Sector = 10;
  bool has_sector() const;
  private:
  bool _internal_has_sector() const;
  public:
  void clear_sector();
  const ::SectorContract& sector() const;
  PROTOBUF_NODISCARD ::SectorContract* release_sector();
  ::SectorContract* mutable_sector();
  void set_allocated_sector(::SectorContract* sector);
  private:
  const ::SectorContract& _internal_sector() const;
  ::SectorContract* _internal_mutable_sector();
  public:
  void unsafe_arena_set_allocated_sector(
      ::SectorContract* sector);
  ::SectorContract* unsafe_arena_release_sector();

  // optional .AreaContract Area = 13;
  bool has_area() const;
  private:
  bool _internal_has_area() const;
  public:
  void clear_area();
  const ::AreaContract& area() const;
  PROTOBUF_NODISCARD ::AreaContract* release_area();
  ::AreaContract* mutable_area();
  void set_allocated_area(::AreaContract* area);
  private:
  const ::AreaContract& _internal_area() const;
  ::AreaContract* _internal_mutable_area();
  public:
  void unsafe_arena_set_allocated_area(
      ::AreaContract* area);
  ::AreaContract* unsafe_arena_release_area();

  // int32 Id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional float X = 6;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 7;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // optional float Battery = 8;
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  float battery() const;
  void set_battery(float value);
  private:
  float _internal_battery() const;
  void _internal_set_battery(float value);
  public:

  // optional int32 SectorId = 9;
  bool has_sectorid() const;
  private:
  bool _internal_has_sectorid() const;
  public:
  void clear_sectorid();
  int32_t sectorid() const;
  void set_sectorid(int32_t value);
  private:
  int32_t _internal_sectorid() const;
  void _internal_set_sectorid(int32_t value);
  public:

  // optional int32 AreaId = 12;
  bool has_areaid() const;
  private:
  bool _internal_has_areaid() const;
  public:
  void clear_areaid();
  int32_t areaid() const;
  void set_areaid(int32_t value);
  private:
  int32_t _internal_areaid() const;
  void _internal_set_areaid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SensorContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract > sensordata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::SectorContract* sector_;
    ::AreaContract* area_;
    int32_t id_;
    float x_;
    float y_;
    float battery_;
    int32_t sectorid_;
    int32_t areaid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SensorDataContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorDataContract) */ {
 public:
  inline SensorDataContract() : SensorDataContract(nullptr) {}
  ~SensorDataContract() override;
  explicit PROTOBUF_CONSTEXPR SensorDataContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorDataContract(const SensorDataContract& from);
  SensorDataContract(SensorDataContract&& from) noexcept
    : SensorDataContract() {
    *this = ::std::move(from);
  }

  inline SensorDataContract& operator=(const SensorDataContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDataContract& operator=(SensorDataContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorDataContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorDataContract* internal_default_instance() {
    return reinterpret_cast<const SensorDataContract*>(
               &_SensorDataContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SensorDataContract& a, SensorDataContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorDataContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorDataContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorDataContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorDataContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorDataContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorDataContract& from) {
    SensorDataContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDataContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorDataContract";
  }
  protected:
  explicit SensorDataContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 1,
    kValueFieldNumber = 2,
    kUnitFieldNumber = 3,
    kDataTypeFieldNumber = 4,
    kRangeFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kIndexFieldNumber = 7,
  };
  // string Quantity = 1;
  void clear_quantity();
  const std::string& quantity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quantity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* quantity);
  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(const std::string& value);
  std::string* _internal_mutable_quantity();
  public:

  // string Value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string Unit = 3;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // string DataType = 4;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // .RangeContract Range = 6;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::RangeContract& range() const;
  PROTOBUF_NODISCARD ::RangeContract* release_range();
  ::RangeContract* mutable_range();
  void set_allocated_range(::RangeContract* range);
  private:
  const ::RangeContract& _internal_range() const;
  ::RangeContract* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::RangeContract* range);
  ::RangeContract* unsafe_arena_release_range();

  // int64 Timestamp = 5;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 Index = 7;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SensorDataContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    ::RangeContract* range_;
    int64_t timestamp_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SensorBatchContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorBatchContract) */ {
 public:
  inline SensorBatchContract() : SensorBatchContract(nullptr) {}
  ~SensorBatchContract() override;
  explicit PROTOBUF_CONSTEXPR SensorBatchContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorBatchContract(const SensorBatchContract& from);
  SensorBatchContract(SensorBatchContract&& from) noexcept
    : SensorBatchContract() {
    *this = ::std::move(from);
  }

  inline SensorBatchContract& operator=(const SensorBatchContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorBatchContract& operator=(SensorBatchContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorBatchContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorBatchContract* internal_default_instance() {
    return reinterpret_cast<const SensorBatchContract*>(
               &_SensorBatchContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SensorBatchContract& a, SensorBatchContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorBatchContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorBatchContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorBatchContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorBatchContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorBatchContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorBatchContract& from) {
    SensorBatchContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorBatchContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorBatchContract";
  }
  protected:
  explicit SensorBatchContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorDataFieldNumber = 2,
    kLoginFieldNumber = 1,
  };
  // repeated .SensorDataBatchContract SensorData = 2;
  int sensordata_size() const;
  private:
  int _internal_sensordata_size() const;
  public:
  void clear_sensordata();
  ::SensorDataBatchContract* mutable_sensordata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >*
      mutable_sensordata();
  private:
  const ::SensorDataBatchContract& _internal_sensordata(int index) const;
  ::SensorDataBatchContract* _internal_add_sensordata();
  public:
  const ::SensorDataBatchContract& sensordata(int index) const;
  ::SensorDataBatchContract* add_sensordata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >&
      sensordata() const;

  // string Login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // @@protoc_insertion_point(class_scope:SensorBatchContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract > sensordata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SensorDataBatchContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorDataBatchContract) */ {
 public:
  inline SensorDataBatchContract() : SensorDataBatchContract(nullptr) {}
  ~SensorDataBatchContract() override;
  explicit PROTOBUF_CONSTEXPR SensorDataBatchContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorDataBatchContract(const SensorDataBatchContract& from);
  SensorDataBatchContract(SensorDataBatchContract&& from) noexcept
    : SensorDataBatchContract() {
    *this = ::std::move(from);
  }

  inline SensorDataBatchContract& operator=(const SensorDataBatchContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDataBatchContract& operator=(SensorDataBatchContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorDataBatchContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorDataBatchContract* internal_default_instance() {
    return reinterpret_cast<const SensorDataBatchContract*>(
               &_SensorDataBatchContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SensorDataBatchContract& a, SensorDataBatchContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorDataBatchContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorDataBatchContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorDataBatchContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorDataBatchContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorDataBatchContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorDataBatchContract& from) {
    SensorDataBatchContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDataBatchContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorDataBatchContract";
  }
  protected:
  explicit SensorDataBatchContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuantityFieldNumber = 2,
    kValueFieldNumber = 3,
    kUnitFieldNumber = 4,
    kDataTypeFieldNumber = 5,
    kTimestampFieldNumber = 1,
    kValueOKFieldNumber = 6,
  };
  // string Quantity = 2;
  void clear_quantity();
  const std::string& quantity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quantity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quantity();
  PROTOBUF_NODISCARD std::string* release_quantity();
  void set_allocated_quantity(std::string* quantity);
  private:
  const std::string& _internal_quantity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quantity(const std::string& value);
  std::string* _internal_mutable_quantity();
  public:

  // string Value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string Unit = 4;
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_NODISCARD std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // string DataType = 5;
  void clear_datatype();
  const std::string& datatype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datatype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datatype();
  PROTOBUF_NODISCARD std::string* release_datatype();
  void set_allocated_datatype(std::string* datatype);
  private:
  const std::string& _internal_datatype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datatype(const std::string& value);
  std::string* _internal_mutable_datatype();
  public:

  // int64 Timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // optional bool ValueOK = 6;
  bool has_valueok() const;
  private:
  bool _internal_has_valueok() const;
  public:
  void clear_valueok();
  bool valueok() const;
  void set_valueok(bool value);
  private:
  bool _internal_valueok() const;
  void _internal_set_valueok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:SensorDataBatchContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datatype_;
    int64_t timestamp_;
    bool valueok_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class SensorAppInfoContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SensorAppInfoContract) */ {
 public:
  inline SensorAppInfoContract() : SensorAppInfoContract(nullptr) {}
  ~SensorAppInfoContract() override;
  explicit PROTOBUF_CONSTEXPR SensorAppInfoContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorAppInfoContract(const SensorAppInfoContract& from);
  SensorAppInfoContract(SensorAppInfoContract&& from) noexcept
    : SensorAppInfoContract() {
    *this = ::std::move(from);
  }

  inline SensorAppInfoContract& operator=(const SensorAppInfoContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorAppInfoContract& operator=(SensorAppInfoContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorAppInfoContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorAppInfoContract* internal_default_instance() {
    return reinterpret_cast<const SensorAppInfoContract*>(
               &_SensorAppInfoContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SensorAppInfoContract& a, SensorAppInfoContract& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorAppInfoContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorAppInfoContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorAppInfoContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorAppInfoContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorAppInfoContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorAppInfoContract& from) {
    SensorAppInfoContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorAppInfoContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SensorAppInfoContract";
  }
  protected:
  explicit SensorAppInfoContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string Version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // int64 Size = 2;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SensorAppInfoContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class RangeContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RangeContract) */ {
 public:
  inline RangeContract() : RangeContract(nullptr) {}
  ~RangeContract() override;
  explicit PROTOBUF_CONSTEXPR RangeContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeContract(const RangeContract& from);
  RangeContract(RangeContract&& from) noexcept
    : RangeContract() {
    *this = ::std::move(from);
  }

  inline RangeContract& operator=(const RangeContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeContract& operator=(RangeContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeContract* internal_default_instance() {
    return reinterpret_cast<const RangeContract*>(
               &_RangeContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RangeContract& a, RangeContract& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangeContract& from) {
    RangeContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RangeContract";
  }
  protected:
  explicit RangeContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangesFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated .RangesContract Ranges = 2;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::RangesContract* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RangesContract >*
      mutable_ranges();
  private:
  const ::RangesContract& _internal_ranges(int index) const;
  ::RangesContract* _internal_add_ranges();
  public:
  const ::RangesContract& ranges(int index) const;
  ::RangesContract* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RangesContract >&
      ranges() const;

  // string Type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:RangeContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RangesContract > ranges_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// -------------------------------------------------------------------

class RangesContract final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RangesContract) */ {
 public:
  inline RangesContract() : RangesContract(nullptr) {}
  ~RangesContract() override;
  explicit PROTOBUF_CONSTEXPR RangesContract(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangesContract(const RangesContract& from);
  RangesContract(RangesContract&& from) noexcept
    : RangesContract() {
    *this = ::std::move(from);
  }

  inline RangesContract& operator=(const RangesContract& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangesContract& operator=(RangesContract&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangesContract& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangesContract* internal_default_instance() {
    return reinterpret_cast<const RangesContract*>(
               &_RangesContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RangesContract& a, RangesContract& b) {
    a.Swap(&b);
  }
  inline void Swap(RangesContract* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangesContract* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangesContract* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangesContract>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangesContract& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RangesContract& from) {
    RangesContract::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangesContract* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RangesContract";
  }
  protected:
  explicit RangesContract(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string Color = 1;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // string Value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:RangesContract)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_core_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Guid

// fixed64 lo = 1;
inline void Guid::clear_lo() {
  _impl_.lo_ = uint64_t{0u};
}
inline uint64_t Guid::_internal_lo() const {
  return _impl_.lo_;
}
inline uint64_t Guid::lo() const {
  // @@protoc_insertion_point(field_get:Guid.lo)
  return _internal_lo();
}
inline void Guid::_internal_set_lo(uint64_t value) {
  
  _impl_.lo_ = value;
}
inline void Guid::set_lo(uint64_t value) {
  _internal_set_lo(value);
  // @@protoc_insertion_point(field_set:Guid.lo)
}

// fixed64 hi = 2;
inline void Guid::clear_hi() {
  _impl_.hi_ = uint64_t{0u};
}
inline uint64_t Guid::_internal_hi() const {
  return _impl_.hi_;
}
inline uint64_t Guid::hi() const {
  // @@protoc_insertion_point(field_get:Guid.hi)
  return _internal_hi();
}
inline void Guid::_internal_set_hi(uint64_t value) {
  
  _impl_.hi_ = value;
}
inline void Guid::set_hi(uint64_t value) {
  _internal_set_hi(value);
  // @@protoc_insertion_point(field_set:Guid.hi)
}

// -------------------------------------------------------------------

// DeviceContract

// int32 Id = 1;
inline void DeviceContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t DeviceContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t DeviceContract::id() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Id)
  return _internal_id();
}
inline void DeviceContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void DeviceContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:DeviceContract.Id)
}

// string Mac = 2;
inline void DeviceContract::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& DeviceContract::mac() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.Mac)
}
inline std::string* DeviceContract::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Mac)
  return _s;
}
inline const std::string& DeviceContract::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void DeviceContract::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_mac() {
  // @@protoc_insertion_point(field_release:DeviceContract.Mac)
  return _impl_.mac_.Release();
}
inline void DeviceContract::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Mac)
}

// int32 BranchId = 3;
inline void DeviceContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t DeviceContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t DeviceContract::branchid() const {
  // @@protoc_insertion_point(field_get:DeviceContract.BranchId)
  return _internal_branchid();
}
inline void DeviceContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void DeviceContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:DeviceContract.BranchId)
}

// optional .BranchContract Branch = 4;
inline bool DeviceContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool DeviceContract::has_branch() const {
  return _internal_has_branch();
}
inline void DeviceContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::BranchContract& DeviceContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& DeviceContract::branch() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Branch)
  return _internal_branch();
}
inline void DeviceContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DeviceContract.Branch)
}
inline ::BranchContract* DeviceContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* DeviceContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:DeviceContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* DeviceContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* DeviceContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Branch)
  return _msg;
}
inline void DeviceContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Branch)
}

// optional int32 SectorId = 5;
inline bool DeviceContract::_internal_has_sectorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceContract::has_sectorid() const {
  return _internal_has_sectorid();
}
inline void DeviceContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DeviceContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t DeviceContract::sectorid() const {
  // @@protoc_insertion_point(field_get:DeviceContract.SectorId)
  return _internal_sectorid();
}
inline void DeviceContract::_internal_set_sectorid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sectorid_ = value;
}
inline void DeviceContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:DeviceContract.SectorId)
}

// optional .SectorContract Sector = 6;
inline bool DeviceContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool DeviceContract::has_sector() const {
  return _internal_has_sector();
}
inline void DeviceContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::SectorContract& DeviceContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& DeviceContract::sector() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Sector)
  return _internal_sector();
}
inline void DeviceContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DeviceContract.Sector)
}
inline ::SectorContract* DeviceContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* DeviceContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:DeviceContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* DeviceContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* DeviceContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Sector)
  return _msg;
}
inline void DeviceContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Sector)
}

// optional int32 ValidSectorId = 7;
inline bool DeviceContract::_internal_has_validsectorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceContract::has_validsectorid() const {
  return _internal_has_validsectorid();
}
inline void DeviceContract::clear_validsectorid() {
  _impl_.validsectorid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t DeviceContract::_internal_validsectorid() const {
  return _impl_.validsectorid_;
}
inline int32_t DeviceContract::validsectorid() const {
  // @@protoc_insertion_point(field_get:DeviceContract.ValidSectorId)
  return _internal_validsectorid();
}
inline void DeviceContract::_internal_set_validsectorid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.validsectorid_ = value;
}
inline void DeviceContract::set_validsectorid(int32_t value) {
  _internal_set_validsectorid(value);
  // @@protoc_insertion_point(field_set:DeviceContract.ValidSectorId)
}

// string Title = 8;
inline void DeviceContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& DeviceContract::title() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.Title)
}
inline std::string* DeviceContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Title)
  return _s;
}
inline const std::string& DeviceContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void DeviceContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_title() {
  // @@protoc_insertion_point(field_release:DeviceContract.Title)
  return _impl_.title_.Release();
}
inline void DeviceContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Title)
}

// string Note = 9;
inline void DeviceContract::clear_note() {
  _impl_.note_.ClearToEmpty();
}
inline const std::string& DeviceContract::note() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_note(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.Note)
}
inline std::string* DeviceContract::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Note)
  return _s;
}
inline const std::string& DeviceContract::_internal_note() const {
  return _impl_.note_.Get();
}
inline void DeviceContract::_internal_set_note(const std::string& value) {
  
  _impl_.note_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_note() {
  
  return _impl_.note_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_note() {
  // @@protoc_insertion_point(field_release:DeviceContract.Note)
  return _impl_.note_.Release();
}
inline void DeviceContract::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  _impl_.note_.SetAllocated(note, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Note)
}

// optional int64 LastTimeOnline = 10;
inline bool DeviceContract::_internal_has_lasttimeonline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceContract::has_lasttimeonline() const {
  return _internal_has_lasttimeonline();
}
inline void DeviceContract::clear_lasttimeonline() {
  _impl_.lasttimeonline_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t DeviceContract::_internal_lasttimeonline() const {
  return _impl_.lasttimeonline_;
}
inline int64_t DeviceContract::lasttimeonline() const {
  // @@protoc_insertion_point(field_get:DeviceContract.LastTimeOnline)
  return _internal_lasttimeonline();
}
inline void DeviceContract::_internal_set_lasttimeonline(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.lasttimeonline_ = value;
}
inline void DeviceContract::set_lasttimeonline(int64_t value) {
  _internal_set_lasttimeonline(value);
  // @@protoc_insertion_point(field_set:DeviceContract.LastTimeOnline)
}

// optional int64 ValidLastTimeOnline = 11;
inline bool DeviceContract::_internal_has_validlasttimeonline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeviceContract::has_validlasttimeonline() const {
  return _internal_has_validlasttimeonline();
}
inline void DeviceContract::clear_validlasttimeonline() {
  _impl_.validlasttimeonline_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t DeviceContract::_internal_validlasttimeonline() const {
  return _impl_.validlasttimeonline_;
}
inline int64_t DeviceContract::validlasttimeonline() const {
  // @@protoc_insertion_point(field_get:DeviceContract.ValidLastTimeOnline)
  return _internal_validlasttimeonline();
}
inline void DeviceContract::_internal_set_validlasttimeonline(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.validlasttimeonline_ = value;
}
inline void DeviceContract::set_validlasttimeonline(int64_t value) {
  _internal_set_validlasttimeonline(value);
  // @@protoc_insertion_point(field_set:DeviceContract.ValidLastTimeOnline)
}

// optional float X = 12;
inline bool DeviceContract::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeviceContract::has_x() const {
  return _internal_has_x();
}
inline void DeviceContract::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline float DeviceContract::_internal_x() const {
  return _impl_.x_;
}
inline float DeviceContract::x() const {
  // @@protoc_insertion_point(field_get:DeviceContract.X)
  return _internal_x();
}
inline void DeviceContract::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.x_ = value;
}
inline void DeviceContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:DeviceContract.X)
}

// optional float Y = 13;
inline bool DeviceContract::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DeviceContract::has_y() const {
  return _internal_has_y();
}
inline void DeviceContract::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float DeviceContract::_internal_y() const {
  return _impl_.y_;
}
inline float DeviceContract::y() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Y)
  return _internal_y();
}
inline void DeviceContract::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.y_ = value;
}
inline void DeviceContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:DeviceContract.Y)
}

// optional float ValidX = 14;
inline bool DeviceContract::_internal_has_validx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DeviceContract::has_validx() const {
  return _internal_has_validx();
}
inline void DeviceContract::clear_validx() {
  _impl_.validx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float DeviceContract::_internal_validx() const {
  return _impl_.validx_;
}
inline float DeviceContract::validx() const {
  // @@protoc_insertion_point(field_get:DeviceContract.ValidX)
  return _internal_validx();
}
inline void DeviceContract::_internal_set_validx(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.validx_ = value;
}
inline void DeviceContract::set_validx(float value) {
  _internal_set_validx(value);
  // @@protoc_insertion_point(field_set:DeviceContract.ValidX)
}

// optional float ValidY = 15;
inline bool DeviceContract::_internal_has_validy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DeviceContract::has_validy() const {
  return _internal_has_validy();
}
inline void DeviceContract::clear_validy() {
  _impl_.validy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float DeviceContract::_internal_validy() const {
  return _impl_.validy_;
}
inline float DeviceContract::validy() const {
  // @@protoc_insertion_point(field_get:DeviceContract.ValidY)
  return _internal_validy();
}
inline void DeviceContract::_internal_set_validy(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.validy_ = value;
}
inline void DeviceContract::set_validy(float value) {
  _internal_set_validy(value);
  // @@protoc_insertion_point(field_set:DeviceContract.ValidY)
}

// string AppVersion = 16;
inline void DeviceContract::clear_appversion() {
  _impl_.appversion_.ClearToEmpty();
}
inline const std::string& DeviceContract::appversion() const {
  // @@protoc_insertion_point(field_get:DeviceContract.AppVersion)
  return _internal_appversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_appversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.AppVersion)
}
inline std::string* DeviceContract::mutable_appversion() {
  std::string* _s = _internal_mutable_appversion();
  // @@protoc_insertion_point(field_mutable:DeviceContract.AppVersion)
  return _s;
}
inline const std::string& DeviceContract::_internal_appversion() const {
  return _impl_.appversion_.Get();
}
inline void DeviceContract::_internal_set_appversion(const std::string& value) {
  
  _impl_.appversion_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_appversion() {
  
  return _impl_.appversion_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_appversion() {
  // @@protoc_insertion_point(field_release:DeviceContract.AppVersion)
  return _impl_.appversion_.Release();
}
inline void DeviceContract::set_allocated_appversion(std::string* appversion) {
  if (appversion != nullptr) {
    
  } else {
    
  }
  _impl_.appversion_.SetAllocated(appversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appversion_.IsDefault()) {
    _impl_.appversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.AppVersion)
}

// bool IsMoving = 17;
inline void DeviceContract::clear_ismoving() {
  _impl_.ismoving_ = false;
}
inline bool DeviceContract::_internal_ismoving() const {
  return _impl_.ismoving_;
}
inline bool DeviceContract::ismoving() const {
  // @@protoc_insertion_point(field_get:DeviceContract.IsMoving)
  return _internal_ismoving();
}
inline void DeviceContract::_internal_set_ismoving(bool value) {
  
  _impl_.ismoving_ = value;
}
inline void DeviceContract::set_ismoving(bool value) {
  _internal_set_ismoving(value);
  // @@protoc_insertion_point(field_set:DeviceContract.IsMoving)
}

// string FallStatus = 18;
inline void DeviceContract::clear_fallstatus() {
  _impl_.fallstatus_.ClearToEmpty();
}
inline const std::string& DeviceContract::fallstatus() const {
  // @@protoc_insertion_point(field_get:DeviceContract.FallStatus)
  return _internal_fallstatus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_fallstatus(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fallstatus_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.FallStatus)
}
inline std::string* DeviceContract::mutable_fallstatus() {
  std::string* _s = _internal_mutable_fallstatus();
  // @@protoc_insertion_point(field_mutable:DeviceContract.FallStatus)
  return _s;
}
inline const std::string& DeviceContract::_internal_fallstatus() const {
  return _impl_.fallstatus_.Get();
}
inline void DeviceContract::_internal_set_fallstatus(const std::string& value) {
  
  _impl_.fallstatus_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_fallstatus() {
  
  return _impl_.fallstatus_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_fallstatus() {
  // @@protoc_insertion_point(field_release:DeviceContract.FallStatus)
  return _impl_.fallstatus_.Release();
}
inline void DeviceContract::set_allocated_fallstatus(std::string* fallstatus) {
  if (fallstatus != nullptr) {
    
  } else {
    
  }
  _impl_.fallstatus_.SetAllocated(fallstatus, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fallstatus_.IsDefault()) {
    _impl_.fallstatus_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.FallStatus)
}

// optional float Battery = 19;
inline bool DeviceContract::_internal_has_battery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DeviceContract::has_battery() const {
  return _internal_has_battery();
}
inline void DeviceContract::clear_battery() {
  _impl_.battery_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float DeviceContract::_internal_battery() const {
  return _impl_.battery_;
}
inline float DeviceContract::battery() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Battery)
  return _internal_battery();
}
inline void DeviceContract::_internal_set_battery(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.battery_ = value;
}
inline void DeviceContract::set_battery(float value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:DeviceContract.Battery)
}

// int32 DeviceTypeId = 20;
inline void DeviceContract::clear_devicetypeid() {
  _impl_.devicetypeid_ = 0;
}
inline int32_t DeviceContract::_internal_devicetypeid() const {
  return _impl_.devicetypeid_;
}
inline int32_t DeviceContract::devicetypeid() const {
  // @@protoc_insertion_point(field_get:DeviceContract.DeviceTypeId)
  return _internal_devicetypeid();
}
inline void DeviceContract::_internal_set_devicetypeid(int32_t value) {
  
  _impl_.devicetypeid_ = value;
}
inline void DeviceContract::set_devicetypeid(int32_t value) {
  _internal_set_devicetypeid(value);
  // @@protoc_insertion_point(field_set:DeviceContract.DeviceTypeId)
}

// string DeviceType = 21;
inline void DeviceContract::clear_devicetype() {
  _impl_.devicetype_.ClearToEmpty();
}
inline const std::string& DeviceContract::devicetype() const {
  // @@protoc_insertion_point(field_get:DeviceContract.DeviceType)
  return _internal_devicetype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_devicetype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.devicetype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.DeviceType)
}
inline std::string* DeviceContract::mutable_devicetype() {
  std::string* _s = _internal_mutable_devicetype();
  // @@protoc_insertion_point(field_mutable:DeviceContract.DeviceType)
  return _s;
}
inline const std::string& DeviceContract::_internal_devicetype() const {
  return _impl_.devicetype_.Get();
}
inline void DeviceContract::_internal_set_devicetype(const std::string& value) {
  
  _impl_.devicetype_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_devicetype() {
  
  return _impl_.devicetype_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_devicetype() {
  // @@protoc_insertion_point(field_release:DeviceContract.DeviceType)
  return _impl_.devicetype_.Release();
}
inline void DeviceContract::set_allocated_devicetype(std::string* devicetype) {
  if (devicetype != nullptr) {
    
  } else {
    
  }
  _impl_.devicetype_.SetAllocated(devicetype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicetype_.IsDefault()) {
    _impl_.devicetype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.DeviceType)
}

// string Login = 22;
inline void DeviceContract::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& DeviceContract::login() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.Login)
}
inline std::string* DeviceContract::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Login)
  return _s;
}
inline const std::string& DeviceContract::_internal_login() const {
  return _impl_.login_.Get();
}
inline void DeviceContract::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_login() {
  // @@protoc_insertion_point(field_release:DeviceContract.Login)
  return _impl_.login_.Release();
}
inline void DeviceContract::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Login)
}

// bool Position = 23;
inline void DeviceContract::clear_position() {
  _impl_.position_ = false;
}
inline bool DeviceContract::_internal_position() const {
  return _impl_.position_;
}
inline bool DeviceContract::position() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Position)
  return _internal_position();
}
inline void DeviceContract::_internal_set_position(bool value) {
  
  _impl_.position_ = value;
}
inline void DeviceContract::set_position(bool value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:DeviceContract.Position)
}

// bool Geofence = 24;
inline void DeviceContract::clear_geofence() {
  _impl_.geofence_ = false;
}
inline bool DeviceContract::_internal_geofence() const {
  return _impl_.geofence_;
}
inline bool DeviceContract::geofence() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Geofence)
  return _internal_geofence();
}
inline void DeviceContract::_internal_set_geofence(bool value) {
  
  _impl_.geofence_ = value;
}
inline void DeviceContract::set_geofence(bool value) {
  _internal_set_geofence(value);
  // @@protoc_insertion_point(field_set:DeviceContract.Geofence)
}

// optional uint32 GeofenceRange = 25;
inline bool DeviceContract::_internal_has_geofencerange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DeviceContract::has_geofencerange() const {
  return _internal_has_geofencerange();
}
inline void DeviceContract::clear_geofencerange() {
  _impl_.geofencerange_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline uint32_t DeviceContract::_internal_geofencerange() const {
  return _impl_.geofencerange_;
}
inline uint32_t DeviceContract::geofencerange() const {
  // @@protoc_insertion_point(field_get:DeviceContract.GeofenceRange)
  return _internal_geofencerange();
}
inline void DeviceContract::_internal_set_geofencerange(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.geofencerange_ = value;
}
inline void DeviceContract::set_geofencerange(uint32_t value) {
  _internal_set_geofencerange(value);
  // @@protoc_insertion_point(field_set:DeviceContract.GeofenceRange)
}

// string Password = 26;
inline void DeviceContract::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& DeviceContract::password() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.Password)
}
inline std::string* DeviceContract::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:DeviceContract.Password)
  return _s;
}
inline const std::string& DeviceContract::_internal_password() const {
  return _impl_.password_.Get();
}
inline void DeviceContract::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_password() {
  // @@protoc_insertion_point(field_release:DeviceContract.Password)
  return _impl_.password_.Release();
}
inline void DeviceContract::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.Password)
}

// repeated .LayerContract Layers = 27;
inline int DeviceContract::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int DeviceContract::layers_size() const {
  return _internal_layers_size();
}
inline void DeviceContract::clear_layers() {
  _impl_.layers_.Clear();
}
inline ::LayerContract* DeviceContract::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:DeviceContract.Layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >*
DeviceContract::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:DeviceContract.Layers)
  return &_impl_.layers_;
}
inline const ::LayerContract& DeviceContract::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::LayerContract& DeviceContract::layers(int index) const {
  // @@protoc_insertion_point(field_get:DeviceContract.Layers)
  return _internal_layers(index);
}
inline ::LayerContract* DeviceContract::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::LayerContract* DeviceContract::add_layers() {
  ::LayerContract* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:DeviceContract.Layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >&
DeviceContract::layers() const {
  // @@protoc_insertion_point(field_list:DeviceContract.Layers)
  return _impl_.layers_;
}

// string DeviceStatus = 28;
inline void DeviceContract::clear_devicestatus() {
  _impl_.devicestatus_.ClearToEmpty();
}
inline const std::string& DeviceContract::devicestatus() const {
  // @@protoc_insertion_point(field_get:DeviceContract.DeviceStatus)
  return _internal_devicestatus();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceContract::set_devicestatus(ArgT0&& arg0, ArgT... args) {
 
 _impl_.devicestatus_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceContract.DeviceStatus)
}
inline std::string* DeviceContract::mutable_devicestatus() {
  std::string* _s = _internal_mutable_devicestatus();
  // @@protoc_insertion_point(field_mutable:DeviceContract.DeviceStatus)
  return _s;
}
inline const std::string& DeviceContract::_internal_devicestatus() const {
  return _impl_.devicestatus_.Get();
}
inline void DeviceContract::_internal_set_devicestatus(const std::string& value) {
  
  _impl_.devicestatus_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceContract::_internal_mutable_devicestatus() {
  
  return _impl_.devicestatus_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceContract::release_devicestatus() {
  // @@protoc_insertion_point(field_release:DeviceContract.DeviceStatus)
  return _impl_.devicestatus_.Release();
}
inline void DeviceContract::set_allocated_devicestatus(std::string* devicestatus) {
  if (devicestatus != nullptr) {
    
  } else {
    
  }
  _impl_.devicestatus_.SetAllocated(devicestatus, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicestatus_.IsDefault()) {
    _impl_.devicestatus_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceContract.DeviceStatus)
}

// optional int64 Heartbeat = 29;
inline bool DeviceContract::_internal_has_heartbeat() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DeviceContract::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void DeviceContract::clear_heartbeat() {
  _impl_.heartbeat_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t DeviceContract::_internal_heartbeat() const {
  return _impl_.heartbeat_;
}
inline int64_t DeviceContract::heartbeat() const {
  // @@protoc_insertion_point(field_get:DeviceContract.Heartbeat)
  return _internal_heartbeat();
}
inline void DeviceContract::_internal_set_heartbeat(int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.heartbeat_ = value;
}
inline void DeviceContract::set_heartbeat(int64_t value) {
  _internal_set_heartbeat(value);
  // @@protoc_insertion_point(field_set:DeviceContract.Heartbeat)
}

// -------------------------------------------------------------------

// SectorContract

// int32 Id = 1;
inline void SectorContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t SectorContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SectorContract::id() const {
  // @@protoc_insertion_point(field_get:SectorContract.Id)
  return _internal_id();
}
inline void SectorContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void SectorContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SectorContract.Id)
}

// string Guid = 2;
inline void SectorContract::clear_guid() {
  _impl_.guid_.ClearToEmpty();
}
inline const std::string& SectorContract::guid() const {
  // @@protoc_insertion_point(field_get:SectorContract.Guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectorContract::set_guid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SectorContract.Guid)
}
inline std::string* SectorContract::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:SectorContract.Guid)
  return _s;
}
inline const std::string& SectorContract::_internal_guid() const {
  return _impl_.guid_.Get();
}
inline void SectorContract::_internal_set_guid(const std::string& value) {
  
  _impl_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* SectorContract::_internal_mutable_guid() {
  
  return _impl_.guid_.Mutable(GetArenaForAllocation());
}
inline std::string* SectorContract::release_guid() {
  // @@protoc_insertion_point(field_release:SectorContract.Guid)
  return _impl_.guid_.Release();
}
inline void SectorContract::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    
  } else {
    
  }
  _impl_.guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.guid_.IsDefault()) {
    _impl_.guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SectorContract.Guid)
}

// int32 BranchId = 3;
inline void SectorContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t SectorContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t SectorContract::branchid() const {
  // @@protoc_insertion_point(field_get:SectorContract.BranchId)
  return _internal_branchid();
}
inline void SectorContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void SectorContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:SectorContract.BranchId)
}

// optional .BranchContract Branch = 4;
inline bool SectorContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool SectorContract::has_branch() const {
  return _internal_has_branch();
}
inline void SectorContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::BranchContract& SectorContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& SectorContract::branch() const {
  // @@protoc_insertion_point(field_get:SectorContract.Branch)
  return _internal_branch();
}
inline void SectorContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SectorContract.Branch)
}
inline ::BranchContract* SectorContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* SectorContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:SectorContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* SectorContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* SectorContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:SectorContract.Branch)
  return _msg;
}
inline void SectorContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:SectorContract.Branch)
}

// string Title = 5;
inline void SectorContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SectorContract::title() const {
  // @@protoc_insertion_point(field_get:SectorContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectorContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SectorContract.Title)
}
inline std::string* SectorContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SectorContract.Title)
  return _s;
}
inline const std::string& SectorContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SectorContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SectorContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* SectorContract::release_title() {
  // @@protoc_insertion_point(field_release:SectorContract.Title)
  return _impl_.title_.Release();
}
inline void SectorContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SectorContract.Title)
}

// float BarrierHeight = 6;
inline void SectorContract::clear_barrierheight() {
  _impl_.barrierheight_ = 0;
}
inline float SectorContract::_internal_barrierheight() const {
  return _impl_.barrierheight_;
}
inline float SectorContract::barrierheight() const {
  // @@protoc_insertion_point(field_get:SectorContract.BarrierHeight)
  return _internal_barrierheight();
}
inline void SectorContract::_internal_set_barrierheight(float value) {
  
  _impl_.barrierheight_ = value;
}
inline void SectorContract::set_barrierheight(float value) {
  _internal_set_barrierheight(value);
  // @@protoc_insertion_point(field_set:SectorContract.BarrierHeight)
}

// float BarrierWidth = 7;
inline void SectorContract::clear_barrierwidth() {
  _impl_.barrierwidth_ = 0;
}
inline float SectorContract::_internal_barrierwidth() const {
  return _impl_.barrierwidth_;
}
inline float SectorContract::barrierwidth() const {
  // @@protoc_insertion_point(field_get:SectorContract.BarrierWidth)
  return _internal_barrierwidth();
}
inline void SectorContract::_internal_set_barrierwidth(float value) {
  
  _impl_.barrierwidth_ = value;
}
inline void SectorContract::set_barrierwidth(float value) {
  _internal_set_barrierwidth(value);
  // @@protoc_insertion_point(field_set:SectorContract.BarrierWidth)
}

// float SectorHeight = 8;
inline void SectorContract::clear_sectorheight() {
  _impl_.sectorheight_ = 0;
}
inline float SectorContract::_internal_sectorheight() const {
  return _impl_.sectorheight_;
}
inline float SectorContract::sectorheight() const {
  // @@protoc_insertion_point(field_get:SectorContract.SectorHeight)
  return _internal_sectorheight();
}
inline void SectorContract::_internal_set_sectorheight(float value) {
  
  _impl_.sectorheight_ = value;
}
inline void SectorContract::set_sectorheight(float value) {
  _internal_set_sectorheight(value);
  // @@protoc_insertion_point(field_set:SectorContract.SectorHeight)
}

// float SectorWidth = 9;
inline void SectorContract::clear_sectorwidth() {
  _impl_.sectorwidth_ = 0;
}
inline float SectorContract::_internal_sectorwidth() const {
  return _impl_.sectorwidth_;
}
inline float SectorContract::sectorwidth() const {
  // @@protoc_insertion_point(field_get:SectorContract.SectorWidth)
  return _internal_sectorwidth();
}
inline void SectorContract::_internal_set_sectorwidth(float value) {
  
  _impl_.sectorwidth_ = value;
}
inline void SectorContract::set_sectorwidth(float value) {
  _internal_set_sectorwidth(value);
  // @@protoc_insertion_point(field_set:SectorContract.SectorWidth)
}

// int64 Modified = 10;
inline void SectorContract::clear_modified() {
  _impl_.modified_ = int64_t{0};
}
inline int64_t SectorContract::_internal_modified() const {
  return _impl_.modified_;
}
inline int64_t SectorContract::modified() const {
  // @@protoc_insertion_point(field_get:SectorContract.Modified)
  return _internal_modified();
}
inline void SectorContract::_internal_set_modified(int64_t value) {
  
  _impl_.modified_ = value;
}
inline void SectorContract::set_modified(int64_t value) {
  _internal_set_modified(value);
  // @@protoc_insertion_point(field_set:SectorContract.Modified)
}

// repeated .GpsItemContract GpsItems = 11;
inline int SectorContract::_internal_gpsitems_size() const {
  return _impl_.gpsitems_.size();
}
inline int SectorContract::gpsitems_size() const {
  return _internal_gpsitems_size();
}
inline void SectorContract::clear_gpsitems() {
  _impl_.gpsitems_.Clear();
}
inline ::GpsItemContract* SectorContract::mutable_gpsitems(int index) {
  // @@protoc_insertion_point(field_mutable:SectorContract.GpsItems)
  return _impl_.gpsitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GpsItemContract >*
SectorContract::mutable_gpsitems() {
  // @@protoc_insertion_point(field_mutable_list:SectorContract.GpsItems)
  return &_impl_.gpsitems_;
}
inline const ::GpsItemContract& SectorContract::_internal_gpsitems(int index) const {
  return _impl_.gpsitems_.Get(index);
}
inline const ::GpsItemContract& SectorContract::gpsitems(int index) const {
  // @@protoc_insertion_point(field_get:SectorContract.GpsItems)
  return _internal_gpsitems(index);
}
inline ::GpsItemContract* SectorContract::_internal_add_gpsitems() {
  return _impl_.gpsitems_.Add();
}
inline ::GpsItemContract* SectorContract::add_gpsitems() {
  ::GpsItemContract* _add = _internal_add_gpsitems();
  // @@protoc_insertion_point(field_add:SectorContract.GpsItems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GpsItemContract >&
SectorContract::gpsitems() const {
  // @@protoc_insertion_point(field_list:SectorContract.GpsItems)
  return _impl_.gpsitems_;
}

// repeated .AreaContract Areas = 12;
inline int SectorContract::_internal_areas_size() const {
  return _impl_.areas_.size();
}
inline int SectorContract::areas_size() const {
  return _internal_areas_size();
}
inline void SectorContract::clear_areas() {
  _impl_.areas_.Clear();
}
inline ::AreaContract* SectorContract::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:SectorContract.Areas)
  return _impl_.areas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >*
SectorContract::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:SectorContract.Areas)
  return &_impl_.areas_;
}
inline const ::AreaContract& SectorContract::_internal_areas(int index) const {
  return _impl_.areas_.Get(index);
}
inline const ::AreaContract& SectorContract::areas(int index) const {
  // @@protoc_insertion_point(field_get:SectorContract.Areas)
  return _internal_areas(index);
}
inline ::AreaContract* SectorContract::_internal_add_areas() {
  return _impl_.areas_.Add();
}
inline ::AreaContract* SectorContract::add_areas() {
  ::AreaContract* _add = _internal_add_areas();
  // @@protoc_insertion_point(field_add:SectorContract.Areas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >&
SectorContract::areas() const {
  // @@protoc_insertion_point(field_list:SectorContract.Areas)
  return _impl_.areas_;
}

// repeated .BarrierContract Barriers = 13;
inline int SectorContract::_internal_barriers_size() const {
  return _impl_.barriers_.size();
}
inline int SectorContract::barriers_size() const {
  return _internal_barriers_size();
}
inline void SectorContract::clear_barriers() {
  _impl_.barriers_.Clear();
}
inline ::BarrierContract* SectorContract::mutable_barriers(int index) {
  // @@protoc_insertion_point(field_mutable:SectorContract.Barriers)
  return _impl_.barriers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BarrierContract >*
SectorContract::mutable_barriers() {
  // @@protoc_insertion_point(field_mutable_list:SectorContract.Barriers)
  return &_impl_.barriers_;
}
inline const ::BarrierContract& SectorContract::_internal_barriers(int index) const {
  return _impl_.barriers_.Get(index);
}
inline const ::BarrierContract& SectorContract::barriers(int index) const {
  // @@protoc_insertion_point(field_get:SectorContract.Barriers)
  return _internal_barriers(index);
}
inline ::BarrierContract* SectorContract::_internal_add_barriers() {
  return _impl_.barriers_.Add();
}
inline ::BarrierContract* SectorContract::add_barriers() {
  ::BarrierContract* _add = _internal_add_barriers();
  // @@protoc_insertion_point(field_add:SectorContract.Barriers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BarrierContract >&
SectorContract::barriers() const {
  // @@protoc_insertion_point(field_list:SectorContract.Barriers)
  return _impl_.barriers_;
}

// repeated .BeaconContract Beacons = 14;
inline int SectorContract::_internal_beacons_size() const {
  return _impl_.beacons_.size();
}
inline int SectorContract::beacons_size() const {
  return _internal_beacons_size();
}
inline void SectorContract::clear_beacons() {
  _impl_.beacons_.Clear();
}
inline ::BeaconContract* SectorContract::mutable_beacons(int index) {
  // @@protoc_insertion_point(field_mutable:SectorContract.Beacons)
  return _impl_.beacons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BeaconContract >*
SectorContract::mutable_beacons() {
  // @@protoc_insertion_point(field_mutable_list:SectorContract.Beacons)
  return &_impl_.beacons_;
}
inline const ::BeaconContract& SectorContract::_internal_beacons(int index) const {
  return _impl_.beacons_.Get(index);
}
inline const ::BeaconContract& SectorContract::beacons(int index) const {
  // @@protoc_insertion_point(field_get:SectorContract.Beacons)
  return _internal_beacons(index);
}
inline ::BeaconContract* SectorContract::_internal_add_beacons() {
  return _impl_.beacons_.Add();
}
inline ::BeaconContract* SectorContract::add_beacons() {
  ::BeaconContract* _add = _internal_add_beacons();
  // @@protoc_insertion_point(field_add:SectorContract.Beacons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BeaconContract >&
SectorContract::beacons() const {
  // @@protoc_insertion_point(field_list:SectorContract.Beacons)
  return _impl_.beacons_;
}

// repeated .SensorContract Sensors = 15;
inline int SectorContract::_internal_sensors_size() const {
  return _impl_.sensors_.size();
}
inline int SectorContract::sensors_size() const {
  return _internal_sensors_size();
}
inline void SectorContract::clear_sensors() {
  _impl_.sensors_.Clear();
}
inline ::SensorContract* SectorContract::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:SectorContract.Sensors)
  return _impl_.sensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >*
SectorContract::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:SectorContract.Sensors)
  return &_impl_.sensors_;
}
inline const ::SensorContract& SectorContract::_internal_sensors(int index) const {
  return _impl_.sensors_.Get(index);
}
inline const ::SensorContract& SectorContract::sensors(int index) const {
  // @@protoc_insertion_point(field_get:SectorContract.Sensors)
  return _internal_sensors(index);
}
inline ::SensorContract* SectorContract::_internal_add_sensors() {
  return _impl_.sensors_.Add();
}
inline ::SensorContract* SectorContract::add_sensors() {
  ::SensorContract* _add = _internal_add_sensors();
  // @@protoc_insertion_point(field_add:SectorContract.Sensors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorContract >&
SectorContract::sensors() const {
  // @@protoc_insertion_point(field_list:SectorContract.Sensors)
  return _impl_.sensors_;
}

// string Configuration = 16;
inline void SectorContract::clear_configuration() {
  _impl_.configuration_.ClearToEmpty();
}
inline const std::string& SectorContract::configuration() const {
  // @@protoc_insertion_point(field_get:SectorContract.Configuration)
  return _internal_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SectorContract::set_configuration(ArgT0&& arg0, ArgT... args) {
 
 _impl_.configuration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SectorContract.Configuration)
}
inline std::string* SectorContract::mutable_configuration() {
  std::string* _s = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:SectorContract.Configuration)
  return _s;
}
inline const std::string& SectorContract::_internal_configuration() const {
  return _impl_.configuration_.Get();
}
inline void SectorContract::_internal_set_configuration(const std::string& value) {
  
  _impl_.configuration_.Set(value, GetArenaForAllocation());
}
inline std::string* SectorContract::_internal_mutable_configuration() {
  
  return _impl_.configuration_.Mutable(GetArenaForAllocation());
}
inline std::string* SectorContract::release_configuration() {
  // @@protoc_insertion_point(field_release:SectorContract.Configuration)
  return _impl_.configuration_.Release();
}
inline void SectorContract::set_allocated_configuration(std::string* configuration) {
  if (configuration != nullptr) {
    
  } else {
    
  }
  _impl_.configuration_.SetAllocated(configuration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.configuration_.IsDefault()) {
    _impl_.configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SectorContract.Configuration)
}

// repeated .PathContract Paths = 17;
inline int SectorContract::_internal_paths_size() const {
  return _impl_.paths_.size();
}
inline int SectorContract::paths_size() const {
  return _internal_paths_size();
}
inline void SectorContract::clear_paths() {
  _impl_.paths_.Clear();
}
inline ::PathContract* SectorContract::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:SectorContract.Paths)
  return _impl_.paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >*
SectorContract::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:SectorContract.Paths)
  return &_impl_.paths_;
}
inline const ::PathContract& SectorContract::_internal_paths(int index) const {
  return _impl_.paths_.Get(index);
}
inline const ::PathContract& SectorContract::paths(int index) const {
  // @@protoc_insertion_point(field_get:SectorContract.Paths)
  return _internal_paths(index);
}
inline ::PathContract* SectorContract::_internal_add_paths() {
  return _impl_.paths_.Add();
}
inline ::PathContract* SectorContract::add_paths() {
  ::PathContract* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:SectorContract.Paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >&
SectorContract::paths() const {
  // @@protoc_insertion_point(field_list:SectorContract.Paths)
  return _impl_.paths_;
}

// -------------------------------------------------------------------

// BranchContract

// int32 Id = 1;
inline void BranchContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t BranchContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t BranchContract::id() const {
  // @@protoc_insertion_point(field_get:BranchContract.Id)
  return _internal_id();
}
inline void BranchContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void BranchContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:BranchContract.Id)
}

// string Title = 2;
inline void BranchContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& BranchContract::title() const {
  // @@protoc_insertion_point(field_get:BranchContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BranchContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BranchContract.Title)
}
inline std::string* BranchContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:BranchContract.Title)
  return _s;
}
inline const std::string& BranchContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BranchContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BranchContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* BranchContract::release_title() {
  // @@protoc_insertion_point(field_release:BranchContract.Title)
  return _impl_.title_.Release();
}
inline void BranchContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BranchContract.Title)
}

// .Guid Guid = 3;
inline bool BranchContract::_internal_has_guid() const {
  return this != internal_default_instance() && _impl_.guid_ != nullptr;
}
inline bool BranchContract::has_guid() const {
  return _internal_has_guid();
}
inline void BranchContract::clear_guid() {
  if (GetArenaForAllocation() == nullptr && _impl_.guid_ != nullptr) {
    delete _impl_.guid_;
  }
  _impl_.guid_ = nullptr;
}
inline const ::Guid& BranchContract::_internal_guid() const {
  const ::Guid* p = _impl_.guid_;
  return p != nullptr ? *p : reinterpret_cast<const ::Guid&>(
      ::_Guid_default_instance_);
}
inline const ::Guid& BranchContract::guid() const {
  // @@protoc_insertion_point(field_get:BranchContract.Guid)
  return _internal_guid();
}
inline void BranchContract::unsafe_arena_set_allocated_guid(
    ::Guid* guid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.guid_);
  }
  _impl_.guid_ = guid;
  if (guid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BranchContract.Guid)
}
inline ::Guid* BranchContract::release_guid() {
  
  ::Guid* temp = _impl_.guid_;
  _impl_.guid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Guid* BranchContract::unsafe_arena_release_guid() {
  // @@protoc_insertion_point(field_release:BranchContract.Guid)
  
  ::Guid* temp = _impl_.guid_;
  _impl_.guid_ = nullptr;
  return temp;
}
inline ::Guid* BranchContract::_internal_mutable_guid() {
  
  if (_impl_.guid_ == nullptr) {
    auto* p = CreateMaybeMessage<::Guid>(GetArenaForAllocation());
    _impl_.guid_ = p;
  }
  return _impl_.guid_;
}
inline ::Guid* BranchContract::mutable_guid() {
  ::Guid* _msg = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:BranchContract.Guid)
  return _msg;
}
inline void BranchContract::set_allocated_guid(::Guid* guid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.guid_;
  }
  if (guid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guid);
    if (message_arena != submessage_arena) {
      guid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.guid_ = guid;
  // @@protoc_insertion_point(field_set_allocated:BranchContract.Guid)
}

// string TimeZone = 4;
inline void BranchContract::clear_timezone() {
  _impl_.timezone_.ClearToEmpty();
}
inline const std::string& BranchContract::timezone() const {
  // @@protoc_insertion_point(field_get:BranchContract.TimeZone)
  return _internal_timezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BranchContract::set_timezone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.timezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BranchContract.TimeZone)
}
inline std::string* BranchContract::mutable_timezone() {
  std::string* _s = _internal_mutable_timezone();
  // @@protoc_insertion_point(field_mutable:BranchContract.TimeZone)
  return _s;
}
inline const std::string& BranchContract::_internal_timezone() const {
  return _impl_.timezone_.Get();
}
inline void BranchContract::_internal_set_timezone(const std::string& value) {
  
  _impl_.timezone_.Set(value, GetArenaForAllocation());
}
inline std::string* BranchContract::_internal_mutable_timezone() {
  
  return _impl_.timezone_.Mutable(GetArenaForAllocation());
}
inline std::string* BranchContract::release_timezone() {
  // @@protoc_insertion_point(field_release:BranchContract.TimeZone)
  return _impl_.timezone_.Release();
}
inline void BranchContract::set_allocated_timezone(std::string* timezone) {
  if (timezone != nullptr) {
    
  } else {
    
  }
  _impl_.timezone_.SetAllocated(timezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.timezone_.IsDefault()) {
    _impl_.timezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BranchContract.TimeZone)
}

// float Latitude = 5;
inline void BranchContract::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline float BranchContract::_internal_latitude() const {
  return _impl_.latitude_;
}
inline float BranchContract::latitude() const {
  // @@protoc_insertion_point(field_get:BranchContract.Latitude)
  return _internal_latitude();
}
inline void BranchContract::_internal_set_latitude(float value) {
  
  _impl_.latitude_ = value;
}
inline void BranchContract::set_latitude(float value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:BranchContract.Latitude)
}

// float Longtitude = 6;
inline void BranchContract::clear_longtitude() {
  _impl_.longtitude_ = 0;
}
inline float BranchContract::_internal_longtitude() const {
  return _impl_.longtitude_;
}
inline float BranchContract::longtitude() const {
  // @@protoc_insertion_point(field_get:BranchContract.Longtitude)
  return _internal_longtitude();
}
inline void BranchContract::_internal_set_longtitude(float value) {
  
  _impl_.longtitude_ = value;
}
inline void BranchContract::set_longtitude(float value) {
  _internal_set_longtitude(value);
  // @@protoc_insertion_point(field_set:BranchContract.Longtitude)
}

// repeated .SectorContract Sectors = 7;
inline int BranchContract::_internal_sectors_size() const {
  return _impl_.sectors_.size();
}
inline int BranchContract::sectors_size() const {
  return _internal_sectors_size();
}
inline void BranchContract::clear_sectors() {
  _impl_.sectors_.Clear();
}
inline ::SectorContract* BranchContract::mutable_sectors(int index) {
  // @@protoc_insertion_point(field_mutable:BranchContract.Sectors)
  return _impl_.sectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SectorContract >*
BranchContract::mutable_sectors() {
  // @@protoc_insertion_point(field_mutable_list:BranchContract.Sectors)
  return &_impl_.sectors_;
}
inline const ::SectorContract& BranchContract::_internal_sectors(int index) const {
  return _impl_.sectors_.Get(index);
}
inline const ::SectorContract& BranchContract::sectors(int index) const {
  // @@protoc_insertion_point(field_get:BranchContract.Sectors)
  return _internal_sectors(index);
}
inline ::SectorContract* BranchContract::_internal_add_sectors() {
  return _impl_.sectors_.Add();
}
inline ::SectorContract* BranchContract::add_sectors() {
  ::SectorContract* _add = _internal_add_sectors();
  // @@protoc_insertion_point(field_add:BranchContract.Sectors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SectorContract >&
BranchContract::sectors() const {
  // @@protoc_insertion_point(field_list:BranchContract.Sectors)
  return _impl_.sectors_;
}

// -------------------------------------------------------------------

// LayerContract

// int32 Id = 1;
inline void LayerContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t LayerContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t LayerContract::id() const {
  // @@protoc_insertion_point(field_get:LayerContract.Id)
  return _internal_id();
}
inline void LayerContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void LayerContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:LayerContract.Id)
}

// string Title = 2;
inline void LayerContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& LayerContract::title() const {
  // @@protoc_insertion_point(field_get:LayerContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LayerContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LayerContract.Title)
}
inline std::string* LayerContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:LayerContract.Title)
  return _s;
}
inline const std::string& LayerContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void LayerContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* LayerContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* LayerContract::release_title() {
  // @@protoc_insertion_point(field_release:LayerContract.Title)
  return _impl_.title_.Release();
}
inline void LayerContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LayerContract.Title)
}

// string Icon = 3;
inline void LayerContract::clear_icon() {
  _impl_.icon_.ClearToEmpty();
}
inline const std::string& LayerContract::icon() const {
  // @@protoc_insertion_point(field_get:LayerContract.Icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LayerContract::set_icon(ArgT0&& arg0, ArgT... args) {
 
 _impl_.icon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LayerContract.Icon)
}
inline std::string* LayerContract::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:LayerContract.Icon)
  return _s;
}
inline const std::string& LayerContract::_internal_icon() const {
  return _impl_.icon_.Get();
}
inline void LayerContract::_internal_set_icon(const std::string& value) {
  
  _impl_.icon_.Set(value, GetArenaForAllocation());
}
inline std::string* LayerContract::_internal_mutable_icon() {
  
  return _impl_.icon_.Mutable(GetArenaForAllocation());
}
inline std::string* LayerContract::release_icon() {
  // @@protoc_insertion_point(field_release:LayerContract.Icon)
  return _impl_.icon_.Release();
}
inline void LayerContract::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  _impl_.icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.icon_.IsDefault()) {
    _impl_.icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LayerContract.Icon)
}

// int32 BranchId = 4;
inline void LayerContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t LayerContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t LayerContract::branchid() const {
  // @@protoc_insertion_point(field_get:LayerContract.BranchId)
  return _internal_branchid();
}
inline void LayerContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void LayerContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:LayerContract.BranchId)
}

// optional .BranchContract Branch = 5;
inline bool LayerContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool LayerContract::has_branch() const {
  return _internal_has_branch();
}
inline void LayerContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::BranchContract& LayerContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& LayerContract::branch() const {
  // @@protoc_insertion_point(field_get:LayerContract.Branch)
  return _internal_branch();
}
inline void LayerContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:LayerContract.Branch)
}
inline ::BranchContract* LayerContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* LayerContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:LayerContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* LayerContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* LayerContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:LayerContract.Branch)
  return _msg;
}
inline void LayerContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:LayerContract.Branch)
}

// bool Visible = 6;
inline void LayerContract::clear_visible() {
  _impl_.visible_ = false;
}
inline bool LayerContract::_internal_visible() const {
  return _impl_.visible_;
}
inline bool LayerContract::visible() const {
  // @@protoc_insertion_point(field_get:LayerContract.Visible)
  return _internal_visible();
}
inline void LayerContract::_internal_set_visible(bool value) {
  
  _impl_.visible_ = value;
}
inline void LayerContract::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:LayerContract.Visible)
}

// bool Localization = 7;
inline void LayerContract::clear_localization() {
  _impl_.localization_ = false;
}
inline bool LayerContract::_internal_localization() const {
  return _impl_.localization_;
}
inline bool LayerContract::localization() const {
  // @@protoc_insertion_point(field_get:LayerContract.Localization)
  return _internal_localization();
}
inline void LayerContract::_internal_set_localization(bool value) {
  
  _impl_.localization_ = value;
}
inline void LayerContract::set_localization(bool value) {
  _internal_set_localization(value);
  // @@protoc_insertion_point(field_set:LayerContract.Localization)
}

// int64 Created = 8;
inline void LayerContract::clear_created() {
  _impl_.created_ = int64_t{0};
}
inline int64_t LayerContract::_internal_created() const {
  return _impl_.created_;
}
inline int64_t LayerContract::created() const {
  // @@protoc_insertion_point(field_get:LayerContract.Created)
  return _internal_created();
}
inline void LayerContract::_internal_set_created(int64_t value) {
  
  _impl_.created_ = value;
}
inline void LayerContract::set_created(int64_t value) {
  _internal_set_created(value);
  // @@protoc_insertion_point(field_set:LayerContract.Created)
}

// int64 Updated = 9;
inline void LayerContract::clear_updated() {
  _impl_.updated_ = int64_t{0};
}
inline int64_t LayerContract::_internal_updated() const {
  return _impl_.updated_;
}
inline int64_t LayerContract::updated() const {
  // @@protoc_insertion_point(field_get:LayerContract.Updated)
  return _internal_updated();
}
inline void LayerContract::_internal_set_updated(int64_t value) {
  
  _impl_.updated_ = value;
}
inline void LayerContract::set_updated(int64_t value) {
  _internal_set_updated(value);
  // @@protoc_insertion_point(field_set:LayerContract.Updated)
}

// repeated .AreaContract Areas = 10;
inline int LayerContract::_internal_areas_size() const {
  return _impl_.areas_.size();
}
inline int LayerContract::areas_size() const {
  return _internal_areas_size();
}
inline void LayerContract::clear_areas() {
  _impl_.areas_.Clear();
}
inline ::AreaContract* LayerContract::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:LayerContract.Areas)
  return _impl_.areas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >*
LayerContract::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:LayerContract.Areas)
  return &_impl_.areas_;
}
inline const ::AreaContract& LayerContract::_internal_areas(int index) const {
  return _impl_.areas_.Get(index);
}
inline const ::AreaContract& LayerContract::areas(int index) const {
  // @@protoc_insertion_point(field_get:LayerContract.Areas)
  return _internal_areas(index);
}
inline ::AreaContract* LayerContract::_internal_add_areas() {
  return _impl_.areas_.Add();
}
inline ::AreaContract* LayerContract::add_areas() {
  ::AreaContract* _add = _internal_add_areas();
  // @@protoc_insertion_point(field_add:LayerContract.Areas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AreaContract >&
LayerContract::areas() const {
  // @@protoc_insertion_point(field_list:LayerContract.Areas)
  return _impl_.areas_;
}

// repeated .DeviceContract Devices = 11;
inline int LayerContract::_internal_devices_size() const {
  return _impl_.devices_.size();
}
inline int LayerContract::devices_size() const {
  return _internal_devices_size();
}
inline void LayerContract::clear_devices() {
  _impl_.devices_.Clear();
}
inline ::DeviceContract* LayerContract::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:LayerContract.Devices)
  return _impl_.devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >*
LayerContract::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:LayerContract.Devices)
  return &_impl_.devices_;
}
inline const ::DeviceContract& LayerContract::_internal_devices(int index) const {
  return _impl_.devices_.Get(index);
}
inline const ::DeviceContract& LayerContract::devices(int index) const {
  // @@protoc_insertion_point(field_get:LayerContract.Devices)
  return _internal_devices(index);
}
inline ::DeviceContract* LayerContract::_internal_add_devices() {
  return _impl_.devices_.Add();
}
inline ::DeviceContract* LayerContract::add_devices() {
  ::DeviceContract* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:LayerContract.Devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DeviceContract >&
LayerContract::devices() const {
  // @@protoc_insertion_point(field_list:LayerContract.Devices)
  return _impl_.devices_;
}

// bool IsNoGo = 12;
inline void LayerContract::clear_isnogo() {
  _impl_.isnogo_ = false;
}
inline bool LayerContract::_internal_isnogo() const {
  return _impl_.isnogo_;
}
inline bool LayerContract::isnogo() const {
  // @@protoc_insertion_point(field_get:LayerContract.IsNoGo)
  return _internal_isnogo();
}
inline void LayerContract::_internal_set_isnogo(bool value) {
  
  _impl_.isnogo_ = value;
}
inline void LayerContract::set_isnogo(bool value) {
  _internal_set_isnogo(value);
  // @@protoc_insertion_point(field_set:LayerContract.IsNoGo)
}

// repeated .PathContract Paths = 13;
inline int LayerContract::_internal_paths_size() const {
  return _impl_.paths_.size();
}
inline int LayerContract::paths_size() const {
  return _internal_paths_size();
}
inline void LayerContract::clear_paths() {
  _impl_.paths_.Clear();
}
inline ::PathContract* LayerContract::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:LayerContract.Paths)
  return _impl_.paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >*
LayerContract::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:LayerContract.Paths)
  return &_impl_.paths_;
}
inline const ::PathContract& LayerContract::_internal_paths(int index) const {
  return _impl_.paths_.Get(index);
}
inline const ::PathContract& LayerContract::paths(int index) const {
  // @@protoc_insertion_point(field_get:LayerContract.Paths)
  return _internal_paths(index);
}
inline ::PathContract* LayerContract::_internal_add_paths() {
  return _impl_.paths_.Add();
}
inline ::PathContract* LayerContract::add_paths() {
  ::PathContract* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:LayerContract.Paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathContract >&
LayerContract::paths() const {
  // @@protoc_insertion_point(field_list:LayerContract.Paths)
  return _impl_.paths_;
}

// repeated .LayerContract Children = 14;
inline int LayerContract::_internal_children_size() const {
  return _impl_.children_.size();
}
inline int LayerContract::children_size() const {
  return _internal_children_size();
}
inline void LayerContract::clear_children() {
  _impl_.children_.Clear();
}
inline ::LayerContract* LayerContract::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:LayerContract.Children)
  return _impl_.children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >*
LayerContract::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:LayerContract.Children)
  return &_impl_.children_;
}
inline const ::LayerContract& LayerContract::_internal_children(int index) const {
  return _impl_.children_.Get(index);
}
inline const ::LayerContract& LayerContract::children(int index) const {
  // @@protoc_insertion_point(field_get:LayerContract.Children)
  return _internal_children(index);
}
inline ::LayerContract* LayerContract::_internal_add_children() {
  return _impl_.children_.Add();
}
inline ::LayerContract* LayerContract::add_children() {
  ::LayerContract* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:LayerContract.Children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LayerContract >&
LayerContract::children() const {
  // @@protoc_insertion_point(field_list:LayerContract.Children)
  return _impl_.children_;
}

// -------------------------------------------------------------------

// PathContract

// int32 Id = 1;
inline void PathContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t PathContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t PathContract::id() const {
  // @@protoc_insertion_point(field_get:PathContract.Id)
  return _internal_id();
}
inline void PathContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void PathContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PathContract.Id)
}

// .Guid Guid = 2;
inline bool PathContract::_internal_has_guid() const {
  return this != internal_default_instance() && _impl_.guid_ != nullptr;
}
inline bool PathContract::has_guid() const {
  return _internal_has_guid();
}
inline void PathContract::clear_guid() {
  if (GetArenaForAllocation() == nullptr && _impl_.guid_ != nullptr) {
    delete _impl_.guid_;
  }
  _impl_.guid_ = nullptr;
}
inline const ::Guid& PathContract::_internal_guid() const {
  const ::Guid* p = _impl_.guid_;
  return p != nullptr ? *p : reinterpret_cast<const ::Guid&>(
      ::_Guid_default_instance_);
}
inline const ::Guid& PathContract::guid() const {
  // @@protoc_insertion_point(field_get:PathContract.Guid)
  return _internal_guid();
}
inline void PathContract::unsafe_arena_set_allocated_guid(
    ::Guid* guid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.guid_);
  }
  _impl_.guid_ = guid;
  if (guid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathContract.Guid)
}
inline ::Guid* PathContract::release_guid() {
  
  ::Guid* temp = _impl_.guid_;
  _impl_.guid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Guid* PathContract::unsafe_arena_release_guid() {
  // @@protoc_insertion_point(field_release:PathContract.Guid)
  
  ::Guid* temp = _impl_.guid_;
  _impl_.guid_ = nullptr;
  return temp;
}
inline ::Guid* PathContract::_internal_mutable_guid() {
  
  if (_impl_.guid_ == nullptr) {
    auto* p = CreateMaybeMessage<::Guid>(GetArenaForAllocation());
    _impl_.guid_ = p;
  }
  return _impl_.guid_;
}
inline ::Guid* PathContract::mutable_guid() {
  ::Guid* _msg = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:PathContract.Guid)
  return _msg;
}
inline void PathContract::set_allocated_guid(::Guid* guid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.guid_;
  }
  if (guid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guid);
    if (message_arena != submessage_arena) {
      guid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.guid_ = guid;
  // @@protoc_insertion_point(field_set_allocated:PathContract.Guid)
}

// string Title = 3;
inline void PathContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& PathContract::title() const {
  // @@protoc_insertion_point(field_get:PathContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PathContract.Title)
}
inline std::string* PathContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:PathContract.Title)
  return _s;
}
inline const std::string& PathContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void PathContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* PathContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* PathContract::release_title() {
  // @@protoc_insertion_point(field_release:PathContract.Title)
  return _impl_.title_.Release();
}
inline void PathContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PathContract.Title)
}

// int32 SectorId = 4;
inline void PathContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
}
inline int32_t PathContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t PathContract::sectorid() const {
  // @@protoc_insertion_point(field_get:PathContract.SectorId)
  return _internal_sectorid();
}
inline void PathContract::_internal_set_sectorid(int32_t value) {
  
  _impl_.sectorid_ = value;
}
inline void PathContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:PathContract.SectorId)
}

// optional .SectorContract Sector = 5;
inline bool PathContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool PathContract::has_sector() const {
  return _internal_has_sector();
}
inline void PathContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SectorContract& PathContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& PathContract::sector() const {
  // @@protoc_insertion_point(field_get:PathContract.Sector)
  return _internal_sector();
}
inline void PathContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathContract.Sector)
}
inline ::SectorContract* PathContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* PathContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:PathContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* PathContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* PathContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:PathContract.Sector)
  return _msg;
}
inline void PathContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:PathContract.Sector)
}

// int32 BranchId = 6;
inline void PathContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t PathContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t PathContract::branchid() const {
  // @@protoc_insertion_point(field_get:PathContract.BranchId)
  return _internal_branchid();
}
inline void PathContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void PathContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:PathContract.BranchId)
}

// optional .BranchContract Branch = 7;
inline bool PathContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool PathContract::has_branch() const {
  return _internal_has_branch();
}
inline void PathContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::BranchContract& PathContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& PathContract::branch() const {
  // @@protoc_insertion_point(field_get:PathContract.Branch)
  return _internal_branch();
}
inline void PathContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathContract.Branch)
}
inline ::BranchContract* PathContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* PathContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:PathContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* PathContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* PathContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:PathContract.Branch)
  return _msg;
}
inline void PathContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:PathContract.Branch)
}

// optional int32 LayerId = 8;
inline bool PathContract::_internal_has_layerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PathContract::has_layerid() const {
  return _internal_has_layerid();
}
inline void PathContract::clear_layerid() {
  _impl_.layerid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t PathContract::_internal_layerid() const {
  return _impl_.layerid_;
}
inline int32_t PathContract::layerid() const {
  // @@protoc_insertion_point(field_get:PathContract.LayerId)
  return _internal_layerid();
}
inline void PathContract::_internal_set_layerid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.layerid_ = value;
}
inline void PathContract::set_layerid(int32_t value) {
  _internal_set_layerid(value);
  // @@protoc_insertion_point(field_set:PathContract.LayerId)
}

// optional .LayerContract Layer = 9;
inline bool PathContract::_internal_has_layer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.layer_ != nullptr);
  return value;
}
inline bool PathContract::has_layer() const {
  return _internal_has_layer();
}
inline void PathContract::clear_layer() {
  if (_impl_.layer_ != nullptr) _impl_.layer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::LayerContract& PathContract::_internal_layer() const {
  const ::LayerContract* p = _impl_.layer_;
  return p != nullptr ? *p : reinterpret_cast<const ::LayerContract&>(
      ::_LayerContract_default_instance_);
}
inline const ::LayerContract& PathContract::layer() const {
  // @@protoc_insertion_point(field_get:PathContract.Layer)
  return _internal_layer();
}
inline void PathContract::unsafe_arena_set_allocated_layer(
    ::LayerContract* layer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layer_);
  }
  _impl_.layer_ = layer;
  if (layer) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathContract.Layer)
}
inline ::LayerContract* PathContract::release_layer() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::LayerContract* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LayerContract* PathContract::unsafe_arena_release_layer() {
  // @@protoc_insertion_point(field_release:PathContract.Layer)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::LayerContract* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
  return temp;
}
inline ::LayerContract* PathContract::_internal_mutable_layer() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::LayerContract>(GetArenaForAllocation());
    _impl_.layer_ = p;
  }
  return _impl_.layer_;
}
inline ::LayerContract* PathContract::mutable_layer() {
  ::LayerContract* _msg = _internal_mutable_layer();
  // @@protoc_insertion_point(field_mutable:PathContract.Layer)
  return _msg;
}
inline void PathContract::set_allocated_layer(::LayerContract* layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.layer_;
  }
  if (layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(layer);
    if (message_arena != submessage_arena) {
      layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.layer_ = layer;
  // @@protoc_insertion_point(field_set_allocated:PathContract.Layer)
}

// string Color = 10;
inline void PathContract::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& PathContract::color() const {
  // @@protoc_insertion_point(field_get:PathContract.Color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathContract::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PathContract.Color)
}
inline std::string* PathContract::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:PathContract.Color)
  return _s;
}
inline const std::string& PathContract::_internal_color() const {
  return _impl_.color_.Get();
}
inline void PathContract::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* PathContract::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* PathContract::release_color() {
  // @@protoc_insertion_point(field_release:PathContract.Color)
  return _impl_.color_.Release();
}
inline void PathContract::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PathContract.Color)
}

// repeated .PathPointContract PathPoints = 11;
inline int PathContract::_internal_pathpoints_size() const {
  return _impl_.pathpoints_.size();
}
inline int PathContract::pathpoints_size() const {
  return _internal_pathpoints_size();
}
inline void PathContract::clear_pathpoints() {
  _impl_.pathpoints_.Clear();
}
inline ::PathPointContract* PathContract::mutable_pathpoints(int index) {
  // @@protoc_insertion_point(field_mutable:PathContract.PathPoints)
  return _impl_.pathpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathPointContract >*
PathContract::mutable_pathpoints() {
  // @@protoc_insertion_point(field_mutable_list:PathContract.PathPoints)
  return &_impl_.pathpoints_;
}
inline const ::PathPointContract& PathContract::_internal_pathpoints(int index) const {
  return _impl_.pathpoints_.Get(index);
}
inline const ::PathPointContract& PathContract::pathpoints(int index) const {
  // @@protoc_insertion_point(field_get:PathContract.PathPoints)
  return _internal_pathpoints(index);
}
inline ::PathPointContract* PathContract::_internal_add_pathpoints() {
  return _impl_.pathpoints_.Add();
}
inline ::PathPointContract* PathContract::add_pathpoints() {
  ::PathPointContract* _add = _internal_add_pathpoints();
  // @@protoc_insertion_point(field_add:PathContract.PathPoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PathPointContract >&
PathContract::pathpoints() const {
  // @@protoc_insertion_point(field_list:PathContract.PathPoints)
  return _impl_.pathpoints_;
}

// string Description = 12;
inline void PathContract::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& PathContract::description() const {
  // @@protoc_insertion_point(field_get:PathContract.Description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PathContract::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PathContract.Description)
}
inline std::string* PathContract::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:PathContract.Description)
  return _s;
}
inline const std::string& PathContract::_internal_description() const {
  return _impl_.description_.Get();
}
inline void PathContract::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* PathContract::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* PathContract::release_description() {
  // @@protoc_insertion_point(field_release:PathContract.Description)
  return _impl_.description_.Release();
}
inline void PathContract::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PathContract.Description)
}

// int64 Created = 13;
inline void PathContract::clear_created() {
  _impl_.created_ = int64_t{0};
}
inline int64_t PathContract::_internal_created() const {
  return _impl_.created_;
}
inline int64_t PathContract::created() const {
  // @@protoc_insertion_point(field_get:PathContract.Created)
  return _internal_created();
}
inline void PathContract::_internal_set_created(int64_t value) {
  
  _impl_.created_ = value;
}
inline void PathContract::set_created(int64_t value) {
  _internal_set_created(value);
  // @@protoc_insertion_point(field_set:PathContract.Created)
}

// int64 Updated = 14;
inline void PathContract::clear_updated() {
  _impl_.updated_ = int64_t{0};
}
inline int64_t PathContract::_internal_updated() const {
  return _impl_.updated_;
}
inline int64_t PathContract::updated() const {
  // @@protoc_insertion_point(field_get:PathContract.Updated)
  return _internal_updated();
}
inline void PathContract::_internal_set_updated(int64_t value) {
  
  _impl_.updated_ = value;
}
inline void PathContract::set_updated(int64_t value) {
  _internal_set_updated(value);
  // @@protoc_insertion_point(field_set:PathContract.Updated)
}

// -------------------------------------------------------------------

// PathPointContract

// int32 Id = 1;
inline void PathPointContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t PathPointContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t PathPointContract::id() const {
  // @@protoc_insertion_point(field_get:PathPointContract.Id)
  return _internal_id();
}
inline void PathPointContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void PathPointContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:PathPointContract.Id)
}

// int32 PathId = 2;
inline void PathPointContract::clear_pathid() {
  _impl_.pathid_ = 0;
}
inline int32_t PathPointContract::_internal_pathid() const {
  return _impl_.pathid_;
}
inline int32_t PathPointContract::pathid() const {
  // @@protoc_insertion_point(field_get:PathPointContract.PathId)
  return _internal_pathid();
}
inline void PathPointContract::_internal_set_pathid(int32_t value) {
  
  _impl_.pathid_ = value;
}
inline void PathPointContract::set_pathid(int32_t value) {
  _internal_set_pathid(value);
  // @@protoc_insertion_point(field_set:PathPointContract.PathId)
}

// optional .PathContract Path = 3;
inline bool PathPointContract::_internal_has_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_ != nullptr);
  return value;
}
inline bool PathPointContract::has_path() const {
  return _internal_has_path();
}
inline void PathPointContract::clear_path() {
  if (_impl_.path_ != nullptr) _impl_.path_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::PathContract& PathPointContract::_internal_path() const {
  const ::PathContract* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::PathContract&>(
      ::_PathContract_default_instance_);
}
inline const ::PathContract& PathPointContract::path() const {
  // @@protoc_insertion_point(field_get:PathPointContract.Path)
  return _internal_path();
}
inline void PathPointContract::unsafe_arena_set_allocated_path(
    ::PathContract* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathPointContract.Path)
}
inline ::PathContract* PathPointContract::release_path() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PathContract* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PathContract* PathPointContract::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:PathPointContract.Path)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::PathContract* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::PathContract* PathPointContract::_internal_mutable_path() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::PathContract>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::PathContract* PathPointContract::mutable_path() {
  ::PathContract* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:PathPointContract.Path)
  return _msg;
}
inline void PathPointContract::set_allocated_path(::PathContract* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:PathPointContract.Path)
}

// int32 BranchId = 4;
inline void PathPointContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t PathPointContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t PathPointContract::branchid() const {
  // @@protoc_insertion_point(field_get:PathPointContract.BranchId)
  return _internal_branchid();
}
inline void PathPointContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void PathPointContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:PathPointContract.BranchId)
}

// optional .BranchContract Branch = 5;
inline bool PathPointContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool PathPointContract::has_branch() const {
  return _internal_has_branch();
}
inline void PathPointContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::BranchContract& PathPointContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& PathPointContract::branch() const {
  // @@protoc_insertion_point(field_get:PathPointContract.Branch)
  return _internal_branch();
}
inline void PathPointContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathPointContract.Branch)
}
inline ::BranchContract* PathPointContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* PathPointContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:PathPointContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* PathPointContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* PathPointContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:PathPointContract.Branch)
  return _msg;
}
inline void PathPointContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:PathPointContract.Branch)
}

// int32 Index = 6;
inline void PathPointContract::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t PathPointContract::_internal_index() const {
  return _impl_.index_;
}
inline int32_t PathPointContract::index() const {
  // @@protoc_insertion_point(field_get:PathPointContract.Index)
  return _internal_index();
}
inline void PathPointContract::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void PathPointContract::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:PathPointContract.Index)
}

// float X = 7;
inline void PathPointContract::clear_x() {
  _impl_.x_ = 0;
}
inline float PathPointContract::_internal_x() const {
  return _impl_.x_;
}
inline float PathPointContract::x() const {
  // @@protoc_insertion_point(field_get:PathPointContract.X)
  return _internal_x();
}
inline void PathPointContract::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void PathPointContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PathPointContract.X)
}

// float Y = 8;
inline void PathPointContract::clear_y() {
  _impl_.y_ = 0;
}
inline float PathPointContract::_internal_y() const {
  return _impl_.y_;
}
inline float PathPointContract::y() const {
  // @@protoc_insertion_point(field_get:PathPointContract.Y)
  return _internal_y();
}
inline void PathPointContract::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void PathPointContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PathPointContract.Y)
}

// optional int32 AreaId = 9;
inline bool PathPointContract::_internal_has_areaid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PathPointContract::has_areaid() const {
  return _internal_has_areaid();
}
inline void PathPointContract::clear_areaid() {
  _impl_.areaid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t PathPointContract::_internal_areaid() const {
  return _impl_.areaid_;
}
inline int32_t PathPointContract::areaid() const {
  // @@protoc_insertion_point(field_get:PathPointContract.AreaId)
  return _internal_areaid();
}
inline void PathPointContract::_internal_set_areaid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.areaid_ = value;
}
inline void PathPointContract::set_areaid(int32_t value) {
  _internal_set_areaid(value);
  // @@protoc_insertion_point(field_set:PathPointContract.AreaId)
}

// optional .AreaContract Area = 10;
inline bool PathPointContract::_internal_has_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.area_ != nullptr);
  return value;
}
inline bool PathPointContract::has_area() const {
  return _internal_has_area();
}
inline void PathPointContract::clear_area() {
  if (_impl_.area_ != nullptr) _impl_.area_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::AreaContract& PathPointContract::_internal_area() const {
  const ::AreaContract* p = _impl_.area_;
  return p != nullptr ? *p : reinterpret_cast<const ::AreaContract&>(
      ::_AreaContract_default_instance_);
}
inline const ::AreaContract& PathPointContract::area() const {
  // @@protoc_insertion_point(field_get:PathPointContract.Area)
  return _internal_area();
}
inline void PathPointContract::unsafe_arena_set_allocated_area(
    ::AreaContract* area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_);
  }
  _impl_.area_ = area;
  if (area) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PathPointContract.Area)
}
inline ::AreaContract* PathPointContract::release_area() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::AreaContract* temp = _impl_.area_;
  _impl_.area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AreaContract* PathPointContract::unsafe_arena_release_area() {
  // @@protoc_insertion_point(field_release:PathPointContract.Area)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::AreaContract* temp = _impl_.area_;
  _impl_.area_ = nullptr;
  return temp;
}
inline ::AreaContract* PathPointContract::_internal_mutable_area() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.area_ == nullptr) {
    auto* p = CreateMaybeMessage<::AreaContract>(GetArenaForAllocation());
    _impl_.area_ = p;
  }
  return _impl_.area_;
}
inline ::AreaContract* PathPointContract::mutable_area() {
  ::AreaContract* _msg = _internal_mutable_area();
  // @@protoc_insertion_point(field_mutable:PathPointContract.Area)
  return _msg;
}
inline void PathPointContract::set_allocated_area(::AreaContract* area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_;
  }
  if (area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area);
    if (message_arena != submessage_arena) {
      area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.area_ = area;
  // @@protoc_insertion_point(field_set_allocated:PathPointContract.Area)
}

// -------------------------------------------------------------------

// AreaContract

// int32 Id = 1;
inline void AreaContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t AreaContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t AreaContract::id() const {
  // @@protoc_insertion_point(field_get:AreaContract.Id)
  return _internal_id();
}
inline void AreaContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void AreaContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:AreaContract.Id)
}

// .Guid Guid = 2;
inline bool AreaContract::_internal_has_guid() const {
  return this != internal_default_instance() && _impl_.guid_ != nullptr;
}
inline bool AreaContract::has_guid() const {
  return _internal_has_guid();
}
inline void AreaContract::clear_guid() {
  if (GetArenaForAllocation() == nullptr && _impl_.guid_ != nullptr) {
    delete _impl_.guid_;
  }
  _impl_.guid_ = nullptr;
}
inline const ::Guid& AreaContract::_internal_guid() const {
  const ::Guid* p = _impl_.guid_;
  return p != nullptr ? *p : reinterpret_cast<const ::Guid&>(
      ::_Guid_default_instance_);
}
inline const ::Guid& AreaContract::guid() const {
  // @@protoc_insertion_point(field_get:AreaContract.Guid)
  return _internal_guid();
}
inline void AreaContract::unsafe_arena_set_allocated_guid(
    ::Guid* guid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.guid_);
  }
  _impl_.guid_ = guid;
  if (guid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AreaContract.Guid)
}
inline ::Guid* AreaContract::release_guid() {
  
  ::Guid* temp = _impl_.guid_;
  _impl_.guid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Guid* AreaContract::unsafe_arena_release_guid() {
  // @@protoc_insertion_point(field_release:AreaContract.Guid)
  
  ::Guid* temp = _impl_.guid_;
  _impl_.guid_ = nullptr;
  return temp;
}
inline ::Guid* AreaContract::_internal_mutable_guid() {
  
  if (_impl_.guid_ == nullptr) {
    auto* p = CreateMaybeMessage<::Guid>(GetArenaForAllocation());
    _impl_.guid_ = p;
  }
  return _impl_.guid_;
}
inline ::Guid* AreaContract::mutable_guid() {
  ::Guid* _msg = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:AreaContract.Guid)
  return _msg;
}
inline void AreaContract::set_allocated_guid(::Guid* guid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.guid_;
  }
  if (guid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(guid);
    if (message_arena != submessage_arena) {
      guid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, guid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.guid_ = guid;
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Guid)
}

// string Title = 3;
inline void AreaContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& AreaContract::title() const {
  // @@protoc_insertion_point(field_get:AreaContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AreaContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AreaContract.Title)
}
inline std::string* AreaContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:AreaContract.Title)
  return _s;
}
inline const std::string& AreaContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void AreaContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* AreaContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* AreaContract::release_title() {
  // @@protoc_insertion_point(field_release:AreaContract.Title)
  return _impl_.title_.Release();
}
inline void AreaContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Title)
}

// int32 SectorId = 4;
inline void AreaContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
}
inline int32_t AreaContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t AreaContract::sectorid() const {
  // @@protoc_insertion_point(field_get:AreaContract.SectorId)
  return _internal_sectorid();
}
inline void AreaContract::_internal_set_sectorid(int32_t value) {
  
  _impl_.sectorid_ = value;
}
inline void AreaContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:AreaContract.SectorId)
}

// optional .SectorContract Sector = 5;
inline bool AreaContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool AreaContract::has_sector() const {
  return _internal_has_sector();
}
inline void AreaContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SectorContract& AreaContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& AreaContract::sector() const {
  // @@protoc_insertion_point(field_get:AreaContract.Sector)
  return _internal_sector();
}
inline void AreaContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AreaContract.Sector)
}
inline ::SectorContract* AreaContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* AreaContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:AreaContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* AreaContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* AreaContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:AreaContract.Sector)
  return _msg;
}
inline void AreaContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Sector)
}

// int32 BranchId = 6;
inline void AreaContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t AreaContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t AreaContract::branchid() const {
  // @@protoc_insertion_point(field_get:AreaContract.BranchId)
  return _internal_branchid();
}
inline void AreaContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void AreaContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:AreaContract.BranchId)
}

// optional .BranchContract Branch = 7;
inline bool AreaContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool AreaContract::has_branch() const {
  return _internal_has_branch();
}
inline void AreaContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::BranchContract& AreaContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& AreaContract::branch() const {
  // @@protoc_insertion_point(field_get:AreaContract.Branch)
  return _internal_branch();
}
inline void AreaContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AreaContract.Branch)
}
inline ::BranchContract* AreaContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* AreaContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:AreaContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* AreaContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* AreaContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:AreaContract.Branch)
  return _msg;
}
inline void AreaContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Branch)
}

// optional int32 LayerId = 8;
inline bool AreaContract::_internal_has_layerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AreaContract::has_layerid() const {
  return _internal_has_layerid();
}
inline void AreaContract::clear_layerid() {
  _impl_.layerid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t AreaContract::_internal_layerid() const {
  return _impl_.layerid_;
}
inline int32_t AreaContract::layerid() const {
  // @@protoc_insertion_point(field_get:AreaContract.LayerId)
  return _internal_layerid();
}
inline void AreaContract::_internal_set_layerid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.layerid_ = value;
}
inline void AreaContract::set_layerid(int32_t value) {
  _internal_set_layerid(value);
  // @@protoc_insertion_point(field_set:AreaContract.LayerId)
}

// optional .LayerContract Layer = 9;
inline bool AreaContract::_internal_has_layer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.layer_ != nullptr);
  return value;
}
inline bool AreaContract::has_layer() const {
  return _internal_has_layer();
}
inline void AreaContract::clear_layer() {
  if (_impl_.layer_ != nullptr) _impl_.layer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::LayerContract& AreaContract::_internal_layer() const {
  const ::LayerContract* p = _impl_.layer_;
  return p != nullptr ? *p : reinterpret_cast<const ::LayerContract&>(
      ::_LayerContract_default_instance_);
}
inline const ::LayerContract& AreaContract::layer() const {
  // @@protoc_insertion_point(field_get:AreaContract.Layer)
  return _internal_layer();
}
inline void AreaContract::unsafe_arena_set_allocated_layer(
    ::LayerContract* layer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layer_);
  }
  _impl_.layer_ = layer;
  if (layer) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AreaContract.Layer)
}
inline ::LayerContract* AreaContract::release_layer() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::LayerContract* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::LayerContract* AreaContract::unsafe_arena_release_layer() {
  // @@protoc_insertion_point(field_release:AreaContract.Layer)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::LayerContract* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
  return temp;
}
inline ::LayerContract* AreaContract::_internal_mutable_layer() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::LayerContract>(GetArenaForAllocation());
    _impl_.layer_ = p;
  }
  return _impl_.layer_;
}
inline ::LayerContract* AreaContract::mutable_layer() {
  ::LayerContract* _msg = _internal_mutable_layer();
  // @@protoc_insertion_point(field_mutable:AreaContract.Layer)
  return _msg;
}
inline void AreaContract::set_allocated_layer(::LayerContract* layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.layer_;
  }
  if (layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(layer);
    if (message_arena != submessage_arena) {
      layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.layer_ = layer;
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Layer)
}

// string Color = 10;
inline void AreaContract::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& AreaContract::color() const {
  // @@protoc_insertion_point(field_get:AreaContract.Color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AreaContract::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AreaContract.Color)
}
inline std::string* AreaContract::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:AreaContract.Color)
  return _s;
}
inline const std::string& AreaContract::_internal_color() const {
  return _impl_.color_.Get();
}
inline void AreaContract::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* AreaContract::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* AreaContract::release_color() {
  // @@protoc_insertion_point(field_release:AreaContract.Color)
  return _impl_.color_.Release();
}
inline void AreaContract::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Color)
}

// repeated .PointContract Coordinates = 11;
inline int AreaContract::_internal_coordinates_size() const {
  return _impl_.coordinates_.size();
}
inline int AreaContract::coordinates_size() const {
  return _internal_coordinates_size();
}
inline void AreaContract::clear_coordinates() {
  _impl_.coordinates_.Clear();
}
inline ::PointContract* AreaContract::mutable_coordinates(int index) {
  // @@protoc_insertion_point(field_mutable:AreaContract.Coordinates)
  return _impl_.coordinates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PointContract >*
AreaContract::mutable_coordinates() {
  // @@protoc_insertion_point(field_mutable_list:AreaContract.Coordinates)
  return &_impl_.coordinates_;
}
inline const ::PointContract& AreaContract::_internal_coordinates(int index) const {
  return _impl_.coordinates_.Get(index);
}
inline const ::PointContract& AreaContract::coordinates(int index) const {
  // @@protoc_insertion_point(field_get:AreaContract.Coordinates)
  return _internal_coordinates(index);
}
inline ::PointContract* AreaContract::_internal_add_coordinates() {
  return _impl_.coordinates_.Add();
}
inline ::PointContract* AreaContract::add_coordinates() {
  ::PointContract* _add = _internal_add_coordinates();
  // @@protoc_insertion_point(field_add:AreaContract.Coordinates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PointContract >&
AreaContract::coordinates() const {
  // @@protoc_insertion_point(field_list:AreaContract.Coordinates)
  return _impl_.coordinates_;
}

// string Description = 12;
inline void AreaContract::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AreaContract::description() const {
  // @@protoc_insertion_point(field_get:AreaContract.Description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AreaContract::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AreaContract.Description)
}
inline std::string* AreaContract::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:AreaContract.Description)
  return _s;
}
inline const std::string& AreaContract::_internal_description() const {
  return _impl_.description_.Get();
}
inline void AreaContract::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* AreaContract::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* AreaContract::release_description() {
  // @@protoc_insertion_point(field_release:AreaContract.Description)
  return _impl_.description_.Release();
}
inline void AreaContract::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AreaContract.Description)
}

// int64 Created = 13;
inline void AreaContract::clear_created() {
  _impl_.created_ = int64_t{0};
}
inline int64_t AreaContract::_internal_created() const {
  return _impl_.created_;
}
inline int64_t AreaContract::created() const {
  // @@protoc_insertion_point(field_get:AreaContract.Created)
  return _internal_created();
}
inline void AreaContract::_internal_set_created(int64_t value) {
  
  _impl_.created_ = value;
}
inline void AreaContract::set_created(int64_t value) {
  _internal_set_created(value);
  // @@protoc_insertion_point(field_set:AreaContract.Created)
}

// int64 Updated = 14;
inline void AreaContract::clear_updated() {
  _impl_.updated_ = int64_t{0};
}
inline int64_t AreaContract::_internal_updated() const {
  return _impl_.updated_;
}
inline int64_t AreaContract::updated() const {
  // @@protoc_insertion_point(field_get:AreaContract.Updated)
  return _internal_updated();
}
inline void AreaContract::_internal_set_updated(int64_t value) {
  
  _impl_.updated_ = value;
}
inline void AreaContract::set_updated(int64_t value) {
  _internal_set_updated(value);
  // @@protoc_insertion_point(field_set:AreaContract.Updated)
}

// optional int32 TargetBranchId = 15;
inline bool AreaContract::_internal_has_targetbranchid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AreaContract::has_targetbranchid() const {
  return _internal_has_targetbranchid();
}
inline void AreaContract::clear_targetbranchid() {
  _impl_.targetbranchid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t AreaContract::_internal_targetbranchid() const {
  return _impl_.targetbranchid_;
}
inline int32_t AreaContract::targetbranchid() const {
  // @@protoc_insertion_point(field_get:AreaContract.TargetBranchId)
  return _internal_targetbranchid();
}
inline void AreaContract::_internal_set_targetbranchid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.targetbranchid_ = value;
}
inline void AreaContract::set_targetbranchid(int32_t value) {
  _internal_set_targetbranchid(value);
  // @@protoc_insertion_point(field_set:AreaContract.TargetBranchId)
}

// -------------------------------------------------------------------

// PointContract

// float X = 1;
inline void PointContract::clear_x() {
  _impl_.x_ = 0;
}
inline float PointContract::_internal_x() const {
  return _impl_.x_;
}
inline float PointContract::x() const {
  // @@protoc_insertion_point(field_get:PointContract.X)
  return _internal_x();
}
inline void PointContract::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void PointContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:PointContract.X)
}

// float Y = 2;
inline void PointContract::clear_y() {
  _impl_.y_ = 0;
}
inline float PointContract::_internal_y() const {
  return _impl_.y_;
}
inline float PointContract::y() const {
  // @@protoc_insertion_point(field_get:PointContract.Y)
  return _internal_y();
}
inline void PointContract::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void PointContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:PointContract.Y)
}

// -------------------------------------------------------------------

// DeviceLocationContract

// string Login = 1;
inline void DeviceLocationContract::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& DeviceLocationContract::login() const {
  // @@protoc_insertion_point(field_get:DeviceLocationContract.Login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceLocationContract::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeviceLocationContract.Login)
}
inline std::string* DeviceLocationContract::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:DeviceLocationContract.Login)
  return _s;
}
inline const std::string& DeviceLocationContract::_internal_login() const {
  return _impl_.login_.Get();
}
inline void DeviceLocationContract::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceLocationContract::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceLocationContract::release_login() {
  // @@protoc_insertion_point(field_release:DeviceLocationContract.Login)
  return _impl_.login_.Release();
}
inline void DeviceLocationContract::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeviceLocationContract.Login)
}

// repeated .LocationContract Locations = 2;
inline int DeviceLocationContract::_internal_locations_size() const {
  return _impl_.locations_.size();
}
inline int DeviceLocationContract::locations_size() const {
  return _internal_locations_size();
}
inline void DeviceLocationContract::clear_locations() {
  _impl_.locations_.Clear();
}
inline ::LocationContract* DeviceLocationContract::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:DeviceLocationContract.Locations)
  return _impl_.locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >*
DeviceLocationContract::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:DeviceLocationContract.Locations)
  return &_impl_.locations_;
}
inline const ::LocationContract& DeviceLocationContract::_internal_locations(int index) const {
  return _impl_.locations_.Get(index);
}
inline const ::LocationContract& DeviceLocationContract::locations(int index) const {
  // @@protoc_insertion_point(field_get:DeviceLocationContract.Locations)
  return _internal_locations(index);
}
inline ::LocationContract* DeviceLocationContract::_internal_add_locations() {
  return _impl_.locations_.Add();
}
inline ::LocationContract* DeviceLocationContract::add_locations() {
  ::LocationContract* _add = _internal_add_locations();
  // @@protoc_insertion_point(field_add:DeviceLocationContract.Locations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LocationContract >&
DeviceLocationContract::locations() const {
  // @@protoc_insertion_point(field_list:DeviceLocationContract.Locations)
  return _impl_.locations_;
}

// -------------------------------------------------------------------

// LocationContract

// int64 Timestamp = 1;
inline void LocationContract::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t LocationContract::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t LocationContract::timestamp() const {
  // @@protoc_insertion_point(field_get:LocationContract.Timestamp)
  return _internal_timestamp();
}
inline void LocationContract::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void LocationContract::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:LocationContract.Timestamp)
}

// optional int32 SectorId = 2;
inline bool LocationContract::_internal_has_sectorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocationContract::has_sectorid() const {
  return _internal_has_sectorid();
}
inline void LocationContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t LocationContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t LocationContract::sectorid() const {
  // @@protoc_insertion_point(field_get:LocationContract.SectorId)
  return _internal_sectorid();
}
inline void LocationContract::_internal_set_sectorid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sectorid_ = value;
}
inline void LocationContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:LocationContract.SectorId)
}

// optional float X = 3;
inline bool LocationContract::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocationContract::has_x() const {
  return _internal_has_x();
}
inline void LocationContract::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float LocationContract::_internal_x() const {
  return _impl_.x_;
}
inline float LocationContract::x() const {
  // @@protoc_insertion_point(field_get:LocationContract.X)
  return _internal_x();
}
inline void LocationContract::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void LocationContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:LocationContract.X)
}

// optional float Y = 4;
inline bool LocationContract::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocationContract::has_y() const {
  return _internal_has_y();
}
inline void LocationContract::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float LocationContract::_internal_y() const {
  return _impl_.y_;
}
inline float LocationContract::y() const {
  // @@protoc_insertion_point(field_get:LocationContract.Y)
  return _internal_y();
}
inline void LocationContract::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void LocationContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:LocationContract.Y)
}

// optional float Z = 5;
inline bool LocationContract::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocationContract::has_z() const {
  return _internal_has_z();
}
inline void LocationContract::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float LocationContract::_internal_z() const {
  return _impl_.z_;
}
inline float LocationContract::z() const {
  // @@protoc_insertion_point(field_get:LocationContract.Z)
  return _internal_z();
}
inline void LocationContract::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.z_ = value;
}
inline void LocationContract::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:LocationContract.Z)
}

// optional int32 Interval = 6;
inline bool LocationContract::_internal_has_interval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LocationContract::has_interval() const {
  return _internal_has_interval();
}
inline void LocationContract::clear_interval() {
  _impl_.interval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t LocationContract::_internal_interval() const {
  return _impl_.interval_;
}
inline int32_t LocationContract::interval() const {
  // @@protoc_insertion_point(field_get:LocationContract.Interval)
  return _internal_interval();
}
inline void LocationContract::_internal_set_interval(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.interval_ = value;
}
inline void LocationContract::set_interval(int32_t value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:LocationContract.Interval)
}

// optional uint32 battery = 7;
inline bool LocationContract::_internal_has_battery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LocationContract::has_battery() const {
  return _internal_has_battery();
}
inline void LocationContract::clear_battery() {
  _impl_.battery_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t LocationContract::_internal_battery() const {
  return _impl_.battery_;
}
inline uint32_t LocationContract::battery() const {
  // @@protoc_insertion_point(field_get:LocationContract.battery)
  return _internal_battery();
}
inline void LocationContract::_internal_set_battery(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.battery_ = value;
}
inline void LocationContract::set_battery(uint32_t value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:LocationContract.battery)
}

// bool IsMoving = 8;
inline void LocationContract::clear_ismoving() {
  _impl_.ismoving_ = false;
}
inline bool LocationContract::_internal_ismoving() const {
  return _impl_.ismoving_;
}
inline bool LocationContract::ismoving() const {
  // @@protoc_insertion_point(field_get:LocationContract.IsMoving)
  return _internal_ismoving();
}
inline void LocationContract::_internal_set_ismoving(bool value) {
  
  _impl_.ismoving_ = value;
}
inline void LocationContract::set_ismoving(bool value) {
  _internal_set_ismoving(value);
  // @@protoc_insertion_point(field_set:LocationContract.IsMoving)
}

// repeated .DistanceContract Distances = 9;
inline int LocationContract::_internal_distances_size() const {
  return _impl_.distances_.size();
}
inline int LocationContract::distances_size() const {
  return _internal_distances_size();
}
inline void LocationContract::clear_distances() {
  _impl_.distances_.Clear();
}
inline ::DistanceContract* LocationContract::mutable_distances(int index) {
  // @@protoc_insertion_point(field_mutable:LocationContract.Distances)
  return _impl_.distances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >*
LocationContract::mutable_distances() {
  // @@protoc_insertion_point(field_mutable_list:LocationContract.Distances)
  return &_impl_.distances_;
}
inline const ::DistanceContract& LocationContract::_internal_distances(int index) const {
  return _impl_.distances_.Get(index);
}
inline const ::DistanceContract& LocationContract::distances(int index) const {
  // @@protoc_insertion_point(field_get:LocationContract.Distances)
  return _internal_distances(index);
}
inline ::DistanceContract* LocationContract::_internal_add_distances() {
  return _impl_.distances_.Add();
}
inline ::DistanceContract* LocationContract::add_distances() {
  ::DistanceContract* _add = _internal_add_distances();
  // @@protoc_insertion_point(field_add:LocationContract.Distances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DistanceContract >&
LocationContract::distances() const {
  // @@protoc_insertion_point(field_list:LocationContract.Distances)
  return _impl_.distances_;
}

// repeated int32 LocalizationAreas = 10;
inline int LocationContract::_internal_localizationareas_size() const {
  return _impl_.localizationareas_.size();
}
inline int LocationContract::localizationareas_size() const {
  return _internal_localizationareas_size();
}
inline void LocationContract::clear_localizationareas() {
  _impl_.localizationareas_.Clear();
}
inline int32_t LocationContract::_internal_localizationareas(int index) const {
  return _impl_.localizationareas_.Get(index);
}
inline int32_t LocationContract::localizationareas(int index) const {
  // @@protoc_insertion_point(field_get:LocationContract.LocalizationAreas)
  return _internal_localizationareas(index);
}
inline void LocationContract::set_localizationareas(int index, int32_t value) {
  _impl_.localizationareas_.Set(index, value);
  // @@protoc_insertion_point(field_set:LocationContract.LocalizationAreas)
}
inline void LocationContract::_internal_add_localizationareas(int32_t value) {
  _impl_.localizationareas_.Add(value);
}
inline void LocationContract::add_localizationareas(int32_t value) {
  _internal_add_localizationareas(value);
  // @@protoc_insertion_point(field_add:LocationContract.LocalizationAreas)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LocationContract::_internal_localizationareas() const {
  return _impl_.localizationareas_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LocationContract::localizationareas() const {
  // @@protoc_insertion_point(field_list:LocationContract.LocalizationAreas)
  return _internal_localizationareas();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LocationContract::_internal_mutable_localizationareas() {
  return &_impl_.localizationareas_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LocationContract::mutable_localizationareas() {
  // @@protoc_insertion_point(field_mutable_list:LocationContract.LocalizationAreas)
  return _internal_mutable_localizationareas();
}

// repeated int32 NoGoAreas = 11;
inline int LocationContract::_internal_nogoareas_size() const {
  return _impl_.nogoareas_.size();
}
inline int LocationContract::nogoareas_size() const {
  return _internal_nogoareas_size();
}
inline void LocationContract::clear_nogoareas() {
  _impl_.nogoareas_.Clear();
}
inline int32_t LocationContract::_internal_nogoareas(int index) const {
  return _impl_.nogoareas_.Get(index);
}
inline int32_t LocationContract::nogoareas(int index) const {
  // @@protoc_insertion_point(field_get:LocationContract.NoGoAreas)
  return _internal_nogoareas(index);
}
inline void LocationContract::set_nogoareas(int index, int32_t value) {
  _impl_.nogoareas_.Set(index, value);
  // @@protoc_insertion_point(field_set:LocationContract.NoGoAreas)
}
inline void LocationContract::_internal_add_nogoareas(int32_t value) {
  _impl_.nogoareas_.Add(value);
}
inline void LocationContract::add_nogoareas(int32_t value) {
  _internal_add_nogoareas(value);
  // @@protoc_insertion_point(field_add:LocationContract.NoGoAreas)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LocationContract::_internal_nogoareas() const {
  return _impl_.nogoareas_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
LocationContract::nogoareas() const {
  // @@protoc_insertion_point(field_list:LocationContract.NoGoAreas)
  return _internal_nogoareas();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LocationContract::_internal_mutable_nogoareas() {
  return &_impl_.nogoareas_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
LocationContract::mutable_nogoareas() {
  // @@protoc_insertion_point(field_mutable_list:LocationContract.NoGoAreas)
  return _internal_mutable_nogoareas();
}

// -------------------------------------------------------------------

// DistanceContract

// int32 BeaconId = 1;
inline void DistanceContract::clear_beaconid() {
  _impl_.beaconid_ = 0;
}
inline int32_t DistanceContract::_internal_beaconid() const {
  return _impl_.beaconid_;
}
inline int32_t DistanceContract::beaconid() const {
  // @@protoc_insertion_point(field_get:DistanceContract.BeaconId)
  return _internal_beaconid();
}
inline void DistanceContract::_internal_set_beaconid(int32_t value) {
  
  _impl_.beaconid_ = value;
}
inline void DistanceContract::set_beaconid(int32_t value) {
  _internal_set_beaconid(value);
  // @@protoc_insertion_point(field_set:DistanceContract.BeaconId)
}

// float Distance = 2;
inline void DistanceContract::clear_distance() {
  _impl_.distance_ = 0;
}
inline float DistanceContract::_internal_distance() const {
  return _impl_.distance_;
}
inline float DistanceContract::distance() const {
  // @@protoc_insertion_point(field_get:DistanceContract.Distance)
  return _internal_distance();
}
inline void DistanceContract::_internal_set_distance(float value) {
  
  _impl_.distance_ = value;
}
inline void DistanceContract::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:DistanceContract.Distance)
}

// int32 RSSI = 3;
inline void DistanceContract::clear_rssi() {
  _impl_.rssi_ = 0;
}
inline int32_t DistanceContract::_internal_rssi() const {
  return _impl_.rssi_;
}
inline int32_t DistanceContract::rssi() const {
  // @@protoc_insertion_point(field_get:DistanceContract.RSSI)
  return _internal_rssi();
}
inline void DistanceContract::_internal_set_rssi(int32_t value) {
  
  _impl_.rssi_ = value;
}
inline void DistanceContract::set_rssi(int32_t value) {
  _internal_set_rssi(value);
  // @@protoc_insertion_point(field_set:DistanceContract.RSSI)
}

// -------------------------------------------------------------------

// LoginContract

// string Login = 1;
inline void LoginContract::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& LoginContract::login() const {
  // @@protoc_insertion_point(field_get:LoginContract.Login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginContract::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LoginContract.Login)
}
inline std::string* LoginContract::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:LoginContract.Login)
  return _s;
}
inline const std::string& LoginContract::_internal_login() const {
  return _impl_.login_.Get();
}
inline void LoginContract::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginContract::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginContract::release_login() {
  // @@protoc_insertion_point(field_release:LoginContract.Login)
  return _impl_.login_.Release();
}
inline void LoginContract::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LoginContract.Login)
}

// -------------------------------------------------------------------

// AuthenticationResponseContract

// string Client = 1;
inline void AuthenticationResponseContract::clear_client() {
  _impl_.client_.ClearToEmpty();
}
inline const std::string& AuthenticationResponseContract::client() const {
  // @@protoc_insertion_point(field_get:AuthenticationResponseContract.Client)
  return _internal_client();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticationResponseContract::set_client(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AuthenticationResponseContract.Client)
}
inline std::string* AuthenticationResponseContract::mutable_client() {
  std::string* _s = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:AuthenticationResponseContract.Client)
  return _s;
}
inline const std::string& AuthenticationResponseContract::_internal_client() const {
  return _impl_.client_.Get();
}
inline void AuthenticationResponseContract::_internal_set_client(const std::string& value) {
  
  _impl_.client_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticationResponseContract::_internal_mutable_client() {
  
  return _impl_.client_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticationResponseContract::release_client() {
  // @@protoc_insertion_point(field_release:AuthenticationResponseContract.Client)
  return _impl_.client_.Release();
}
inline void AuthenticationResponseContract::set_allocated_client(std::string* client) {
  if (client != nullptr) {
    
  } else {
    
  }
  _impl_.client_.SetAllocated(client, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_.IsDefault()) {
    _impl_.client_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AuthenticationResponseContract.Client)
}

// string Token = 2;
inline void AuthenticationResponseContract::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AuthenticationResponseContract::token() const {
  // @@protoc_insertion_point(field_get:AuthenticationResponseContract.Token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticationResponseContract::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AuthenticationResponseContract.Token)
}
inline std::string* AuthenticationResponseContract::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:AuthenticationResponseContract.Token)
  return _s;
}
inline const std::string& AuthenticationResponseContract::_internal_token() const {
  return _impl_.token_.Get();
}
inline void AuthenticationResponseContract::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticationResponseContract::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticationResponseContract::release_token() {
  // @@protoc_insertion_point(field_release:AuthenticationResponseContract.Token)
  return _impl_.token_.Release();
}
inline void AuthenticationResponseContract::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AuthenticationResponseContract.Token)
}

// uint64 Expiration = 3;
inline void AuthenticationResponseContract::clear_expiration() {
  _impl_.expiration_ = uint64_t{0u};
}
inline uint64_t AuthenticationResponseContract::_internal_expiration() const {
  return _impl_.expiration_;
}
inline uint64_t AuthenticationResponseContract::expiration() const {
  // @@protoc_insertion_point(field_get:AuthenticationResponseContract.Expiration)
  return _internal_expiration();
}
inline void AuthenticationResponseContract::_internal_set_expiration(uint64_t value) {
  
  _impl_.expiration_ = value;
}
inline void AuthenticationResponseContract::set_expiration(uint64_t value) {
  _internal_set_expiration(value);
  // @@protoc_insertion_point(field_set:AuthenticationResponseContract.Expiration)
}

// uint64 Created = 4;
inline void AuthenticationResponseContract::clear_created() {
  _impl_.created_ = uint64_t{0u};
}
inline uint64_t AuthenticationResponseContract::_internal_created() const {
  return _impl_.created_;
}
inline uint64_t AuthenticationResponseContract::created() const {
  // @@protoc_insertion_point(field_get:AuthenticationResponseContract.Created)
  return _internal_created();
}
inline void AuthenticationResponseContract::_internal_set_created(uint64_t value) {
  
  _impl_.created_ = value;
}
inline void AuthenticationResponseContract::set_created(uint64_t value) {
  _internal_set_created(value);
  // @@protoc_insertion_point(field_set:AuthenticationResponseContract.Created)
}

// string Branch = 5;
inline void AuthenticationResponseContract::clear_branch() {
  _impl_.branch_.ClearToEmpty();
}
inline const std::string& AuthenticationResponseContract::branch() const {
  // @@protoc_insertion_point(field_get:AuthenticationResponseContract.Branch)
  return _internal_branch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthenticationResponseContract::set_branch(ArgT0&& arg0, ArgT... args) {
 
 _impl_.branch_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AuthenticationResponseContract.Branch)
}
inline std::string* AuthenticationResponseContract::mutable_branch() {
  std::string* _s = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:AuthenticationResponseContract.Branch)
  return _s;
}
inline const std::string& AuthenticationResponseContract::_internal_branch() const {
  return _impl_.branch_.Get();
}
inline void AuthenticationResponseContract::_internal_set_branch(const std::string& value) {
  
  _impl_.branch_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthenticationResponseContract::_internal_mutable_branch() {
  
  return _impl_.branch_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthenticationResponseContract::release_branch() {
  // @@protoc_insertion_point(field_release:AuthenticationResponseContract.Branch)
  return _impl_.branch_.Release();
}
inline void AuthenticationResponseContract::set_allocated_branch(std::string* branch) {
  if (branch != nullptr) {
    
  } else {
    
  }
  _impl_.branch_.SetAllocated(branch, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.branch_.IsDefault()) {
    _impl_.branch_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AuthenticationResponseContract.Branch)
}

// -------------------------------------------------------------------

// CredentialContract

// string Client = 1;
inline void CredentialContract::clear_client() {
  _impl_.client_.ClearToEmpty();
}
inline const std::string& CredentialContract::client() const {
  // @@protoc_insertion_point(field_get:CredentialContract.Client)
  return _internal_client();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialContract::set_client(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CredentialContract.Client)
}
inline std::string* CredentialContract::mutable_client() {
  std::string* _s = _internal_mutable_client();
  // @@protoc_insertion_point(field_mutable:CredentialContract.Client)
  return _s;
}
inline const std::string& CredentialContract::_internal_client() const {
  return _impl_.client_.Get();
}
inline void CredentialContract::_internal_set_client(const std::string& value) {
  
  _impl_.client_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialContract::_internal_mutable_client() {
  
  return _impl_.client_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialContract::release_client() {
  // @@protoc_insertion_point(field_release:CredentialContract.Client)
  return _impl_.client_.Release();
}
inline void CredentialContract::set_allocated_client(std::string* client) {
  if (client != nullptr) {
    
  } else {
    
  }
  _impl_.client_.SetAllocated(client, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_.IsDefault()) {
    _impl_.client_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CredentialContract.Client)
}

// string Login = 2;
inline void CredentialContract::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& CredentialContract::login() const {
  // @@protoc_insertion_point(field_get:CredentialContract.Login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialContract::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CredentialContract.Login)
}
inline std::string* CredentialContract::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:CredentialContract.Login)
  return _s;
}
inline const std::string& CredentialContract::_internal_login() const {
  return _impl_.login_.Get();
}
inline void CredentialContract::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialContract::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialContract::release_login() {
  // @@protoc_insertion_point(field_release:CredentialContract.Login)
  return _impl_.login_.Release();
}
inline void CredentialContract::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CredentialContract.Login)
}

// string Password = 3;
inline void CredentialContract::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& CredentialContract::password() const {
  // @@protoc_insertion_point(field_get:CredentialContract.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CredentialContract::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CredentialContract.Password)
}
inline std::string* CredentialContract::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CredentialContract.Password)
  return _s;
}
inline const std::string& CredentialContract::_internal_password() const {
  return _impl_.password_.Get();
}
inline void CredentialContract::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* CredentialContract::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* CredentialContract::release_password() {
  // @@protoc_insertion_point(field_release:CredentialContract.Password)
  return _impl_.password_.Release();
}
inline void CredentialContract::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CredentialContract.Password)
}

// -------------------------------------------------------------------

// PostResponseContract

// bool Success = 1;
inline void PostResponseContract::clear_success() {
  _impl_.success_ = false;
}
inline bool PostResponseContract::_internal_success() const {
  return _impl_.success_;
}
inline bool PostResponseContract::success() const {
  // @@protoc_insertion_point(field_get:PostResponseContract.Success)
  return _internal_success();
}
inline void PostResponseContract::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void PostResponseContract::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:PostResponseContract.Success)
}

// string ErrorMessage = 2;
inline void PostResponseContract::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
}
inline const std::string& PostResponseContract::errormessage() const {
  // @@protoc_insertion_point(field_get:PostResponseContract.ErrorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostResponseContract::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.errormessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PostResponseContract.ErrorMessage)
}
inline std::string* PostResponseContract::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:PostResponseContract.ErrorMessage)
  return _s;
}
inline const std::string& PostResponseContract::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void PostResponseContract::_internal_set_errormessage(const std::string& value) {
  
  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* PostResponseContract::_internal_mutable_errormessage() {
  
  return _impl_.errormessage_.Mutable(GetArenaForAllocation());
}
inline std::string* PostResponseContract::release_errormessage() {
  // @@protoc_insertion_point(field_release:PostResponseContract.ErrorMessage)
  return _impl_.errormessage_.Release();
}
inline void PostResponseContract::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  _impl_.errormessage_.SetAllocated(errormessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.errormessage_.IsDefault()) {
    _impl_.errormessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PostResponseContract.ErrorMessage)
}

// -------------------------------------------------------------------

// GpsItemContract

// int32 Id = 1;
inline void GpsItemContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t GpsItemContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t GpsItemContract::id() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.Id)
  return _internal_id();
}
inline void GpsItemContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void GpsItemContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:GpsItemContract.Id)
}

// int32 SectorId = 2;
inline void GpsItemContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
}
inline int32_t GpsItemContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t GpsItemContract::sectorid() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.SectorId)
  return _internal_sectorid();
}
inline void GpsItemContract::_internal_set_sectorid(int32_t value) {
  
  _impl_.sectorid_ = value;
}
inline void GpsItemContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:GpsItemContract.SectorId)
}

// optional .SectorContract Sector = 3;
inline bool GpsItemContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool GpsItemContract::has_sector() const {
  return _internal_has_sector();
}
inline void GpsItemContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SectorContract& GpsItemContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& GpsItemContract::sector() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.Sector)
  return _internal_sector();
}
inline void GpsItemContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GpsItemContract.Sector)
}
inline ::SectorContract* GpsItemContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* GpsItemContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:GpsItemContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* GpsItemContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* GpsItemContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:GpsItemContract.Sector)
  return _msg;
}
inline void GpsItemContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:GpsItemContract.Sector)
}

// float X = 4;
inline void GpsItemContract::clear_x() {
  _impl_.x_ = 0;
}
inline float GpsItemContract::_internal_x() const {
  return _impl_.x_;
}
inline float GpsItemContract::x() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.X)
  return _internal_x();
}
inline void GpsItemContract::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void GpsItemContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:GpsItemContract.X)
}

// float Y = 5;
inline void GpsItemContract::clear_y() {
  _impl_.y_ = 0;
}
inline float GpsItemContract::_internal_y() const {
  return _impl_.y_;
}
inline float GpsItemContract::y() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.Y)
  return _internal_y();
}
inline void GpsItemContract::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void GpsItemContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:GpsItemContract.Y)
}

// double Latitude = 6;
inline void GpsItemContract::clear_latitude() {
  _impl_.latitude_ = 0;
}
inline double GpsItemContract::_internal_latitude() const {
  return _impl_.latitude_;
}
inline double GpsItemContract::latitude() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.Latitude)
  return _internal_latitude();
}
inline void GpsItemContract::_internal_set_latitude(double value) {
  
  _impl_.latitude_ = value;
}
inline void GpsItemContract::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:GpsItemContract.Latitude)
}

// double Longitude = 7;
inline void GpsItemContract::clear_longitude() {
  _impl_.longitude_ = 0;
}
inline double GpsItemContract::_internal_longitude() const {
  return _impl_.longitude_;
}
inline double GpsItemContract::longitude() const {
  // @@protoc_insertion_point(field_get:GpsItemContract.Longitude)
  return _internal_longitude();
}
inline void GpsItemContract::_internal_set_longitude(double value) {
  
  _impl_.longitude_ = value;
}
inline void GpsItemContract::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:GpsItemContract.Longitude)
}

// -------------------------------------------------------------------

// BarrierContract

// int32 X = 1;
inline void BarrierContract::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t BarrierContract::_internal_x() const {
  return _impl_.x_;
}
inline int32_t BarrierContract::x() const {
  // @@protoc_insertion_point(field_get:BarrierContract.X)
  return _internal_x();
}
inline void BarrierContract::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void BarrierContract::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:BarrierContract.X)
}

// int32 Y = 2;
inline void BarrierContract::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t BarrierContract::_internal_y() const {
  return _impl_.y_;
}
inline int32_t BarrierContract::y() const {
  // @@protoc_insertion_point(field_get:BarrierContract.Y)
  return _internal_y();
}
inline void BarrierContract::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void BarrierContract::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:BarrierContract.Y)
}

// int32 SectorId = 3;
inline void BarrierContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
}
inline int32_t BarrierContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t BarrierContract::sectorid() const {
  // @@protoc_insertion_point(field_get:BarrierContract.SectorId)
  return _internal_sectorid();
}
inline void BarrierContract::_internal_set_sectorid(int32_t value) {
  
  _impl_.sectorid_ = value;
}
inline void BarrierContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:BarrierContract.SectorId)
}

// optional .SectorContract Sector = 4;
inline bool BarrierContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool BarrierContract::has_sector() const {
  return _internal_has_sector();
}
inline void BarrierContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SectorContract& BarrierContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& BarrierContract::sector() const {
  // @@protoc_insertion_point(field_get:BarrierContract.Sector)
  return _internal_sector();
}
inline void BarrierContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BarrierContract.Sector)
}
inline ::SectorContract* BarrierContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* BarrierContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:BarrierContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* BarrierContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* BarrierContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:BarrierContract.Sector)
  return _msg;
}
inline void BarrierContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:BarrierContract.Sector)
}

// int32 BranchId = 5;
inline void BarrierContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t BarrierContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t BarrierContract::branchid() const {
  // @@protoc_insertion_point(field_get:BarrierContract.BranchId)
  return _internal_branchid();
}
inline void BarrierContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void BarrierContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:BarrierContract.BranchId)
}

// optional .BranchContract Branch = 6;
inline bool BarrierContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool BarrierContract::has_branch() const {
  return _internal_has_branch();
}
inline void BarrierContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::BranchContract& BarrierContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& BarrierContract::branch() const {
  // @@protoc_insertion_point(field_get:BarrierContract.Branch)
  return _internal_branch();
}
inline void BarrierContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BarrierContract.Branch)
}
inline ::BranchContract* BarrierContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* BarrierContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:BarrierContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* BarrierContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* BarrierContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:BarrierContract.Branch)
  return _msg;
}
inline void BarrierContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:BarrierContract.Branch)
}

// -------------------------------------------------------------------

// BeaconContract

// int32 Id = 1;
inline void BeaconContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t BeaconContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t BeaconContract::id() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Id)
  return _internal_id();
}
inline void BeaconContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void BeaconContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:BeaconContract.Id)
}

// optional int32 SectorId = 2;
inline bool BeaconContract::_internal_has_sectorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BeaconContract::has_sectorid() const {
  return _internal_has_sectorid();
}
inline void BeaconContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t BeaconContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t BeaconContract::sectorid() const {
  // @@protoc_insertion_point(field_get:BeaconContract.SectorId)
  return _internal_sectorid();
}
inline void BeaconContract::_internal_set_sectorid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sectorid_ = value;
}
inline void BeaconContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:BeaconContract.SectorId)
}

// optional .SectorContract Sector = 3;
inline bool BeaconContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool BeaconContract::has_sector() const {
  return _internal_has_sector();
}
inline void BeaconContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SectorContract& BeaconContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& BeaconContract::sector() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Sector)
  return _internal_sector();
}
inline void BeaconContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BeaconContract.Sector)
}
inline ::SectorContract* BeaconContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* BeaconContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:BeaconContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* BeaconContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* BeaconContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:BeaconContract.Sector)
  return _msg;
}
inline void BeaconContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:BeaconContract.Sector)
}

// int32 BranchId = 4;
inline void BeaconContract::clear_branchid() {
  _impl_.branchid_ = 0;
}
inline int32_t BeaconContract::_internal_branchid() const {
  return _impl_.branchid_;
}
inline int32_t BeaconContract::branchid() const {
  // @@protoc_insertion_point(field_get:BeaconContract.BranchId)
  return _internal_branchid();
}
inline void BeaconContract::_internal_set_branchid(int32_t value) {
  
  _impl_.branchid_ = value;
}
inline void BeaconContract::set_branchid(int32_t value) {
  _internal_set_branchid(value);
  // @@protoc_insertion_point(field_set:BeaconContract.BranchId)
}

// optional .BranchContract Branch = 5;
inline bool BeaconContract::_internal_has_branch() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.branch_ != nullptr);
  return value;
}
inline bool BeaconContract::has_branch() const {
  return _internal_has_branch();
}
inline void BeaconContract::clear_branch() {
  if (_impl_.branch_ != nullptr) _impl_.branch_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::BranchContract& BeaconContract::_internal_branch() const {
  const ::BranchContract* p = _impl_.branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::BranchContract&>(
      ::_BranchContract_default_instance_);
}
inline const ::BranchContract& BeaconContract::branch() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Branch)
  return _internal_branch();
}
inline void BeaconContract::unsafe_arena_set_allocated_branch(
    ::BranchContract* branch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.branch_);
  }
  _impl_.branch_ = branch;
  if (branch) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BeaconContract.Branch)
}
inline ::BranchContract* BeaconContract::release_branch() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::BranchContract* BeaconContract::unsafe_arena_release_branch() {
  // @@protoc_insertion_point(field_release:BeaconContract.Branch)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::BranchContract* temp = _impl_.branch_;
  _impl_.branch_ = nullptr;
  return temp;
}
inline ::BranchContract* BeaconContract::_internal_mutable_branch() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::BranchContract>(GetArenaForAllocation());
    _impl_.branch_ = p;
  }
  return _impl_.branch_;
}
inline ::BranchContract* BeaconContract::mutable_branch() {
  ::BranchContract* _msg = _internal_mutable_branch();
  // @@protoc_insertion_point(field_mutable:BeaconContract.Branch)
  return _msg;
}
inline void BeaconContract::set_allocated_branch(::BranchContract* branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.branch_;
  }
  if (branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(branch);
    if (message_arena != submessage_arena) {
      branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.branch_ = branch;
  // @@protoc_insertion_point(field_set_allocated:BeaconContract.Branch)
}

// string Mac = 6;
inline void BeaconContract::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& BeaconContract::mac() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeaconContract::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BeaconContract.Mac)
}
inline std::string* BeaconContract::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:BeaconContract.Mac)
  return _s;
}
inline const std::string& BeaconContract::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void BeaconContract::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* BeaconContract::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* BeaconContract::release_mac() {
  // @@protoc_insertion_point(field_release:BeaconContract.Mac)
  return _impl_.mac_.Release();
}
inline void BeaconContract::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BeaconContract.Mac)
}

// optional float X = 7;
inline bool BeaconContract::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BeaconContract::has_x() const {
  return _internal_has_x();
}
inline void BeaconContract::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float BeaconContract::_internal_x() const {
  return _impl_.x_;
}
inline float BeaconContract::x() const {
  // @@protoc_insertion_point(field_get:BeaconContract.X)
  return _internal_x();
}
inline void BeaconContract::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.x_ = value;
}
inline void BeaconContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:BeaconContract.X)
}

// optional float Y = 8;
inline bool BeaconContract::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BeaconContract::has_y() const {
  return _internal_has_y();
}
inline void BeaconContract::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float BeaconContract::_internal_y() const {
  return _impl_.y_;
}
inline float BeaconContract::y() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Y)
  return _internal_y();
}
inline void BeaconContract::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.y_ = value;
}
inline void BeaconContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:BeaconContract.Y)
}

// optional float Z = 9;
inline bool BeaconContract::_internal_has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BeaconContract::has_z() const {
  return _internal_has_z();
}
inline void BeaconContract::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float BeaconContract::_internal_z() const {
  return _impl_.z_;
}
inline float BeaconContract::z() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Z)
  return _internal_z();
}
inline void BeaconContract::_internal_set_z(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.z_ = value;
}
inline void BeaconContract::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:BeaconContract.Z)
}

// string Title = 10;
inline void BeaconContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& BeaconContract::title() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeaconContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BeaconContract.Title)
}
inline std::string* BeaconContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:BeaconContract.Title)
  return _s;
}
inline const std::string& BeaconContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void BeaconContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* BeaconContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* BeaconContract::release_title() {
  // @@protoc_insertion_point(field_release:BeaconContract.Title)
  return _impl_.title_.Release();
}
inline void BeaconContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BeaconContract.Title)
}

// bool Active = 11;
inline void BeaconContract::clear_active() {
  _impl_.active_ = false;
}
inline bool BeaconContract::_internal_active() const {
  return _impl_.active_;
}
inline bool BeaconContract::active() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Active)
  return _internal_active();
}
inline void BeaconContract::_internal_set_active(bool value) {
  
  _impl_.active_ = value;
}
inline void BeaconContract::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:BeaconContract.Active)
}

// optional int32 TypeId = 12;
inline bool BeaconContract::_internal_has_typeid_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BeaconContract::has_typeid_() const {
  return _internal_has_typeid_();
}
inline void BeaconContract::clear_typeid_() {
  _impl_.typeid__ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t BeaconContract::_internal_typeid_() const {
  return _impl_.typeid__;
}
inline int32_t BeaconContract::typeid_() const {
  // @@protoc_insertion_point(field_get:BeaconContract.TypeId)
  return _internal_typeid_();
}
inline void BeaconContract::_internal_set_typeid_(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.typeid__ = value;
}
inline void BeaconContract::set_typeid_(int32_t value) {
  _internal_set_typeid_(value);
  // @@protoc_insertion_point(field_set:BeaconContract.TypeId)
}

// bool Position = 14;
inline void BeaconContract::clear_position() {
  _impl_.position_ = false;
}
inline bool BeaconContract::_internal_position() const {
  return _impl_.position_;
}
inline bool BeaconContract::position() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Position)
  return _internal_position();
}
inline void BeaconContract::_internal_set_position(bool value) {
  
  _impl_.position_ = value;
}
inline void BeaconContract::set_position(bool value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:BeaconContract.Position)
}

// bool Geofence = 15;
inline void BeaconContract::clear_geofence() {
  _impl_.geofence_ = false;
}
inline bool BeaconContract::_internal_geofence() const {
  return _impl_.geofence_;
}
inline bool BeaconContract::geofence() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Geofence)
  return _internal_geofence();
}
inline void BeaconContract::_internal_set_geofence(bool value) {
  
  _impl_.geofence_ = value;
}
inline void BeaconContract::set_geofence(bool value) {
  _internal_set_geofence(value);
  // @@protoc_insertion_point(field_set:BeaconContract.Geofence)
}

// optional float GeofenceRange = 16;
inline bool BeaconContract::_internal_has_geofencerange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BeaconContract::has_geofencerange() const {
  return _internal_has_geofencerange();
}
inline void BeaconContract::clear_geofencerange() {
  _impl_.geofencerange_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float BeaconContract::_internal_geofencerange() const {
  return _impl_.geofencerange_;
}
inline float BeaconContract::geofencerange() const {
  // @@protoc_insertion_point(field_get:BeaconContract.GeofenceRange)
  return _internal_geofencerange();
}
inline void BeaconContract::_internal_set_geofencerange(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.geofencerange_ = value;
}
inline void BeaconContract::set_geofencerange(float value) {
  _internal_set_geofencerange(value);
  // @@protoc_insertion_point(field_set:BeaconContract.GeofenceRange)
}

// string Cluster = 17;
inline void BeaconContract::clear_cluster() {
  _impl_.cluster_.ClearToEmpty();
}
inline const std::string& BeaconContract::cluster() const {
  // @@protoc_insertion_point(field_get:BeaconContract.Cluster)
  return _internal_cluster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BeaconContract::set_cluster(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cluster_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BeaconContract.Cluster)
}
inline std::string* BeaconContract::mutable_cluster() {
  std::string* _s = _internal_mutable_cluster();
  // @@protoc_insertion_point(field_mutable:BeaconContract.Cluster)
  return _s;
}
inline const std::string& BeaconContract::_internal_cluster() const {
  return _impl_.cluster_.Get();
}
inline void BeaconContract::_internal_set_cluster(const std::string& value) {
  
  _impl_.cluster_.Set(value, GetArenaForAllocation());
}
inline std::string* BeaconContract::_internal_mutable_cluster() {
  
  return _impl_.cluster_.Mutable(GetArenaForAllocation());
}
inline std::string* BeaconContract::release_cluster() {
  // @@protoc_insertion_point(field_release:BeaconContract.Cluster)
  return _impl_.cluster_.Release();
}
inline void BeaconContract::set_allocated_cluster(std::string* cluster) {
  if (cluster != nullptr) {
    
  } else {
    
  }
  _impl_.cluster_.SetAllocated(cluster, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cluster_.IsDefault()) {
    _impl_.cluster_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BeaconContract.Cluster)
}

// optional int64 LastTimeOnline = 18;
inline bool BeaconContract::_internal_has_lasttimeonline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BeaconContract::has_lasttimeonline() const {
  return _internal_has_lasttimeonline();
}
inline void BeaconContract::clear_lasttimeonline() {
  _impl_.lasttimeonline_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t BeaconContract::_internal_lasttimeonline() const {
  return _impl_.lasttimeonline_;
}
inline int64_t BeaconContract::lasttimeonline() const {
  // @@protoc_insertion_point(field_get:BeaconContract.LastTimeOnline)
  return _internal_lasttimeonline();
}
inline void BeaconContract::_internal_set_lasttimeonline(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.lasttimeonline_ = value;
}
inline void BeaconContract::set_lasttimeonline(int64_t value) {
  _internal_set_lasttimeonline(value);
  // @@protoc_insertion_point(field_set:BeaconContract.LastTimeOnline)
}

// bool UseGps = 19;
inline void BeaconContract::clear_usegps() {
  _impl_.usegps_ = false;
}
inline bool BeaconContract::_internal_usegps() const {
  return _impl_.usegps_;
}
inline bool BeaconContract::usegps() const {
  // @@protoc_insertion_point(field_get:BeaconContract.UseGps)
  return _internal_usegps();
}
inline void BeaconContract::_internal_set_usegps(bool value) {
  
  _impl_.usegps_ = value;
}
inline void BeaconContract::set_usegps(bool value) {
  _internal_set_usegps(value);
  // @@protoc_insertion_point(field_set:BeaconContract.UseGps)
}

// -------------------------------------------------------------------

// BeaconPositionContract

// int32 Id = 1;
inline void BeaconPositionContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t BeaconPositionContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t BeaconPositionContract::id() const {
  // @@protoc_insertion_point(field_get:BeaconPositionContract.Id)
  return _internal_id();
}
inline void BeaconPositionContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void BeaconPositionContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:BeaconPositionContract.Id)
}

// optional float X = 2;
inline bool BeaconPositionContract::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BeaconPositionContract::has_x() const {
  return _internal_has_x();
}
inline void BeaconPositionContract::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float BeaconPositionContract::_internal_x() const {
  return _impl_.x_;
}
inline float BeaconPositionContract::x() const {
  // @@protoc_insertion_point(field_get:BeaconPositionContract.X)
  return _internal_x();
}
inline void BeaconPositionContract::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void BeaconPositionContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:BeaconPositionContract.X)
}

// optional float Y = 3;
inline bool BeaconPositionContract::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BeaconPositionContract::has_y() const {
  return _internal_has_y();
}
inline void BeaconPositionContract::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float BeaconPositionContract::_internal_y() const {
  return _impl_.y_;
}
inline float BeaconPositionContract::y() const {
  // @@protoc_insertion_point(field_get:BeaconPositionContract.Y)
  return _internal_y();
}
inline void BeaconPositionContract::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void BeaconPositionContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:BeaconPositionContract.Y)
}

// -------------------------------------------------------------------

// SensorContract

// int32 Id = 1;
inline void SensorContract::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t SensorContract::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SensorContract::id() const {
  // @@protoc_insertion_point(field_get:SensorContract.Id)
  return _internal_id();
}
inline void SensorContract::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void SensorContract::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:SensorContract.Id)
}

// string Login = 2;
inline void SensorContract::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& SensorContract::login() const {
  // @@protoc_insertion_point(field_get:SensorContract.Login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorContract::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorContract.Login)
}
inline std::string* SensorContract::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:SensorContract.Login)
  return _s;
}
inline const std::string& SensorContract::_internal_login() const {
  return _impl_.login_.Get();
}
inline void SensorContract::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorContract::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorContract::release_login() {
  // @@protoc_insertion_point(field_release:SensorContract.Login)
  return _impl_.login_.Release();
}
inline void SensorContract::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Login)
}

// string Title = 3;
inline void SensorContract::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& SensorContract::title() const {
  // @@protoc_insertion_point(field_get:SensorContract.Title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorContract::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorContract.Title)
}
inline std::string* SensorContract::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:SensorContract.Title)
  return _s;
}
inline const std::string& SensorContract::_internal_title() const {
  return _impl_.title_.Get();
}
inline void SensorContract::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorContract::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorContract::release_title() {
  // @@protoc_insertion_point(field_release:SensorContract.Title)
  return _impl_.title_.Release();
}
inline void SensorContract::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Title)
}

// string Mac = 4;
inline void SensorContract::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& SensorContract::mac() const {
  // @@protoc_insertion_point(field_get:SensorContract.Mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorContract::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorContract.Mac)
}
inline std::string* SensorContract::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:SensorContract.Mac)
  return _s;
}
inline const std::string& SensorContract::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void SensorContract::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorContract::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorContract::release_mac() {
  // @@protoc_insertion_point(field_release:SensorContract.Mac)
  return _impl_.mac_.Release();
}
inline void SensorContract::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Mac)
}

// string Note = 5;
inline void SensorContract::clear_note() {
  _impl_.note_.ClearToEmpty();
}
inline const std::string& SensorContract::note() const {
  // @@protoc_insertion_point(field_get:SensorContract.Note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorContract::set_note(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorContract.Note)
}
inline std::string* SensorContract::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:SensorContract.Note)
  return _s;
}
inline const std::string& SensorContract::_internal_note() const {
  return _impl_.note_.Get();
}
inline void SensorContract::_internal_set_note(const std::string& value) {
  
  _impl_.note_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorContract::_internal_mutable_note() {
  
  return _impl_.note_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorContract::release_note() {
  // @@protoc_insertion_point(field_release:SensorContract.Note)
  return _impl_.note_.Release();
}
inline void SensorContract::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  _impl_.note_.SetAllocated(note, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Note)
}

// optional float X = 6;
inline bool SensorContract::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorContract::has_x() const {
  return _internal_has_x();
}
inline void SensorContract::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float SensorContract::_internal_x() const {
  return _impl_.x_;
}
inline float SensorContract::x() const {
  // @@protoc_insertion_point(field_get:SensorContract.X)
  return _internal_x();
}
inline void SensorContract::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.x_ = value;
}
inline void SensorContract::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:SensorContract.X)
}

// optional float y = 7;
inline bool SensorContract::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SensorContract::has_y() const {
  return _internal_has_y();
}
inline void SensorContract::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SensorContract::_internal_y() const {
  return _impl_.y_;
}
inline float SensorContract::y() const {
  // @@protoc_insertion_point(field_get:SensorContract.y)
  return _internal_y();
}
inline void SensorContract::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.y_ = value;
}
inline void SensorContract::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:SensorContract.y)
}

// optional float Battery = 8;
inline bool SensorContract::_internal_has_battery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SensorContract::has_battery() const {
  return _internal_has_battery();
}
inline void SensorContract::clear_battery() {
  _impl_.battery_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float SensorContract::_internal_battery() const {
  return _impl_.battery_;
}
inline float SensorContract::battery() const {
  // @@protoc_insertion_point(field_get:SensorContract.Battery)
  return _internal_battery();
}
inline void SensorContract::_internal_set_battery(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.battery_ = value;
}
inline void SensorContract::set_battery(float value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:SensorContract.Battery)
}

// optional int32 SectorId = 9;
inline bool SensorContract::_internal_has_sectorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SensorContract::has_sectorid() const {
  return _internal_has_sectorid();
}
inline void SensorContract::clear_sectorid() {
  _impl_.sectorid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t SensorContract::_internal_sectorid() const {
  return _impl_.sectorid_;
}
inline int32_t SensorContract::sectorid() const {
  // @@protoc_insertion_point(field_get:SensorContract.SectorId)
  return _internal_sectorid();
}
inline void SensorContract::_internal_set_sectorid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sectorid_ = value;
}
inline void SensorContract::set_sectorid(int32_t value) {
  _internal_set_sectorid(value);
  // @@protoc_insertion_point(field_set:SensorContract.SectorId)
}

// optional .SectorContract Sector = 10;
inline bool SensorContract::_internal_has_sector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sector_ != nullptr);
  return value;
}
inline bool SensorContract::has_sector() const {
  return _internal_has_sector();
}
inline void SensorContract::clear_sector() {
  if (_impl_.sector_ != nullptr) _impl_.sector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SectorContract& SensorContract::_internal_sector() const {
  const ::SectorContract* p = _impl_.sector_;
  return p != nullptr ? *p : reinterpret_cast<const ::SectorContract&>(
      ::_SectorContract_default_instance_);
}
inline const ::SectorContract& SensorContract::sector() const {
  // @@protoc_insertion_point(field_get:SensorContract.Sector)
  return _internal_sector();
}
inline void SensorContract::unsafe_arena_set_allocated_sector(
    ::SectorContract* sector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sector_);
  }
  _impl_.sector_ = sector;
  if (sector) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SensorContract.Sector)
}
inline ::SectorContract* SensorContract::release_sector() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SectorContract* SensorContract::unsafe_arena_release_sector() {
  // @@protoc_insertion_point(field_release:SensorContract.Sector)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SectorContract* temp = _impl_.sector_;
  _impl_.sector_ = nullptr;
  return temp;
}
inline ::SectorContract* SensorContract::_internal_mutable_sector() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.sector_ == nullptr) {
    auto* p = CreateMaybeMessage<::SectorContract>(GetArenaForAllocation());
    _impl_.sector_ = p;
  }
  return _impl_.sector_;
}
inline ::SectorContract* SensorContract::mutable_sector() {
  ::SectorContract* _msg = _internal_mutable_sector();
  // @@protoc_insertion_point(field_mutable:SensorContract.Sector)
  return _msg;
}
inline void SensorContract::set_allocated_sector(::SectorContract* sector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sector_;
  }
  if (sector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sector);
    if (message_arena != submessage_arena) {
      sector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sector, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sector_ = sector;
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Sector)
}

// repeated .SensorDataContract SensorData = 11;
inline int SensorContract::_internal_sensordata_size() const {
  return _impl_.sensordata_.size();
}
inline int SensorContract::sensordata_size() const {
  return _internal_sensordata_size();
}
inline void SensorContract::clear_sensordata() {
  _impl_.sensordata_.Clear();
}
inline ::SensorDataContract* SensorContract::mutable_sensordata(int index) {
  // @@protoc_insertion_point(field_mutable:SensorContract.SensorData)
  return _impl_.sensordata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >*
SensorContract::mutable_sensordata() {
  // @@protoc_insertion_point(field_mutable_list:SensorContract.SensorData)
  return &_impl_.sensordata_;
}
inline const ::SensorDataContract& SensorContract::_internal_sensordata(int index) const {
  return _impl_.sensordata_.Get(index);
}
inline const ::SensorDataContract& SensorContract::sensordata(int index) const {
  // @@protoc_insertion_point(field_get:SensorContract.SensorData)
  return _internal_sensordata(index);
}
inline ::SensorDataContract* SensorContract::_internal_add_sensordata() {
  return _impl_.sensordata_.Add();
}
inline ::SensorDataContract* SensorContract::add_sensordata() {
  ::SensorDataContract* _add = _internal_add_sensordata();
  // @@protoc_insertion_point(field_add:SensorContract.SensorData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataContract >&
SensorContract::sensordata() const {
  // @@protoc_insertion_point(field_list:SensorContract.SensorData)
  return _impl_.sensordata_;
}

// optional int32 AreaId = 12;
inline bool SensorContract::_internal_has_areaid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SensorContract::has_areaid() const {
  return _internal_has_areaid();
}
inline void SensorContract::clear_areaid() {
  _impl_.areaid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t SensorContract::_internal_areaid() const {
  return _impl_.areaid_;
}
inline int32_t SensorContract::areaid() const {
  // @@protoc_insertion_point(field_get:SensorContract.AreaId)
  return _internal_areaid();
}
inline void SensorContract::_internal_set_areaid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.areaid_ = value;
}
inline void SensorContract::set_areaid(int32_t value) {
  _internal_set_areaid(value);
  // @@protoc_insertion_point(field_set:SensorContract.AreaId)
}

// optional .AreaContract Area = 13;
inline bool SensorContract::_internal_has_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.area_ != nullptr);
  return value;
}
inline bool SensorContract::has_area() const {
  return _internal_has_area();
}
inline void SensorContract::clear_area() {
  if (_impl_.area_ != nullptr) _impl_.area_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::AreaContract& SensorContract::_internal_area() const {
  const ::AreaContract* p = _impl_.area_;
  return p != nullptr ? *p : reinterpret_cast<const ::AreaContract&>(
      ::_AreaContract_default_instance_);
}
inline const ::AreaContract& SensorContract::area() const {
  // @@protoc_insertion_point(field_get:SensorContract.Area)
  return _internal_area();
}
inline void SensorContract::unsafe_arena_set_allocated_area(
    ::AreaContract* area) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.area_);
  }
  _impl_.area_ = area;
  if (area) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SensorContract.Area)
}
inline ::AreaContract* SensorContract::release_area() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::AreaContract* temp = _impl_.area_;
  _impl_.area_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AreaContract* SensorContract::unsafe_arena_release_area() {
  // @@protoc_insertion_point(field_release:SensorContract.Area)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::AreaContract* temp = _impl_.area_;
  _impl_.area_ = nullptr;
  return temp;
}
inline ::AreaContract* SensorContract::_internal_mutable_area() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.area_ == nullptr) {
    auto* p = CreateMaybeMessage<::AreaContract>(GetArenaForAllocation());
    _impl_.area_ = p;
  }
  return _impl_.area_;
}
inline ::AreaContract* SensorContract::mutable_area() {
  ::AreaContract* _msg = _internal_mutable_area();
  // @@protoc_insertion_point(field_mutable:SensorContract.Area)
  return _msg;
}
inline void SensorContract::set_allocated_area(::AreaContract* area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.area_;
  }
  if (area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(area);
    if (message_arena != submessage_arena) {
      area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.area_ = area;
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Area)
}

// string Password = 14;
inline void SensorContract::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& SensorContract::password() const {
  // @@protoc_insertion_point(field_get:SensorContract.Password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorContract::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorContract.Password)
}
inline std::string* SensorContract::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:SensorContract.Password)
  return _s;
}
inline const std::string& SensorContract::_internal_password() const {
  return _impl_.password_.Get();
}
inline void SensorContract::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorContract::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorContract::release_password() {
  // @@protoc_insertion_point(field_release:SensorContract.Password)
  return _impl_.password_.Release();
}
inline void SensorContract::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorContract.Password)
}

// -------------------------------------------------------------------

// SensorDataContract

// string Quantity = 1;
inline void SensorDataContract::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& SensorDataContract::quantity() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.Quantity)
  return _internal_quantity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataContract::set_quantity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.quantity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataContract.Quantity)
}
inline std::string* SensorDataContract::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:SensorDataContract.Quantity)
  return _s;
}
inline const std::string& SensorDataContract::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void SensorDataContract::_internal_set_quantity(const std::string& value) {
  
  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataContract::_internal_mutable_quantity() {
  
  return _impl_.quantity_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataContract::release_quantity() {
  // @@protoc_insertion_point(field_release:SensorDataContract.Quantity)
  return _impl_.quantity_.Release();
}
inline void SensorDataContract::set_allocated_quantity(std::string* quantity) {
  if (quantity != nullptr) {
    
  } else {
    
  }
  _impl_.quantity_.SetAllocated(quantity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.quantity_.IsDefault()) {
    _impl_.quantity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataContract.Quantity)
}

// string Value = 2;
inline void SensorDataContract::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SensorDataContract::value() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.Value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataContract::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataContract.Value)
}
inline std::string* SensorDataContract::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:SensorDataContract.Value)
  return _s;
}
inline const std::string& SensorDataContract::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SensorDataContract::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataContract::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataContract::release_value() {
  // @@protoc_insertion_point(field_release:SensorDataContract.Value)
  return _impl_.value_.Release();
}
inline void SensorDataContract::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataContract.Value)
}

// string Unit = 3;
inline void SensorDataContract::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& SensorDataContract::unit() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.Unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataContract::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataContract.Unit)
}
inline std::string* SensorDataContract::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:SensorDataContract.Unit)
  return _s;
}
inline const std::string& SensorDataContract::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void SensorDataContract::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataContract::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataContract::release_unit() {
  // @@protoc_insertion_point(field_release:SensorDataContract.Unit)
  return _impl_.unit_.Release();
}
inline void SensorDataContract::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataContract.Unit)
}

// string DataType = 4;
inline void SensorDataContract::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& SensorDataContract::datatype() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.DataType)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataContract::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataContract.DataType)
}
inline std::string* SensorDataContract::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:SensorDataContract.DataType)
  return _s;
}
inline const std::string& SensorDataContract::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void SensorDataContract::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataContract::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataContract::release_datatype() {
  // @@protoc_insertion_point(field_release:SensorDataContract.DataType)
  return _impl_.datatype_.Release();
}
inline void SensorDataContract::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataContract.DataType)
}

// int64 Timestamp = 5;
inline void SensorDataContract::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t SensorDataContract::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t SensorDataContract::timestamp() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.Timestamp)
  return _internal_timestamp();
}
inline void SensorDataContract::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void SensorDataContract::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SensorDataContract.Timestamp)
}

// .RangeContract Range = 6;
inline bool SensorDataContract::_internal_has_range() const {
  return this != internal_default_instance() && _impl_.range_ != nullptr;
}
inline bool SensorDataContract::has_range() const {
  return _internal_has_range();
}
inline void SensorDataContract::clear_range() {
  if (GetArenaForAllocation() == nullptr && _impl_.range_ != nullptr) {
    delete _impl_.range_;
  }
  _impl_.range_ = nullptr;
}
inline const ::RangeContract& SensorDataContract::_internal_range() const {
  const ::RangeContract* p = _impl_.range_;
  return p != nullptr ? *p : reinterpret_cast<const ::RangeContract&>(
      ::_RangeContract_default_instance_);
}
inline const ::RangeContract& SensorDataContract::range() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.Range)
  return _internal_range();
}
inline void SensorDataContract::unsafe_arena_set_allocated_range(
    ::RangeContract* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.range_);
  }
  _impl_.range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SensorDataContract.Range)
}
inline ::RangeContract* SensorDataContract::release_range() {
  
  ::RangeContract* temp = _impl_.range_;
  _impl_.range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RangeContract* SensorDataContract::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:SensorDataContract.Range)
  
  ::RangeContract* temp = _impl_.range_;
  _impl_.range_ = nullptr;
  return temp;
}
inline ::RangeContract* SensorDataContract::_internal_mutable_range() {
  
  if (_impl_.range_ == nullptr) {
    auto* p = CreateMaybeMessage<::RangeContract>(GetArenaForAllocation());
    _impl_.range_ = p;
  }
  return _impl_.range_;
}
inline ::RangeContract* SensorDataContract::mutable_range() {
  ::RangeContract* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:SensorDataContract.Range)
  return _msg;
}
inline void SensorDataContract::set_allocated_range(::RangeContract* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.range_ = range;
  // @@protoc_insertion_point(field_set_allocated:SensorDataContract.Range)
}

// int32 Index = 7;
inline void SensorDataContract::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t SensorDataContract::_internal_index() const {
  return _impl_.index_;
}
inline int32_t SensorDataContract::index() const {
  // @@protoc_insertion_point(field_get:SensorDataContract.Index)
  return _internal_index();
}
inline void SensorDataContract::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void SensorDataContract::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:SensorDataContract.Index)
}

// -------------------------------------------------------------------

// SensorBatchContract

// string Login = 1;
inline void SensorBatchContract::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& SensorBatchContract::login() const {
  // @@protoc_insertion_point(field_get:SensorBatchContract.Login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorBatchContract::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorBatchContract.Login)
}
inline std::string* SensorBatchContract::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:SensorBatchContract.Login)
  return _s;
}
inline const std::string& SensorBatchContract::_internal_login() const {
  return _impl_.login_.Get();
}
inline void SensorBatchContract::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorBatchContract::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorBatchContract::release_login() {
  // @@protoc_insertion_point(field_release:SensorBatchContract.Login)
  return _impl_.login_.Release();
}
inline void SensorBatchContract::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorBatchContract.Login)
}

// repeated .SensorDataBatchContract SensorData = 2;
inline int SensorBatchContract::_internal_sensordata_size() const {
  return _impl_.sensordata_.size();
}
inline int SensorBatchContract::sensordata_size() const {
  return _internal_sensordata_size();
}
inline void SensorBatchContract::clear_sensordata() {
  _impl_.sensordata_.Clear();
}
inline ::SensorDataBatchContract* SensorBatchContract::mutable_sensordata(int index) {
  // @@protoc_insertion_point(field_mutable:SensorBatchContract.SensorData)
  return _impl_.sensordata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >*
SensorBatchContract::mutable_sensordata() {
  // @@protoc_insertion_point(field_mutable_list:SensorBatchContract.SensorData)
  return &_impl_.sensordata_;
}
inline const ::SensorDataBatchContract& SensorBatchContract::_internal_sensordata(int index) const {
  return _impl_.sensordata_.Get(index);
}
inline const ::SensorDataBatchContract& SensorBatchContract::sensordata(int index) const {
  // @@protoc_insertion_point(field_get:SensorBatchContract.SensorData)
  return _internal_sensordata(index);
}
inline ::SensorDataBatchContract* SensorBatchContract::_internal_add_sensordata() {
  return _impl_.sensordata_.Add();
}
inline ::SensorDataBatchContract* SensorBatchContract::add_sensordata() {
  ::SensorDataBatchContract* _add = _internal_add_sensordata();
  // @@protoc_insertion_point(field_add:SensorBatchContract.SensorData)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SensorDataBatchContract >&
SensorBatchContract::sensordata() const {
  // @@protoc_insertion_point(field_list:SensorBatchContract.SensorData)
  return _impl_.sensordata_;
}

// -------------------------------------------------------------------

// SensorDataBatchContract

// int64 Timestamp = 1;
inline void SensorDataBatchContract::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t SensorDataBatchContract::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t SensorDataBatchContract::timestamp() const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContract.Timestamp)
  return _internal_timestamp();
}
inline void SensorDataBatchContract::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void SensorDataBatchContract::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:SensorDataBatchContract.Timestamp)
}

// string Quantity = 2;
inline void SensorDataBatchContract::clear_quantity() {
  _impl_.quantity_.ClearToEmpty();
}
inline const std::string& SensorDataBatchContract::quantity() const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContract.Quantity)
  return _internal_quantity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataBatchContract::set_quantity(ArgT0&& arg0, ArgT... args) {
 
 _impl_.quantity_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataBatchContract.Quantity)
}
inline std::string* SensorDataBatchContract::mutable_quantity() {
  std::string* _s = _internal_mutable_quantity();
  // @@protoc_insertion_point(field_mutable:SensorDataBatchContract.Quantity)
  return _s;
}
inline const std::string& SensorDataBatchContract::_internal_quantity() const {
  return _impl_.quantity_.Get();
}
inline void SensorDataBatchContract::_internal_set_quantity(const std::string& value) {
  
  _impl_.quantity_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::_internal_mutable_quantity() {
  
  return _impl_.quantity_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::release_quantity() {
  // @@protoc_insertion_point(field_release:SensorDataBatchContract.Quantity)
  return _impl_.quantity_.Release();
}
inline void SensorDataBatchContract::set_allocated_quantity(std::string* quantity) {
  if (quantity != nullptr) {
    
  } else {
    
  }
  _impl_.quantity_.SetAllocated(quantity, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.quantity_.IsDefault()) {
    _impl_.quantity_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataBatchContract.Quantity)
}

// string Value = 3;
inline void SensorDataBatchContract::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SensorDataBatchContract::value() const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContract.Value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataBatchContract::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataBatchContract.Value)
}
inline std::string* SensorDataBatchContract::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:SensorDataBatchContract.Value)
  return _s;
}
inline const std::string& SensorDataBatchContract::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SensorDataBatchContract::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::release_value() {
  // @@protoc_insertion_point(field_release:SensorDataBatchContract.Value)
  return _impl_.value_.Release();
}
inline void SensorDataBatchContract::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataBatchContract.Value)
}

// string Unit = 4;
inline void SensorDataBatchContract::clear_unit() {
  _impl_.unit_.ClearToEmpty();
}
inline const std::string& SensorDataBatchContract::unit() const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContract.Unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataBatchContract::set_unit(ArgT0&& arg0, ArgT... args) {
 
 _impl_.unit_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataBatchContract.Unit)
}
inline std::string* SensorDataBatchContract::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:SensorDataBatchContract.Unit)
  return _s;
}
inline const std::string& SensorDataBatchContract::_internal_unit() const {
  return _impl_.unit_.Get();
}
inline void SensorDataBatchContract::_internal_set_unit(const std::string& value) {
  
  _impl_.unit_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::_internal_mutable_unit() {
  
  return _impl_.unit_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::release_unit() {
  // @@protoc_insertion_point(field_release:SensorDataBatchContract.Unit)
  return _impl_.unit_.Release();
}
inline void SensorDataBatchContract::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    
  } else {
    
  }
  _impl_.unit_.SetAllocated(unit, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.unit_.IsDefault()) {
    _impl_.unit_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataBatchContract.Unit)
}

// string DataType = 5;
inline void SensorDataBatchContract::clear_datatype() {
  _impl_.datatype_.ClearToEmpty();
}
inline const std::string& SensorDataBatchContract::datatype() const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContract.DataType)
  return _internal_datatype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorDataBatchContract::set_datatype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datatype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorDataBatchContract.DataType)
}
inline std::string* SensorDataBatchContract::mutable_datatype() {
  std::string* _s = _internal_mutable_datatype();
  // @@protoc_insertion_point(field_mutable:SensorDataBatchContract.DataType)
  return _s;
}
inline const std::string& SensorDataBatchContract::_internal_datatype() const {
  return _impl_.datatype_.Get();
}
inline void SensorDataBatchContract::_internal_set_datatype(const std::string& value) {
  
  _impl_.datatype_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::_internal_mutable_datatype() {
  
  return _impl_.datatype_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorDataBatchContract::release_datatype() {
  // @@protoc_insertion_point(field_release:SensorDataBatchContract.DataType)
  return _impl_.datatype_.Release();
}
inline void SensorDataBatchContract::set_allocated_datatype(std::string* datatype) {
  if (datatype != nullptr) {
    
  } else {
    
  }
  _impl_.datatype_.SetAllocated(datatype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datatype_.IsDefault()) {
    _impl_.datatype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorDataBatchContract.DataType)
}

// optional bool ValueOK = 6;
inline bool SensorDataBatchContract::_internal_has_valueok() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorDataBatchContract::has_valueok() const {
  return _internal_has_valueok();
}
inline void SensorDataBatchContract::clear_valueok() {
  _impl_.valueok_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SensorDataBatchContract::_internal_valueok() const {
  return _impl_.valueok_;
}
inline bool SensorDataBatchContract::valueok() const {
  // @@protoc_insertion_point(field_get:SensorDataBatchContract.ValueOK)
  return _internal_valueok();
}
inline void SensorDataBatchContract::_internal_set_valueok(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.valueok_ = value;
}
inline void SensorDataBatchContract::set_valueok(bool value) {
  _internal_set_valueok(value);
  // @@protoc_insertion_point(field_set:SensorDataBatchContract.ValueOK)
}

// -------------------------------------------------------------------

// SensorAppInfoContract

// string Version = 1;
inline void SensorAppInfoContract::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& SensorAppInfoContract::version() const {
  // @@protoc_insertion_point(field_get:SensorAppInfoContract.Version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorAppInfoContract::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SensorAppInfoContract.Version)
}
inline std::string* SensorAppInfoContract::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:SensorAppInfoContract.Version)
  return _s;
}
inline const std::string& SensorAppInfoContract::_internal_version() const {
  return _impl_.version_.Get();
}
inline void SensorAppInfoContract::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorAppInfoContract::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorAppInfoContract::release_version() {
  // @@protoc_insertion_point(field_release:SensorAppInfoContract.Version)
  return _impl_.version_.Release();
}
inline void SensorAppInfoContract::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SensorAppInfoContract.Version)
}

// int64 Size = 2;
inline void SensorAppInfoContract::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t SensorAppInfoContract::_internal_size() const {
  return _impl_.size_;
}
inline int64_t SensorAppInfoContract::size() const {
  // @@protoc_insertion_point(field_get:SensorAppInfoContract.Size)
  return _internal_size();
}
inline void SensorAppInfoContract::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void SensorAppInfoContract::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SensorAppInfoContract.Size)
}

// -------------------------------------------------------------------

// RangeContract

// string Type = 1;
inline void RangeContract::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& RangeContract::type() const {
  // @@protoc_insertion_point(field_get:RangeContract.Type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeContract::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RangeContract.Type)
}
inline std::string* RangeContract::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:RangeContract.Type)
  return _s;
}
inline const std::string& RangeContract::_internal_type() const {
  return _impl_.type_.Get();
}
inline void RangeContract::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeContract::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeContract::release_type() {
  // @@protoc_insertion_point(field_release:RangeContract.Type)
  return _impl_.type_.Release();
}
inline void RangeContract::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RangeContract.Type)
}

// repeated .RangesContract Ranges = 2;
inline int RangeContract::_internal_ranges_size() const {
  return _impl_.ranges_.size();
}
inline int RangeContract::ranges_size() const {
  return _internal_ranges_size();
}
inline void RangeContract::clear_ranges() {
  _impl_.ranges_.Clear();
}
inline ::RangesContract* RangeContract::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:RangeContract.Ranges)
  return _impl_.ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RangesContract >*
RangeContract::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:RangeContract.Ranges)
  return &_impl_.ranges_;
}
inline const ::RangesContract& RangeContract::_internal_ranges(int index) const {
  return _impl_.ranges_.Get(index);
}
inline const ::RangesContract& RangeContract::ranges(int index) const {
  // @@protoc_insertion_point(field_get:RangeContract.Ranges)
  return _internal_ranges(index);
}
inline ::RangesContract* RangeContract::_internal_add_ranges() {
  return _impl_.ranges_.Add();
}
inline ::RangesContract* RangeContract::add_ranges() {
  ::RangesContract* _add = _internal_add_ranges();
  // @@protoc_insertion_point(field_add:RangeContract.Ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RangesContract >&
RangeContract::ranges() const {
  // @@protoc_insertion_point(field_list:RangeContract.Ranges)
  return _impl_.ranges_;
}

// -------------------------------------------------------------------

// RangesContract

// string Color = 1;
inline void RangesContract::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& RangesContract::color() const {
  // @@protoc_insertion_point(field_get:RangesContract.Color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangesContract::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RangesContract.Color)
}
inline std::string* RangesContract::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:RangesContract.Color)
  return _s;
}
inline const std::string& RangesContract::_internal_color() const {
  return _impl_.color_.Get();
}
inline void RangesContract::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* RangesContract::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* RangesContract::release_color() {
  // @@protoc_insertion_point(field_release:RangesContract.Color)
  return _impl_.color_.Release();
}
inline void RangesContract::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RangesContract.Color)
}

// string Value = 2;
inline void RangesContract::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& RangesContract::value() const {
  // @@protoc_insertion_point(field_get:RangesContract.Value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangesContract::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RangesContract.Value)
}
inline std::string* RangesContract::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:RangesContract.Value)
  return _s;
}
inline const std::string& RangesContract::_internal_value() const {
  return _impl_.value_.Get();
}
inline void RangesContract::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* RangesContract::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* RangesContract::release_value() {
  // @@protoc_insertion_point(field_release:RangesContract.Value)
  return _impl_.value_.Release();
}
inline void RangesContract::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RangesContract.Value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_core_2eproto
